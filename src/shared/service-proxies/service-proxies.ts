/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.2.5.0 (NJsonSchema v9.13.37.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/operator/finally';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 收款
     * @param accounts (optional) 账单Id集合
     * @return Success
     */
    collectAccounts(accounts: string[] | null | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/Account/CollectAccounts?";
        if (accounts !== undefined)
            accounts && accounts.forEach(item => { url_ += "accounts=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCollectAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCollectAccounts(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processCollectAccounts(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }

    /**
     * 取消收款
     * @param accounts (optional) 账单Id集合
     * @return Success
     */
    rCollectAccounts(accounts: string[] | null | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/Account/RCollectAccounts?";
        if (accounts !== undefined)
            accounts && accounts.forEach(item => { url_ += "accounts=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRCollectAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRCollectAccounts(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processRCollectAccounts(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }

    /**
     * 取消结账
     * @param accounts (optional) 
     * @return Success
     */
    rSettleAccount(accounts: string[] | null | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/Account/RSettleAccount?";
        if (accounts !== undefined)
            accounts && accounts.forEach(item => { url_ += "accounts=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRSettleAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRSettleAccount(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processRSettleAccount(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }

    /**
     * 结账
     * @param activitys (optional) 订单Id集合
     * @return Success
     */
    settleAccount(activitys: string[] | null | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/Account/SettleAccount?";
        if (activitys !== undefined)
            activitys && activitys.forEach(item => { url_ += "activitys=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSettleAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSettleAccount(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processSettleAccount(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    activateEmail(input: ActivateEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    impersonate(input: ImpersonateInput | null | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    isTenantAvailable(input: IsTenantAvailableInput | null | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    register(input: RegisterInput | null | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }

    /**
     * 重置密码
     * @param input (optional) 
     * @return Success
     */
    resetPassword(input: ResetPasswordInput | null | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPasswordAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResetPasswordOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResetPasswordOutput>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResetPasswordOutput.fromJS(resultData200) : new ResetPasswordOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResetPasswordOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resolveTenantId(input: ResolveTenantIdInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendEmailActivationLink(input: SendEmailActivationLinkInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendPasswordResetCode(input: SendPasswordResetCodeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    switchToLinkedAccount(input: SwitchToLinkedAccountInput | null | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(<any>response_);
                } catch (e) {
                    return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchToLinkedAccountOutput.fromJS(resultData200) : new SwitchToLinkedAccountOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchToLinkedAccountOutput>(<any>null);
    }
}

@Injectable()
export class ActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Web客户端使用，直接将订单创建到activity表中
     * @param createActivityModel (optional) {
        "sourceId": "54D99CD6-D807-4783-70AA-08D798BCBD02",
        "scheduleId": "829D2F50-D4F8-4D0C-0C2F-08D798BCBD32",
        "payMethodId": "6253E959-5DFD-4CBA-0A7C-08D798BCBC89",
        "activityDetails": [
            {
                "ticketPriceId": "2744AC36-68C4-45E0-1F19-08D798BCBD8A",
                "customerId": "",
            }
        ]
    }
     * @return Success
     */
    createActivity(createActivityModel: CreateActivityModel | null | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/Activity/CreateActivity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createActivityModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateActivity(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processCreateActivity(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBoat(id: string | null | undefined): Observable<Boat> {
        let url_ = this.baseUrl + "/api/Activity/GetBoat?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBoat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBoat(<any>response_);
                } catch (e) {
                    return <Observable<Boat>><any>_observableThrow(e);
                }
            } else
                return <Observable<Boat>><any>_observableThrow(response_);
        }));
    }

    protected processGetBoat(response: HttpResponseBase): Observable<Boat> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Boat.fromJS(resultData200) : new Boat();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Boat>(<any>null);
    }

    /**
     * 查询剩余该航班票数
     * @param scheduleId (optional) 航班Id
     * @return Success
     */
    getExistenTicket(scheduleId: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Activity/GetExistenTicket?";
        if (scheduleId !== undefined)
            url_ += "scheduleId=" + encodeURIComponent("" + scheduleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExistenTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExistenTicket(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetExistenTicket(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Web客户端使用，执行退票操作
     * @param list (optional) 票据Idlist
     * @param rDiscount (optional) 退票折扣
     * @param remark (optional) 备注
     * @return Success
     */
    refundTicket(list: string[] | null | undefined, rDiscount: number | null | undefined, remark: string | null | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/Activity/RefundTicket?";
        if (list !== undefined)
            list && list.forEach(item => { url_ += "list=" + encodeURIComponent("" + item) + "&"; });
        if (rDiscount !== undefined)
            url_ += "rDiscount=" + encodeURIComponent("" + rDiscount) + "&"; 
        if (remark !== undefined)
            url_ += "remark=" + encodeURIComponent("" + remark) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefundTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefundTicket(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processRefundTicket(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }

    /**
     * 设置预留票数
     * @param scheduleId (optional) 航班Id
     * @param reserveQuantity (optional) 预留数
     * @return Success
     */
    setReserveQuantity(scheduleId: string | null | undefined, reserveQuantity: number | null | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/Activity/SetReserveQuantity?";
        if (scheduleId !== undefined)
            url_ += "scheduleId=" + encodeURIComponent("" + scheduleId) + "&"; 
        if (reserveQuantity !== undefined)
            url_ += "reserveQuantity=" + encodeURIComponent("" + reserveQuantity) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetReserveQuantity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetReserveQuantity(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processSetReserveQuantity(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }

    /**
     * 设置各个仓位预留票数
     * @param scheduleId (optional) 
     * @param standardQuantity (optional) 
     * @param vipQuantity (optional) 
     * @param compartmentQuantity (optional) 
     * @param remark (optional) 
     * @return Success
     */
    setReserveQuantityByWare(scheduleId: string | null | undefined, standardQuantity: number | null | undefined, vipQuantity: number | null | undefined, compartmentQuantity: number | null | undefined, remark: string | null | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/Activity/SetReserveQuantityByWare?";
        if (scheduleId !== undefined)
            url_ += "scheduleId=" + encodeURIComponent("" + scheduleId) + "&"; 
        if (standardQuantity !== undefined)
            url_ += "standardQuantity=" + encodeURIComponent("" + standardQuantity) + "&"; 
        if (vipQuantity !== undefined)
            url_ += "vipQuantity=" + encodeURIComponent("" + vipQuantity) + "&"; 
        if (compartmentQuantity !== undefined)
            url_ += "compartmentQuantity=" + encodeURIComponent("" + compartmentQuantity) + "&"; 
        if (remark !== undefined)
            url_ += "remark=" + encodeURIComponent("" + remark) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetReserveQuantityByWare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetReserveQuantityByWare(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processSetReserveQuantityByWare(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }

    /**
     * 合计退票费用
     * @param list (optional) 
     * @param rDiscount (optional) 
     * @return Success
     */
    sumRefund(list: string[] | null | undefined, rDiscount: number | null | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/Activity/SumRefund?";
        if (list !== undefined)
            list && list.forEach(item => { url_ += "list=" + encodeURIComponent("" + item) + "&"; });
        if (rDiscount !== undefined)
            url_ += "rDiscount=" + encodeURIComponent("" + rDiscount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSumRefund(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSumRefund(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processSumRefund(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }

    /**
     * 批量删除Activity的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改Activity的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateActivityInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除Activity信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 销售员售票统计
     * @param queryData (optional) DeviceCode,DeviceName,Port
     * @param certificatesNum (optional) 购票人证件号
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getActivity(queryData: QueryData[] | null | undefined, certificatesNum: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfActivityListDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetActivity?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (certificatesNum !== undefined)
            url_ += "certificatesNum=" + encodeURIComponent("" + certificatesNum) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivity(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActivity(response: HttpResponseBase): Observable<PagedResultDtoOfActivityListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfActivityListDto.fromJS(resultData200) : new PagedResultDtoOfActivityListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityListDto>(<any>null);
    }

    /**
     * 通过指定id获取ActivityListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<ActivityListDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ActivityListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ActivityListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityListDto.fromJS(resultData200) : new ActivityListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityListDto>(<any>null);
    }

    /**
     * 获取编辑 Activity
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetActivityForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetActivityForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetActivityForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetActivityForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetActivityForEditOutput.fromJS(resultData200) : new GetActivityForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetActivityForEditOutput>(<any>null);
    }

    /**
     * 获取Activity的分页列表信息
     * @param input (optional) 
     * @return Success
     */
    getPaged(input: GetActivitysInput | null | undefined): Observable<PagedResultDtoOfActivityListDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfActivityListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfActivityListDto.fromJS(resultData200) : new PagedResultDtoOfActivityListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityListDto>(<any>null);
    }
}

@Injectable()
export class ActivityTempServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 取消暂存订单
     * @param activityTempId (optional) 
     * @return Success
     */
    cancelActivityTemp(activityTempId: string | null | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/ActivityTemp/CancelActivityTemp?";
        if (activityTempId !== undefined)
            url_ += "activityTempId=" + encodeURIComponent("" + activityTempId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelActivityTemp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelActivityTemp(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processCancelActivityTemp(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }

    /**
     * 提交预留订单
     * @param activityTempId (optional) 
     * @return Success
     */
    commitActivityTemp(activityTempId: string | null | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/ActivityTemp/CommitActivityTemp?";
        if (activityTempId !== undefined)
            url_ += "activityTempId=" + encodeURIComponent("" + activityTempId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommitActivityTemp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommitActivityTemp(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processCommitActivityTemp(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }

    /**
     * Web客户端使用，直接将订单创建到activityTemp表中
     * @param createActivityModel (optional) 
     * @return Success
     */
    createActivityTemp(createActivityModel: CreateActivityModel | null | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/ActivityTemp/CreateActivityTemp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createActivityModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateActivityTemp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateActivityTemp(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processCreateActivityTemp(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }

    /**
     * 批量删除ActivityTemp的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTemp/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改ActivityTemp的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateActivityTempInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTemp/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除ActivityTemp信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTemp/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取ActivityTempListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<ActivityTempListDto> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTemp/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ActivityTempListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityTempListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ActivityTempListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityTempListDto.fromJS(resultData200) : new ActivityTempListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityTempListDto>(<any>null);
    }

    /**
     * 获取编辑 ActivityTemp
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetActivityTempForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTemp/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetActivityTempForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetActivityTempForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetActivityTempForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetActivityTempForEditOutput.fromJS(resultData200) : new GetActivityTempForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetActivityTempForEditOutput>(<any>null);
    }

    /**
     * 获取ActivityTemp的分页列表信息
     * @param input (optional) 
     * @return Success
     */
    getPaged(input: GetActivityTempsInput | null | undefined): Observable<PagedResultDtoOfActivityTempListDto> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTemp/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityTempListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityTempListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfActivityTempListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfActivityTempListDto.fromJS(resultData200) : new PagedResultDtoOfActivityTempListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityTempListDto>(<any>null);
    }
}

@Injectable()
export class CheckTicketServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 卡验票
     * @param gateNumber (optional) 设备号
     * @param jqmpass (optional) 卡号
     * @param rdindex (optional) 串口号
     * @return Success
     */
    cardOpenGet(gateNumber: string | null | undefined, jqmpass: string | null | undefined, rdindex: string | null | undefined): Observable<CheckResult> {
        let url_ = this.baseUrl + "/api/CheckTicket/CardOpen?";
        if (gateNumber !== undefined)
            url_ += "gateNumber=" + encodeURIComponent("" + gateNumber) + "&"; 
        if (jqmpass !== undefined)
            url_ += "jqmpass=" + encodeURIComponent("" + jqmpass) + "&"; 
        if (rdindex !== undefined)
            url_ += "rdindex=" + encodeURIComponent("" + rdindex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCardOpenGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCardOpenGet(<any>response_);
                } catch (e) {
                    return <Observable<CheckResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckResult>><any>_observableThrow(response_);
        }));
    }

    protected processCardOpenGet(response: HttpResponseBase): Observable<CheckResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckResult.fromJS(resultData200) : new CheckResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckResult>(<any>null);
    }

    /**
     * 卡验票
     * @param gateNumber (optional) 设备号
     * @param jqmpass (optional) 卡号
     * @param rdindex (optional) 串口号
     * @return Success
     */
    cardOpenPost(gateNumber: string | null | undefined, jqmpass: string | null | undefined, rdindex: string | null | undefined): Observable<CheckResult> {
        let url_ = this.baseUrl + "/api/CheckTicket/CardOpen?";
        if (gateNumber !== undefined)
            url_ += "gateNumber=" + encodeURIComponent("" + gateNumber) + "&"; 
        if (jqmpass !== undefined)
            url_ += "jqmpass=" + encodeURIComponent("" + jqmpass) + "&"; 
        if (rdindex !== undefined)
            url_ += "rdindex=" + encodeURIComponent("" + rdindex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCardOpenPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCardOpenPost(<any>response_);
                } catch (e) {
                    return <Observable<CheckResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckResult>><any>_observableThrow(response_);
        }));
    }

    protected processCardOpenPost(response: HttpResponseBase): Observable<CheckResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckResult.fromJS(resultData200) : new CheckResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckResult>(<any>null);
    }

    /**
     * 二维码验票
     * @param gateNumber (optional) 
     * @param jqmpass (optional) 
     * @param rdindex (optional) 
     * @return Success
     */
    scancodeopenGet(gateNumber: string | null | undefined, jqmpass: string | null | undefined, rdindex: string | null | undefined): Observable<CheckResult> {
        let url_ = this.baseUrl + "/api/CheckTicket/Scancodeopen?";
        if (gateNumber !== undefined)
            url_ += "gateNumber=" + encodeURIComponent("" + gateNumber) + "&"; 
        if (jqmpass !== undefined)
            url_ += "jqmpass=" + encodeURIComponent("" + jqmpass) + "&"; 
        if (rdindex !== undefined)
            url_ += "rdindex=" + encodeURIComponent("" + rdindex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScancodeopenGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScancodeopenGet(<any>response_);
                } catch (e) {
                    return <Observable<CheckResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckResult>><any>_observableThrow(response_);
        }));
    }

    protected processScancodeopenGet(response: HttpResponseBase): Observable<CheckResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckResult.fromJS(resultData200) : new CheckResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckResult>(<any>null);
    }

    /**
     * 二维码验票
     * @param gateNumber (optional) 
     * @param jqmpass (optional) 
     * @param rdindex (optional) 
     * @return Success
     */
    scancodeopenPost(gateNumber: string | null | undefined, jqmpass: string | null | undefined, rdindex: string | null | undefined): Observable<CheckResult> {
        let url_ = this.baseUrl + "/api/CheckTicket/Scancodeopen?";
        if (gateNumber !== undefined)
            url_ += "gateNumber=" + encodeURIComponent("" + gateNumber) + "&"; 
        if (jqmpass !== undefined)
            url_ += "jqmpass=" + encodeURIComponent("" + jqmpass) + "&"; 
        if (rdindex !== undefined)
            url_ += "rdindex=" + encodeURIComponent("" + rdindex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScancodeopenPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScancodeopenPost(<any>response_);
                } catch (e) {
                    return <Observable<CheckResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckResult>><any>_observableThrow(response_);
        }));
    }

    protected processScancodeopenPost(response: HttpResponseBase): Observable<CheckResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckResult.fromJS(resultData200) : new CheckResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckResult>(<any>null);
    }
}

@Injectable()
export class HistoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 过闸统计
     * @param queryData (optional) DeviceId 设备类型，Device.DeviceName 设备名称, CreatorUserId 操作员ID，CreationTime 检票时间
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param ticketId (optional) 票型ID
     * @param scheduleId (optional) 航班ID
     * @return Success
     */
    getPagedStat(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined, ticketId: string | null | undefined, scheduleId: string | null | undefined): Observable<PagedResultDtoOfGateHistoryResultDto> {
        let url_ = this.baseUrl + "/api/CheckTicket/History/GetPagedStat?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&"; 
        if (scheduleId !== undefined)
            url_ += "scheduleId=" + encodeURIComponent("" + scheduleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedStat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedStat(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGateHistoryResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGateHistoryResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedStat(response: HttpResponseBase): Observable<PagedResultDtoOfGateHistoryResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGateHistoryResultDto.fromJS(resultData200) : new PagedResultDtoOfGateHistoryResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGateHistoryResultDto>(<any>null);
    }
}

@Injectable()
export class RecordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 获取过闸记录的查询条件下拉框值
     * @return Success
     */
    filters(): Observable<GateRecordFilters> {
        let url_ = this.baseUrl + "/api/CheckTicket/Record/Filters";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFilters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFilters(<any>response_);
                } catch (e) {
                    return <Observable<GateRecordFilters>><any>_observableThrow(e);
                }
            } else
                return <Observable<GateRecordFilters>><any>_observableThrow(response_);
        }));
    }

    protected processFilters(response: HttpResponseBase): Observable<GateRecordFilters> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GateRecordFilters.fromJS(resultData200) : new GateRecordFilters();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GateRecordFilters>(<any>null);
    }

    /**
     * 过闸记录
     * @param queryData (optional) DeviceId 设备类型，DeviceName 设备名称，TicketId 票型，
    TicketNo 票码，CheckerId 操作员Id，StatusCode 检票状态，
    CreationTime 检票时间
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPagedStat(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<StatsPagedResultDtoOfGateRecordResultDto> {
        let url_ = this.baseUrl + "/api/CheckTicket/Record/GetPagedStat?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedStat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedStat(<any>response_);
                } catch (e) {
                    return <Observable<StatsPagedResultDtoOfGateRecordResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatsPagedResultDtoOfGateRecordResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedStat(response: HttpResponseBase): Observable<StatsPagedResultDtoOfGateRecordResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StatsPagedResultDtoOfGateRecordResultDto.fromJS(resultData200) : new StatsPagedResultDtoOfGateRecordResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatsPagedResultDtoOfGateRecordResultDto>(<any>null);
    }
}

@Injectable()
export class FileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    downloadFilePathFile(fileName: string, fileType: string, fileToken: string): Observable<void> {
        let url_ = this.baseUrl + "/api/File/DownloadFilePathFile?";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined and cannot be null.");
        else
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&"; 
        if (fileType === undefined || fileType === null)
            throw new Error("The parameter 'fileType' must be defined and cannot be null.");
        else
            url_ += "fileType=" + encodeURIComponent("" + fileType) + "&"; 
        if (fileToken === undefined || fileToken === null)
            throw new Error("The parameter 'fileToken' must be defined and cannot be null.");
        else
            url_ += "fileToken=" + encodeURIComponent("" + fileToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFilePathFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFilePathFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFilePathFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    downloadTempFile(fileName: string, fileType: string, fileToken: string): Observable<void> {
        let url_ = this.baseUrl + "/api/File/DownloadTempFile?";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined and cannot be null.");
        else
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&"; 
        if (fileType === undefined || fileType === null)
            throw new Error("The parameter 'fileType' must be defined and cannot be null.");
        else
            url_ += "fileType=" + encodeURIComponent("" + fileType) + "&"; 
        if (fileToken === undefined || fileToken === null)
            throw new Error("The parameter 'fileToken' must be defined and cannot be null.");
        else
            url_ += "fileToken=" + encodeURIComponent("" + fileToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadTempFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadTempFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadTempFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 上传版本文件
     * @param file (optional) 版本名称_版本代码_版本名称_(d|D)设备类型枚举号_xxx.apk 如：开发版V2手持机_120_v1.2_d4_hnhuyhhnyhnhn_888.apk
     * @return Success
     */
    uploadClient(file: FileParameter | null | undefined): Observable<ClientVersionListDto> {
        let url_ = this.baseUrl + "/api/File/UploadClientAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadClient(<any>response_);
                } catch (e) {
                    return <Observable<ClientVersionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientVersionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processUploadClient(response: HttpResponseBase): Observable<ClientVersionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClientVersionListDto.fromJS(resultData200) : new ClientVersionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientVersionListDto>(<any>null);
    }

    /**
     * 上传图片
     * @param file (optional) 
     * @return Success
     */
    uploadImage(file: FileParameter | null | undefined): Observable<PictureResultDto> {
        let url_ = this.baseUrl + "/api/File/UploadImageAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(<any>response_);
                } catch (e) {
                    return <Observable<PictureResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PictureResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<PictureResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PictureResultDto.fromJS(resultData200) : new PictureResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PictureResultDto>(<any>null);
    }
}

@Injectable()
export class AccountDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除AccountDetail的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountDetail/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改AccountDetail的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateAccountDetailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountDetail/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除AccountDetail信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountDetail/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取AccountDetailListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<AccountDetailListDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountDetail/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<AccountDetailListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountDetailListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<AccountDetailListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccountDetailListDto.fromJS(resultData200) : new AccountDetailListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDetailListDto>(<any>null);
    }

    /**
     * 获取编辑 AccountDetail
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetAccountDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AccountDetail/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAccountDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAccountDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetAccountDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetAccountDetailForEditOutput.fromJS(resultData200) : new GetAccountDetailForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAccountDetailForEditOutput>(<any>null);
    }

    /**
     * 获取AccountDetail的分页列表信息
     * @param queryData (optional) DeviceCode,DeviceName,Port
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfAccountDetailListDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountDetail/GetPaged?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAccountDetailListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAccountDetailListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfAccountDetailListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAccountDetailListDto.fromJS(resultData200) : new PagedResultDtoOfAccountDetailListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAccountDetailListDto>(<any>null);
    }
}

@Injectable()
export class ActivityDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除ActivityDetail的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityDetail/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改ActivityDetail的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateActivityDetailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityDetail/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除ActivityDetail信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityDetail/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取ActivityDetailListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<ActivityDetailListDto> {
        let url_ = this.baseUrl + "/api/services/app/ActivityDetail/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ActivityDetailListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityDetailListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ActivityDetailListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityDetailListDto.fromJS(resultData200) : new ActivityDetailListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityDetailListDto>(<any>null);
    }

    /**
     * 获取编辑 ActivityDetail
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetActivityDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ActivityDetail/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetActivityDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetActivityDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetActivityDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetActivityDetailForEditOutput.fromJS(resultData200) : new GetActivityDetailForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetActivityDetailForEditOutput>(<any>null);
    }

    /**
     * 获取ActivityDetail的分页列表信息
     * @param queryData (optional) DeviceCode,DeviceName,Port
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfActivityDetailListDto> {
        let url_ = this.baseUrl + "/api/services/app/ActivityDetail/GetPaged?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityDetailListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityDetailListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfActivityDetailListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfActivityDetailListDto.fromJS(resultData200) : new PagedResultDtoOfActivityDetailListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityDetailListDto>(<any>null);
    }
}

@Injectable()
export class ActivityTempDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除ActivityTempDetail的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTempDetail/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改ActivityTempDetail的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateActivityTempDetailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTempDetail/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除ActivityTempDetail信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTempDetail/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取ActivityTempDetailListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<ActivityTempDetailListDto> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTempDetail/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ActivityTempDetailListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityTempDetailListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ActivityTempDetailListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityTempDetailListDto.fromJS(resultData200) : new ActivityTempDetailListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityTempDetailListDto>(<any>null);
    }

    /**
     * 根据预留订单id查询订单明细
     * @param activityTempId (optional) 
     * @return Success
     */
    getDetailListByTempId(activityTempId: string | null | undefined): Observable<ActivityTempDetailListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTempDetail/GetDetailListByTempId?";
        if (activityTempId !== undefined)
            url_ += "activityTempId=" + encodeURIComponent("" + activityTempId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetailListByTempId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetailListByTempId(<any>response_);
                } catch (e) {
                    return <Observable<ActivityTempDetailListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityTempDetailListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetailListByTempId(response: HttpResponseBase): Observable<ActivityTempDetailListDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ActivityTempDetailListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityTempDetailListDto[]>(<any>null);
    }

    /**
     * 获取编辑 ActivityTempDetail
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetActivityTempDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTempDetail/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetActivityTempDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetActivityTempDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetActivityTempDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetActivityTempDetailForEditOutput.fromJS(resultData200) : new GetActivityTempDetailForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetActivityTempDetailForEditOutput>(<any>null);
    }

    /**
     * 获取ActivityTempDetail的分页列表信息
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfActivityTempDetailListDto> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTempDetail/GetPaged?";
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityTempDetailListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityTempDetailListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfActivityTempDetailListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfActivityTempDetailListDto.fromJS(resultData200) : new PagedResultDtoOfActivityTempDetailListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityTempDetailListDto>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 开始时间
     * @param endDate (optional) 结束时间
     * @param userName (optional) 用户名
     * @param serviceName (optional) 服务名称
     * @param methodName (optional) 方法名称
     * @param browserInfo (optional) 浏览器信息
     * @param hasException (optional) 是否包含异常
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogsToExcelAsync?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "serviceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "methodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "browserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "hasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "minExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "maxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChanges?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "entityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfEntityChangeListDto.fromJS(resultData200) : new PagedResultDtoOfEntityChangeListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChangesToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChangesToExcel?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "entityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChangesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @param startDate (optional) 开始时间
     * @param endDate (optional) 结束时间
     * @param userName (optional) 用户名
     * @param serviceName (optional) 服务名称
     * @param methodName (optional) 方法名称
     * @param browserInfo (optional) 浏览器信息
     * @param hasException (optional) 是否包含异常
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPagedAuditLogs(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetPagedAuditLogs?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "serviceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "methodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "browserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "hasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "minExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "maxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAuditLogListDto.fromJS(resultData200) : new PagedResultDtoOfAuditLogListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAuditLogListDto>(<any>null);
    }

    /**
     * 登录日志查询
     * @param startDate (optional) 开始时间
     * @param endDate (optional) 结束时间
     * @param userName (optional) 登录用户名或邮箱
     * @param sourceName (optional) 登录端
     * @param sourceCode (optional) 登录端编码
     * @param clientIpAddress (optional) IP地址
     * @param hasException (optional) 是否包含异常
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPagedLoginLogs(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, sourceName: string | null | undefined, sourceCode: string | null | undefined, clientIpAddress: string | null | undefined, hasException: boolean | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfLoginLogModel> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetPagedLoginLogs?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&"; 
        if (sourceName !== undefined)
            url_ += "sourceName=" + encodeURIComponent("" + sourceName) + "&"; 
        if (sourceCode !== undefined)
            url_ += "sourceCode=" + encodeURIComponent("" + sourceCode) + "&"; 
        if (clientIpAddress !== undefined)
            url_ += "clientIpAddress=" + encodeURIComponent("" + clientIpAddress) + "&"; 
        if (hasException !== undefined)
            url_ += "hasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedLoginLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedLoginLogs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLoginLogModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLoginLogModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedLoginLogs(response: HttpResponseBase): Observable<PagedResultDtoOfLoginLogModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLoginLogModel.fromJS(resultData200) : new PagedResultDtoOfLoginLogModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLoginLogModel>(<any>null);
    }
}

@Injectable()
export class BoatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Boat的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Boat/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改Boat的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateBoatInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Boat/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除Boat信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Boat/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取BoatListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<BoatListDto> {
        let url_ = this.baseUrl + "/api/services/app/Boat/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<BoatListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BoatListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<BoatListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BoatListDto.fromJS(resultData200) : new BoatListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BoatListDto>(<any>null);
    }

    /**
     * 获取编辑 Boat
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetBoatForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Boat/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBoatForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBoatForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetBoatForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetBoatForEditOutput.fromJS(resultData200) : new GetBoatForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBoatForEditOutput>(<any>null);
    }

    /**
     * 获取Boat的分页列表信息
     * @param input (optional) 
     * @return Success
     */
    getPaged(input: GetBoatsInput | null | undefined): Observable<PagedResultDtoOfBoatListDto> {
        let url_ = this.baseUrl + "/api/services/app/Boat/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBoatListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBoatListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfBoatListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfBoatListDto.fromJS(resultData200) : new PagedResultDtoOfBoatListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBoatListDto>(<any>null);
    }

    /**
     * 从Excel表导入数据
     * @param file (optional) 
     * @return Success
     */
    importBoat(file: FileParameter | null | undefined): Observable<ExcelResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Boat/ImportBoat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportBoat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportBoat(<any>response_);
                } catch (e) {
                    return <Observable<ExcelResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExcelResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportBoat(response: HttpResponseBase): Observable<ExcelResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExcelResultDto.fromJS(resultData200) : new ExcelResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExcelResultDto>(<any>null);
    }
}

@Injectable()
export class BooksServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Book的方法
     * @param input (optional) 
     * @return Success
     */
    batchDeleteBook(input: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Books/BatchDeleteBook";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDeleteBook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDeleteBook(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDeleteBook(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改Book的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateBook(input: CreateOrUpdateBookInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Books/CreateOrUpdateBook";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateBook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateBook(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateBook(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除Book信息的方法
     * @param id (optional) 
     * @return Success
     */
    deleteBook(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Books/DeleteBook?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBook(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBook(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取BookListDto信息
     * @param id (optional) 
     * @return Success
     */
    getBookById(id: number | null | undefined): Observable<BookListDto> {
        let url_ = this.baseUrl + "/api/services/app/Books/GetBookById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBookById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBookById(<any>response_);
                } catch (e) {
                    return <Observable<BookListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BookListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBookById(response: HttpResponseBase): Observable<BookListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BookListDto.fromJS(resultData200) : new BookListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BookListDto>(<any>null);
    }

    /**
     * 获取编辑 Book
     * @param id (optional) 
     * @return Success
     */
    getBookForEdit(id: number | null | undefined): Observable<GetBookForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Books/GetBookForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBookForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBookForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBookForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBookForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBookForEdit(response: HttpResponseBase): Observable<GetBookForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetBookForEditOutput.fromJS(resultData200) : new GetBookForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBookForEditOutput>(<any>null);
    }

    /**
     * 获取Book的分页列表信息
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPagedBook(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfBookListDto> {
        let url_ = this.baseUrl + "/api/services/app/Books/GetPagedBook?";
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedBook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedBook(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBookListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBookListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedBook(response: HttpResponseBase): Observable<PagedResultDtoOfBookListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfBookListDto.fromJS(resultData200) : new PagedResultDtoOfBookListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBookListDto>(<any>null);
    }
}

@Injectable()
export class BranchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Branch的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Branch/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改Branch的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateBranchInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Branch/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除Branch信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Branch/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取BranchListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<BranchListDto> {
        let url_ = this.baseUrl + "/api/services/app/Branch/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<BranchListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BranchListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<BranchListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BranchListDto.fromJS(resultData200) : new BranchListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BranchListDto>(<any>null);
    }

    /**
     * 获取编辑 Branch
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetBranchForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Branch/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBranchForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBranchForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetBranchForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetBranchForEditOutput.fromJS(resultData200) : new GetBranchForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBranchForEditOutput>(<any>null);
    }

    /**
     * 获取Branch的分页列表信息
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfBranchListDto> {
        let url_ = this.baseUrl + "/api/services/app/Branch/GetPaged?";
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBranchListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBranchListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfBranchListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfBranchListDto.fromJS(resultData200) : new PagedResultDtoOfBranchListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBranchListDto>(<any>null);
    }

    /**
     * 导出Branch为excel表。
     * @return Success
     */
    getToExcel(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Branch/GetToExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class BranchListExcelExporterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param branchListDtos (optional) 
     * @return Success
     */
    exportToExcel(branchListDtos: BranchListDto[] | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BranchListExcelExporter/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(branchListDtos);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class BranchUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除BranchUser的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BranchUser/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改BranchUser的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateBranchUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BranchUser/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除BranchUser信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BranchUser/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取BranchUserListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<BranchUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/BranchUser/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<BranchUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BranchUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<BranchUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BranchUserListDto.fromJS(resultData200) : new BranchUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BranchUserListDto>(<any>null);
    }

    /**
     * 获取编辑 BranchUser
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetBranchUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BranchUser/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBranchUserForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBranchUserForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetBranchUserForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetBranchUserForEditOutput.fromJS(resultData200) : new GetBranchUserForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBranchUserForEditOutput>(<any>null);
    }

    /**
     * 获取BranchUser的分页列表信息
     * @param queryData (optional) User.XX,Branch.XX
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfBranchUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/BranchUser/GetPaged?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBranchUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBranchUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfBranchUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfBranchUserListDto.fromJS(resultData200) : new PagedResultDtoOfBranchUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBranchUserListDto>(<any>null);
    }
}

@Injectable()
export class CheckRecordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除CheckRecord的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CheckRecord/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改CheckRecord的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateCheckRecordInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CheckRecord/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除CheckRecord信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CheckRecord/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取CheckRecordListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<CheckRecordListDto> {
        let url_ = this.baseUrl + "/api/services/app/CheckRecord/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<CheckRecordListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckRecordListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CheckRecordListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckRecordListDto.fromJS(resultData200) : new CheckRecordListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckRecordListDto>(<any>null);
    }

    /**
     * 获取编辑 CheckRecord
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetCheckRecordForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/CheckRecord/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCheckRecordForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCheckRecordForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetCheckRecordForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCheckRecordForEditOutput.fromJS(resultData200) : new GetCheckRecordForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCheckRecordForEditOutput>(<any>null);
    }

    /**
     * 获取CheckRecord的分页列表信息
     * @param queryData (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfCheckRecordListDto> {
        let url_ = this.baseUrl + "/api/services/app/CheckRecord/GetPaged?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCheckRecordListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCheckRecordListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfCheckRecordListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCheckRecordListDto.fromJS(resultData200) : new PagedResultDtoOfCheckRecordListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCheckRecordListDto>(<any>null);
    }
}

@Injectable()
export class ClientVersionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除ClientVersion的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ClientVersion/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改ClientVersion的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateClientVersionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ClientVersion/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除ClientVersion信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ClientVersion/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取ClientVersionListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<ClientVersionListDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientVersion/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ClientVersionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientVersionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ClientVersionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClientVersionListDto.fromJS(resultData200) : new ClientVersionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientVersionListDto>(<any>null);
    }

    /**
     * 获取编辑 ClientVersion
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetClientVersionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ClientVersion/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetClientVersionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetClientVersionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetClientVersionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetClientVersionForEditOutput.fromJS(resultData200) : new GetClientVersionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetClientVersionForEditOutput>(<any>null);
    }

    /**
     * 获取ClientVersion的分页列表信息
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfClientVersionListDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientVersion/GetPaged?";
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfClientVersionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfClientVersionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfClientVersionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfClientVersionListDto.fromJS(resultData200) : new PagedResultDtoOfClientVersionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfClientVersionListDto>(<any>null);
    }
}

@Injectable()
export class CommonCustomerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除CommonCustomer的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CommonCustomer/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 创建常用游客
     * @param input (optional) 
     * @return Success
     */
    createCommonCustomer(input: CreateOrUpdateCommonCustomerInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CommonCustomer/CreateCommonCustomer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCommonCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCommonCustomer(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCommonCustomer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateCommonCustomerInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CommonCustomer/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CommonCustomer/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取CommonCustomerListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<CommonCustomerListDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonCustomer/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<CommonCustomerListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonCustomerListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CommonCustomerListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonCustomerListDto.fromJS(resultData200) : new CommonCustomerListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonCustomerListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetCommonCustomerForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommonCustomer/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCommonCustomerForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCommonCustomerForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetCommonCustomerForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCommonCustomerForEditOutput.fromJS(resultData200) : new GetCommonCustomerForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCommonCustomerForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param openId (optional) 主游客openId
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(openId: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfCommonCustomerListDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonCustomer/GetPaged?";
        if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCommonCustomerListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCommonCustomerListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfCommonCustomerListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCommonCustomerListDto.fromJS(resultData200) : new PagedResultDtoOfCommonCustomerListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCommonCustomerListDto>(<any>null);
    }

    /**
     * 导出为excel文件
     * @return Success
     */
    getToExcelFile(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonCustomer/GetToExcelFile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToExcelFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToExcelFile(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetToExcelFile(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    findUsers(input: CommonLookupFindUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(<any>response_);
                } catch (e) {
                    return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDefaultEditionNameOutput.fromJS(resultData200) : new GetDefaultEditionNameOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDefaultEditionNameOutput>(<any>null);
    }

    /**
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | null | undefined): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200) : new ListResultDtoOfSubscribableEditionComboboxItemDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSubscribableEditionComboboxItemDto>(<any>null);
    }

    /**
     * @return Success
     */
    getValidateCodeTypesForCombobox(): Observable<ListResultDtoOfComboboxItemDtoTOfInt32> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetValidateCodeTypesForCombobox";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetValidateCodeTypesForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetValidateCodeTypesForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfComboboxItemDtoTOfInt32>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfComboboxItemDtoTOfInt32>><any>_observableThrow(response_);
        }));
    }

    protected processGetValidateCodeTypesForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfComboboxItemDtoTOfInt32> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfComboboxItemDtoTOfInt32.fromJS(resultData200) : new ListResultDtoOfComboboxItemDtoTOfInt32();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfComboboxItemDtoTOfInt32>(<any>null);
    }
}

@Injectable()
export class CustomerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Customer的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Customer/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 批量插入游客信息
     * @param customers (optional) 游客信息列表
     * @param operation (optional) 有错误时，操作选择，默认提示报错，1表示替换该游客信息，2表是跳过该游客信息，
     * @return Success
     */
    batchInsertCustomer(customers: CustomerEditDto[] | null | undefined, operation: string | null | undefined): Observable<AjaxResult> {
        let url_ = this.baseUrl + "/api/services/app/Customer/BatchInsertCustomer?";
        if (operation !== undefined)
            url_ += "operation=" + encodeURIComponent("" + operation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(customers);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchInsertCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchInsertCustomer(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AjaxResult>><any>_observableThrow(response_);
        }));
    }

    protected processBatchInsertCustomer(response: HttpResponseBase): Observable<AjaxResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AjaxResult.fromJS(resultData200) : new AjaxResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AjaxResult>(<any>null);
    }

    /**
     * 添加或者修改Customer的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateCustomerInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Customer/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加Customer的公共方法,带有返回值
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateReturn(input: CreateOrUpdateCustomerInput | null | undefined): Observable<CustomerExistsDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/CreateOrUpdateReturn";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateReturn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateReturn(<any>response_);
                } catch (e) {
                    return <Observable<CustomerExistsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerExistsDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateReturn(response: HttpResponseBase): Observable<CustomerExistsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerExistsDto.fromJS(resultData200) : new CustomerExistsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerExistsDto>(<any>null);
    }

    /**
     * 官网注册
     * @param input (optional) 
     * @return Success
     */
    createUser(input: CreateOrUpdateCustomerInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Customer/CreateUserAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除Customer信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Customer/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 根据证件ID查询客户，如果客户存在，则返回客户信息
     * @param identity (optional) 
     * @return Success
     */
    exists(identity: string | null | undefined): Observable<CustomerExistsDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/Exists?";
        if (identity !== undefined)
            url_ += "identity=" + encodeURIComponent("" + identity) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExists(<any>response_);
                } catch (e) {
                    return <Observable<CustomerExistsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerExistsDto>><any>_observableThrow(response_);
        }));
    }

    protected processExists(response: HttpResponseBase): Observable<CustomerExistsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerExistsDto.fromJS(resultData200) : new CustomerExistsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerExistsDto>(<any>null);
    }

    /**
     * 通过指定id获取CustomerListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<CustomerListDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<CustomerListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CustomerListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerListDto.fromJS(resultData200) : new CustomerListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerListDto>(<any>null);
    }

    /**
     * 通过指定Openid获取CustomerListDto信息
     * @param openId (optional) 
     * @return Success
     */
    getByOpenId(openId: string | null | undefined): Observable<CustomerListDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetByOpenId?";
        if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByOpenId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByOpenId(<any>response_);
                } catch (e) {
                    return <Observable<CustomerListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetByOpenId(response: HttpResponseBase): Observable<CustomerListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerListDto.fromJS(resultData200) : new CustomerListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerListDto>(<any>null);
    }

    /**
     * 获取编辑 Customer
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetCustomerForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetCustomerForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCustomerForEditOutput.fromJS(resultData200) : new GetCustomerForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerForEditOutput>(<any>null);
    }

    /**
     * 获取Customer的分页列表信息
     * @param input (optional) 
     * @return Success
     */
    getPaged(input: GetCustomersInput | null | undefined): Observable<PagedResultDtoOfCustomerListDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCustomerListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCustomerListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfCustomerListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCustomerListDto.fromJS(resultData200) : new PagedResultDtoOfCustomerListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCustomerListDto>(<any>null);
    }

    /**
     * 导出Customer为excel表,等待开发。
     * @return Success
     */
    getToExcel(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetToExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * 从Excel表导入数据
     * @param file (optional) 文件
     * @param operation (optional) 有错误时，操作选择，默认提示报错，1表示替换该游客信息，2表是跳过该游客信息，
     * @return Success
     */
    importCustomer(file: FileParameter | null | undefined, operation: string | null | undefined): Observable<AjaxResult> {
        let url_ = this.baseUrl + "/api/services/app/Customer/ImportCustomer?";
        if (operation !== undefined)
            url_ += "operation=" + encodeURIComponent("" + operation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportCustomer(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AjaxResult>><any>_observableThrow(response_);
        }));
    }

    protected processImportCustomer(response: HttpResponseBase): Observable<AjaxResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AjaxResult.fromJS(resultData200) : new AjaxResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AjaxResult>(<any>null);
    }

    /**
     * 上传客户照片
     * @param file (optional) 
     * @return Success
     */
    userPicture(file: FileParameter | null | undefined): Observable<UploadUserPictureResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/UserPicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserPicture(<any>response_);
                } catch (e) {
                    return <Observable<UploadUserPictureResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UploadUserPictureResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUserPicture(response: HttpResponseBase): Observable<UploadUserPictureResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UploadUserPictureResultDto.fromJS(resultData200) : new UploadUserPictureResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UploadUserPictureResultDto>(<any>null);
    }

    /**
     * 上传客户照片
     * @param userPictureDto (optional) 
     * @return Success
     */
    userPictureBase64(userPictureDto: UploadUserPictureDto | null | undefined): Observable<UploadUserPictureResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/UserPictureBase64";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userPictureDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserPictureBase64(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserPictureBase64(<any>response_);
                } catch (e) {
                    return <Observable<UploadUserPictureResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UploadUserPictureResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUserPictureBase64(response: HttpResponseBase): Observable<UploadUserPictureResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UploadUserPictureResultDto.fromJS(resultData200) : new UploadUserPictureResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UploadUserPictureResultDto>(<any>null);
    }
}

@Injectable()
export class CustomListExcelExporterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param customerListDtos (optional) 
     * @return Success
     */
    exportToExcel(customerListDtos: CustomerListDto[] | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomListExcelExporter/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(customerListDtos);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class DateDictionaryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除DateDictionary的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DateDictionary/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改DateDictionary的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateDateDictionaryInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DateDictionary/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除DateDictionary信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DateDictionary/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取DateDictionaryListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<DateDictionaryListDto> {
        let url_ = this.baseUrl + "/api/services/app/DateDictionary/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<DateDictionaryListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateDictionaryListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<DateDictionaryListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateDictionaryListDto.fromJS(resultData200) : new DateDictionaryListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateDictionaryListDto>(<any>null);
    }

    /**
     * 获取编辑 DateDictionary
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetDateDictionaryForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/DateDictionary/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetDateDictionaryForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDateDictionaryForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetDateDictionaryForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDateDictionaryForEditOutput.fromJS(resultData200) : new GetDateDictionaryForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDateDictionaryForEditOutput>(<any>null);
    }

    /**
     * 获取DateDictionary的分页列表信息
     * @param queryData (optional) DeviceCode,DeviceName,Port
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDateDictionaryListDto> {
        let url_ = this.baseUrl + "/api/services/app/DateDictionary/GetPaged?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDateDictionaryListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDateDictionaryListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfDateDictionaryListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDateDictionaryListDto.fromJS(resultData200) : new PagedResultDtoOfDateDictionaryListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDateDictionaryListDto>(<any>null);
    }
}

@Injectable()
export class DeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Device的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Device/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改Device的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateDeviceInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Device/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除Device信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Device/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取DeviceListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<DeviceListDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<DeviceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<DeviceListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DeviceListDto.fromJS(resultData200) : new DeviceListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceListDto>(<any>null);
    }

    /**
     * 获取编辑 Device
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetDeviceForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetDeviceForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDeviceForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetDeviceForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDeviceForEditOutput.fromJS(resultData200) : new GetDeviceForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDeviceForEditOutput>(<any>null);
    }

    /**
     * 根据设备编号获取证件类型
     * @param deviceCode (optional) 设备编号
     * @return Success
     */
    getIdentityType(deviceCode: string | null | undefined): Observable<IdentityTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetIdentityType?";
        if (deviceCode !== undefined)
            url_ += "deviceCode=" + encodeURIComponent("" + deviceCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIdentityType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIdentityType(<any>response_);
                } catch (e) {
                    return <Observable<IdentityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdentityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetIdentityType(response: HttpResponseBase): Observable<IdentityTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(IdentityTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdentityTypeDto[]>(<any>null);
    }

    /**
     * 获取Device的分页列表信息--Post方法
     * @param input (optional) 
     * @return Success
     */
    getPaged(input: GetDevicesInput | null | undefined): Observable<PagedResultDtoOfDeviceListDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDeviceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDeviceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDeviceListDto.fromJS(resultData200) : new PagedResultDtoOfDeviceListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDeviceListDto>(<any>null);
    }

    /**
     * 获取Device的分页列表信息--Get方法
     * @param queryData (optional) DeviceCode,DeviceName,Port
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPagedForGet(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDeviceListDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetPagedForGet?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedForGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedForGet(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDeviceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDeviceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedForGet(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDeviceListDto.fromJS(resultData200) : new PagedResultDtoOfDeviceListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDeviceListDto>(<any>null);
    }

    /**
     * 客户端每分钟发送一次心跳包
     * @param gateNumber (optional) 
     * @return Success
     */
    heartBeat(gateNumber: string | null | undefined): Observable<HeartBeatResult> {
        let url_ = this.baseUrl + "/api/services/app/Device/HeartBeat?";
        if (gateNumber !== undefined)
            url_ += "gateNumber=" + encodeURIComponent("" + gateNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHeartBeat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHeartBeat(<any>response_);
                } catch (e) {
                    return <Observable<HeartBeatResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<HeartBeatResult>><any>_observableThrow(response_);
        }));
    }

    protected processHeartBeat(response: HttpResponseBase): Observable<HeartBeatResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HeartBeatResult.fromJS(resultData200) : new HeartBeatResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HeartBeatResult>(<any>null);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateEdition(input: CreateOrUpdateEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/CreateOrUpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteEdition(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/DeleteEdition?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param selectedEditionId (optional) 
     * @param addAllItem (optional) 
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | null | undefined, addAllItem: boolean | null | undefined, onlyFreeItems: boolean | null | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionComboboxItems?";
        if (selectedEditionId !== undefined)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&"; 
        if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&"; 
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribableEditionComboboxItemDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number | null | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionEditOutput.fromJS(resultData200) : new GetEditionEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionEditOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getEditions(): Observable<ListResultDtoOfEditionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<ListResultDtoOfEditionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfEditionListDto.fromJS(resultData200) : new ListResultDtoOfEditionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfEditionListDto>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getTenantCount(editionId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetTenantCount?";
        if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    moveTenantsToAnotherEdition(input: MoveTenantsToAnotherEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/MoveTenantsToAnotherEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveTenantsToAnotherEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveTenantsToAnotherEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMoveTenantsToAnotherEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class GateRecordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除GateRecord的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GateRecord/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改GateRecord的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateGateRecordInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GateRecord/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除GateRecord信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GateRecord/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取GateRecordListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<GateRecordListDto> {
        let url_ = this.baseUrl + "/api/services/app/GateRecord/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<GateRecordListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GateRecordListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<GateRecordListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GateRecordListDto.fromJS(resultData200) : new GateRecordListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GateRecordListDto>(<any>null);
    }

    /**
     * 获取编辑 GateRecord
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetGateRecordForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/GateRecord/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetGateRecordForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGateRecordForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetGateRecordForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetGateRecordForEditOutput.fromJS(resultData200) : new GetGateRecordForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGateRecordForEditOutput>(<any>null);
    }

    /**
     * 获取GateRecord的分页列表信息
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGateRecordListDto> {
        let url_ = this.baseUrl + "/api/services/app/GateRecord/GetPaged?";
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGateRecordListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGateRecordListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfGateRecordListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGateRecordListDto.fromJS(resultData200) : new PagedResultDtoOfGateRecordListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGateRecordListDto>(<any>null);
    }
}

@Injectable()
export class HangfireServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 加入队列
     * @param input (optional) 
     * @return Success
     */
    addEnqueueJob(input: RecurringJobInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/HangfireService/AddEnqueueJob";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddEnqueueJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddEnqueueJob(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAddEnqueueJob(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * 删除普通作业
     * @param jobId (optional) 
     * @return Success
     */
    deleteJob(jobId: string[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/HangfireService/DeleteJob?";
        if (jobId !== undefined)
            jobId && jobId.forEach(item => { url_ += "jobId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteJob(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteJob(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * 删除周期性作业
     * @param jobId (optional) 
     * @return Success
     */
    deleteRecurringJob(jobId: string[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/HangfireService/DeleteRecurringJob?";
        if (jobId !== undefined)
            jobId && jobId.forEach(item => { url_ += "jobId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRecurringJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRecurringJob(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRecurringJob(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * 获取所有作业
     * @param jobState (optional) 
     * @param queueName (optional) 
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllJobs(jobState: JobState | null | undefined, queueName: string | null | undefined, filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfHangFireStorageJob> {
        let url_ = this.baseUrl + "/api/services/app/HangfireService/GetAllJobs?";
        if (jobState !== undefined)
            url_ += "jobState=" + encodeURIComponent("" + jobState) + "&"; 
        if (queueName !== undefined)
            url_ += "queueName=" + encodeURIComponent("" + queueName) + "&"; 
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllJobs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllJobs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfHangFireStorageJob>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfHangFireStorageJob>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllJobs(response: HttpResponseBase): Observable<PagedResultDtoOfHangFireStorageJob> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfHangFireStorageJob.fromJS(resultData200) : new PagedResultDtoOfHangFireStorageJob();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfHangFireStorageJob>(<any>null);
    }

    /**
     * 获取所有周期性作业
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param filterText (optional) 
     * @return Success
     */
    getAllRecurringJob(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined, filterText: string | null | undefined): Observable<RecurringResultList> {
        let url_ = this.baseUrl + "/api/services/app/HangfireService/GetAllRecurringJob?";
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRecurringJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRecurringJob(<any>response_);
                } catch (e) {
                    return <Observable<RecurringResultList>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecurringResultList>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRecurringJob(response: HttpResponseBase): Observable<RecurringResultList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RecurringResultList.fromJS(resultData200) : new RecurringResultList();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecurringResultList>(<any>null);
    }

    /**
     * 获取Dashboard仪表盘-数据
     * @return Success
     */
    getDashboardData(searchTimeType: SearchTimeType): Observable<DashboardIndexDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/HangfireService/GetDashboardData?";
        if (searchTimeType === undefined || searchTimeType === null)
            throw new Error("The parameter 'searchTimeType' must be defined and cannot be null.");
        else
            url_ += "searchTimeType=" + encodeURIComponent("" + searchTimeType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(<any>response_);
                } catch (e) {
                    return <Observable<DashboardIndexDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DashboardIndexDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<DashboardIndexDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DashboardIndexDetailDto.fromJS(resultData200) : new DashboardIndexDetailDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashboardIndexDetailDto>(<any>null);
    }

    /**
     * 获取统计数据
     * @return Success
     */
    getDashboardStatistics(): Observable<StatisticsInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/HangfireService/GetDashboardStatistics";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardStatistics(<any>response_);
                } catch (e) {
                    return <Observable<StatisticsInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatisticsInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardStatistics(response: HttpResponseBase): Observable<StatisticsInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StatisticsInfoDto.fromJS(resultData200) : new StatisticsInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatisticsInfoDto>(<any>null);
    }

    /**
     * 查看作业详情信息
     * @param id (optional) 
     * @return Success
     */
    getJobDetail(id: string | null | undefined): Observable<HangfireJobDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/HangfireService/GetJobDetail?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobDetail(<any>response_);
                } catch (e) {
                    return <Observable<HangfireJobDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HangfireJobDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetJobDetail(response: HttpResponseBase): Observable<HangfireJobDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HangfireJobDetailDto.fromJS(resultData200) : new HangfireJobDetailDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HangfireJobDetailDto>(<any>null);
    }

    /**
     * 获取重试的作业数据
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param filterText (optional) 
     * @return Success
     */
    getRetriesJob(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined, filterText: string | null | undefined): Observable<RetriesResultList> {
        let url_ = this.baseUrl + "/api/services/app/HangfireService/GetRetriesJob?";
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetriesJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetriesJob(<any>response_);
                } catch (e) {
                    return <Observable<RetriesResultList>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetriesResultList>><any>_observableThrow(response_);
        }));
    }

    protected processGetRetriesJob(response: HttpResponseBase): Observable<RetriesResultList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RetriesResultList.fromJS(resultData200) : new RetriesResultList();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetriesResultList>(<any>null);
    }

    /**
     * 获取所有服务
     * @return Success
     */
    getServer(): Observable<ServerResultList> {
        let url_ = this.baseUrl + "/api/services/app/HangfireService/GetServer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServer(<any>response_);
                } catch (e) {
                    return <Observable<ServerResultList>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServerResultList>><any>_observableThrow(response_);
        }));
    }

    protected processGetServer(response: HttpResponseBase): Observable<ServerResultList> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServerResultList.fromJS(resultData200) : new ServerResultList();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServerResultList>(<any>null);
    }

    /**
     * 重新加入队列
     * @param input (optional) 
     * @return Success
     */
    requeue(input: RecurringJobInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/HangfireService/Requeue";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequeue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequeue(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processRequeue(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * 执行作业
     * @param input (optional) 
     * @return Success
     */
    runRecurringJob(input: RecurringJobInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/HangfireService/RunRecurringJob";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRunRecurringJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRunRecurringJob(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processRunRecurringJob(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class HostCachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostCaching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    clearCache(input: EntityDtoOfString | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostCaching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfHostCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/HostCaching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfHostCacheDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfHostCacheDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfHostCacheDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfHostCacheDto.fromJS(resultData200) : new ListResultDtoOfHostCacheDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfHostCacheDto>(<any>null);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<HostSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostSettingsEditDto.fromJS(resultData200) : new HostSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostSettingsEditDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateAllSettings(input: HostSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class InvalidUserExporterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param userListDtos (optional) 
     * @return Success
     */
    exportToFile(userListDtos: ImportUserDto[] | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/InvalidUserExporter/ExportToFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userListDtos);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToFile(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToFile(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class JsonWRServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 根据英文查询中文
     * @param path (optional) 英文
     * @return Success
     */
    getByPathGet(path: string | null | undefined): Observable<JsonCell> {
        let url_ = this.baseUrl + "/api/services/app/JsonWR/GetByPath?";
        if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByPathGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByPathGet(<any>response_);
                } catch (e) {
                    return <Observable<JsonCell>><any>_observableThrow(e);
                }
            } else
                return <Observable<JsonCell>><any>_observableThrow(response_);
        }));
    }

    protected processGetByPathGet(response: HttpResponseBase): Observable<JsonCell> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? JsonCell.fromJS(resultData200) : new JsonCell();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JsonCell>(<any>null);
    }

    /**
     * 根据英文查询中文
     * @param path (optional) 英文
     * @return Success
     */
    getByPathPost(path: string | null | undefined): Observable<JsonCell> {
        let url_ = this.baseUrl + "/api/services/app/JsonWR/GetByPath?";
        if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByPathPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByPathPost(<any>response_);
                } catch (e) {
                    return <Observable<JsonCell>><any>_observableThrow(e);
                }
            } else
                return <Observable<JsonCell>><any>_observableThrow(response_);
        }));
    }

    protected processGetByPathPost(response: HttpResponseBase): Observable<JsonCell> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? JsonCell.fromJS(resultData200) : new JsonCell();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JsonCell>(<any>null);
    }

    /**
     * 根据枚举类型名称查询其属性名称和中文描述
     * @param enumClassName (optional) 枚举名称
     * @return Success
     */
    getEnumCells(enumClassName: string | null | undefined): Observable<EnumCell[]> {
        let url_ = this.baseUrl + "/api/services/app/JsonWR/GetEnumCells?";
        if (enumClassName !== undefined)
            url_ += "enumClassName=" + encodeURIComponent("" + enumClassName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnumCells(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnumCells(<any>response_);
                } catch (e) {
                    return <Observable<EnumCell[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumCell[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEnumCells(response: HttpResponseBase): Observable<EnumCell[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EnumCell.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumCell[]>(<any>null);
    }

    /**
     * 查询中英文对照列表
     * @param input (optional) 
     * @return Success
     */
    getPagedGet(input: GetCommonInput | null | undefined): Observable<PagedResultDtoOfJsonCell> {
        let url_ = this.baseUrl + "/api/services/app/JsonWR/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedGet(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfJsonCell>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfJsonCell>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedGet(response: HttpResponseBase): Observable<PagedResultDtoOfJsonCell> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfJsonCell.fromJS(resultData200) : new PagedResultDtoOfJsonCell();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfJsonCell>(<any>null);
    }

    /**
     * 查询中英文对照列表
     * @param input (optional) 
     * @return Success
     */
    getPagedPost(input: GetCommonInput | null | undefined): Observable<PagedResultDtoOfJsonCell> {
        let url_ = this.baseUrl + "/api/services/app/JsonWR/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedPost(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfJsonCell>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfJsonCell>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedPost(response: HttpResponseBase): Observable<PagedResultDtoOfJsonCell> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfJsonCell.fromJS(resultData200) : new PagedResultDtoOfJsonCell();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfJsonCell>(<any>null);
    }

    /**
     * 更新中文
     * @param cell (optional) 
     * @return Success
     */
    updateGet(cell: JsonCell | null | undefined): Observable<JsonCell> {
        let url_ = this.baseUrl + "/api/services/app/JsonWR/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(cell);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGet(<any>response_);
                } catch (e) {
                    return <Observable<JsonCell>><any>_observableThrow(e);
                }
            } else
                return <Observable<JsonCell>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGet(response: HttpResponseBase): Observable<JsonCell> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? JsonCell.fromJS(resultData200) : new JsonCell();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JsonCell>(<any>null);
    }

    /**
     * 更新中文
     * @param cell (optional) 
     * @return Success
     */
    updatePost(cell: JsonCell | null | undefined): Observable<JsonCell> {
        let url_ = this.baseUrl + "/api/services/app/JsonWR/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(cell);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePost(<any>response_);
                } catch (e) {
                    return <Observable<JsonCell>><any>_observableThrow(e);
                }
            } else
                return <Observable<JsonCell>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePost(response: HttpResponseBase): Observable<JsonCell> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? JsonCell.fromJS(resultData200) : new JsonCell();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JsonCell>(<any>null);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除
     * @param ids (optional) 
     * @return Success
     */
    batchDelete(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateLanguage(input: CreateOrUpdateLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguage?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | null | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguageForEditOutput.fromJS(resultData200) : new GetLanguageForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguageForEditOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguagesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguagesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguagesOutput.fromJS(resultData200) : new GetLanguagesOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguagesOutput>(<any>null);
    }

    /**
     * @param sourceName 语言名称
     * @param baseLanguageName (optional) 原语言名称
     * @param targetLanguageName 目标语言名称
     * @param targetValueFilter (optional) 目标值过滤
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getLanguageTexts(sourceName: string, baseLanguageName: string | null | undefined, targetLanguageName: string, targetValueFilter: string | null | undefined, filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageTexts?";
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "sourceName=" + encodeURIComponent("" + sourceName) + "&"; 
        if (baseLanguageName !== undefined)
            url_ += "baseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&"; 
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "targetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&"; 
        if (targetValueFilter !== undefined)
            url_ += "targetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&"; 
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLanguageTextListDto.fromJS(resultData200) : new PagedResultDtoOfLanguageTextListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLanguageTextListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setDefaultLanguage(input: SetDefaultLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 修改语言的文本内容
     * @param input (optional) 
     * @return Success
     */
    updateLanguageText(input: UpdateLanguageTextInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MenuServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Menu的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Menu/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改Menu的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateMenuInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Menu/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除Menu信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Menu/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取MenuListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<MenuListDto> {
        let url_ = this.baseUrl + "/api/services/app/Menu/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<MenuListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MenuListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<MenuListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MenuListDto.fromJS(resultData200) : new MenuListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuListDto>(<any>null);
    }

    /**
     * 获取编辑 Menu
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetMenuForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Menu/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMenuForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMenuForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetMenuForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMenuForEditOutput.fromJS(resultData200) : new GetMenuForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMenuForEditOutput>(<any>null);
    }

    /**
     * 查询菜单下拉树
     * @return Success
     */
    getMenuDropDown(): Observable<MenuDropDownDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Menu/GetMenuDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMenuDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMenuDropDown(<any>response_);
                } catch (e) {
                    return <Observable<MenuDropDownDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MenuDropDownDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMenuDropDown(response: HttpResponseBase): Observable<MenuDropDownDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MenuDropDownDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuDropDownDto[]>(<any>null);
    }

    /**
     * 查询菜单树
     * @return Success
     */
    getMenuTree(): Observable<MenuTreeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Menu/GetMenuTree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMenuTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMenuTree(<any>response_);
                } catch (e) {
                    return <Observable<MenuTreeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MenuTreeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMenuTree(response: HttpResponseBase): Observable<MenuTreeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MenuTreeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuTreeDto[]>(<any>null);
    }

    /**
     * 获取Menu的分页列表信息
     * @param input (optional) 
     * @return Success
     */
    getPaged(input: GetMenusInput | null | undefined): Observable<PagedResultDtoOfMenuListDto> {
        let url_ = this.baseUrl + "/api/services/app/Menu/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMenuListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMenuListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfMenuListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfMenuListDto.fromJS(resultData200) : new PagedResultDtoOfMenuListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMenuListDto>(<any>null);
    }

    /**
     * 获取Menu的分页列表信息--Get方法
     * @param queryData (optional) MenuName,MenuCode,NavigateUrl,ParentId,IsEnabled
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPagedForGet(queryData: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfMenuListDto> {
        let url_ = this.baseUrl + "/api/services/app/Menu/GetPagedForGet?";
        if (queryData !== undefined)
            url_ += "queryData=" + encodeURIComponent("" + queryData) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedForGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedForGet(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMenuListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMenuListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedForGet(response: HttpResponseBase): Observable<PagedResultDtoOfMenuListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfMenuListDto.fromJS(resultData200) : new PagedResultDtoOfMenuListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMenuListDto>(<any>null);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 删除通知
     * @param id (optional) 
     * @return Success
     */
    deleteNotification(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteNotification?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationSettingsOutput.fromJS(resultData200) : new GetNotificationSettingsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationSettingsOutput>(<any>null);
    }

    /**
     * @param state (optional) 是否阅读枚举 0是未读 1是已经阅读
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPagedUserNotifications(state: UserNotificationState | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetPagedUserNotificationsAsync?";
        if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationsOutput.fromJS(resultData200) : new GetNotificationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    makeAllUserNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/MakeAllUserNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMakeAllUserNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMakeAllUserNotificationsAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMakeAllUserNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    makeNotificationAsRead(input: EntityDtoOfGuid | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/MakeNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMakeNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMakeNotificationAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMakeNotificationAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新消息设置
     * @param input (optional) 
     * @return Success
     */
    updateNotificationSettings(input: UpdateNotificationSettingsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 添加角色 组织关联
     * @param input (optional) 
     * @return Success
     */
    addRoles(input: RolesToOrganizationUnitInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRoles(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddRoles(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addUsers(input: UsersToOrganizationUnitInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUsers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 批量从组织中移除角色
     * @param roleIds (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    batchRemoveRoleFromOrganizationUnit(roleIds: number[] | null | undefined, organizationUnitId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/BatchRemoveRoleFromOrganizationUnit?";
        if (organizationUnitId !== undefined)
            url_ += "organizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(roleIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchRemoveRoleFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchRemoveRoleFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchRemoveRoleFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 批量从组织中移除用户
     * @param userIds (optional) 用户Id列表
     * @param organizationUnitId (optional) 组织机构Id
     * @return Success
     */
    batchRemoveUserFromOrganizationUnit(userIds: number[] | null | undefined, organizationUnitId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/BatchRemoveUserFromOrganizationUnit?";
        if (organizationUnitId !== undefined)
            url_ += "organizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchRemoveUserFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<OrganizationUnitListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitListDto.fromJS(resultData200) : new OrganizationUnitListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    findRoles(input: FindUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindRoles(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    findUsers(input: FindUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllOrganizationUnitList(): Observable<ListResultDtoOfOrganizationUnitListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetAllOrganizationUnitList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrganizationUnitList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrganizationUnitList(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfOrganizationUnitListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfOrganizationUnitListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllOrganizationUnitList(response: HttpResponseBase): Observable<ListResultDtoOfOrganizationUnitListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfOrganizationUnitListDto.fromJS(resultData200) : new ListResultDtoOfOrganizationUnitListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfOrganizationUnitListDto>(<any>null);
    }

    /**
     * 获取角色列表
     * @param id (optional) 
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPagedOrganizationUnitRoles(id: number | null | undefined, filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetPagedOrganizationUnitRolesAsync?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedOrganizationUnitRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedOrganizationUnitRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedOrganizationUnitRoles(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOrganizationUnitRoleListDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationUnitRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitRoleListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPagedOrganizationUnitUsers(id: number | null | undefined, filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetPagedOrganizationUnitUsers?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedOrganizationUnitUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedOrganizationUnitUsers(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationUnitUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitUserListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    isInOrganizationUnit(input: UserToOrganizationUnitInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/IsInOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsInOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsInOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsInOrganizationUnit(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    move(input: MoveOrganizationUnitInput | null | undefined): Observable<OrganizationUnitListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/Move";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMove(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitListDto>><any>_observableThrow(response_);
        }));
    }

    protected processMove(response: HttpResponseBase): Observable<OrganizationUnitListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitListDto.fromJS(resultData200) : new OrganizationUnitListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitListDto>(<any>null);
    }

    /**
     * 删除 角色 组织关联
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeRole(roleId: number | null | undefined, organizationUnitId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveRole?";
        if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "organizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeUser(userId: number | null | undefined, organizationUnitId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUser?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "organizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 判断角色是否在当前组织
     * @param input (optional) 
     * @return Success
     */
    rolesIsInOrganizationUnit(input: RoleToOrganizationUnitInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RolesIsInOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolesIsInOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolesIsInOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processRolesIsInOrganizationUnit(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: UpdateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitListDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<OrganizationUnitListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitListDto.fromJS(resultData200) : new OrganizationUnitListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitListDto>(<any>null);
    }
}

@Injectable()
export class PayMethodServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除PayMethod的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayMethod/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改PayMethod的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdatePayMethodInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayMethod/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除PayMethod信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayMethod/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取PayMethodListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<PayMethodListDto> {
        let url_ = this.baseUrl + "/api/services/app/PayMethod/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<PayMethodListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayMethodListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<PayMethodListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PayMethodListDto.fromJS(resultData200) : new PayMethodListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayMethodListDto>(<any>null);
    }

    /**
     * 获取编辑 PayMethod
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetPayMethodForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/PayMethod/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetPayMethodForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPayMethodForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetPayMethodForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPayMethodForEditOutput.fromJS(resultData200) : new GetPayMethodForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPayMethodForEditOutput>(<any>null);
    }

    /**
     * 获取PayMethod的分页列表信息
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfPayMethodListDto> {
        let url_ = this.baseUrl + "/api/services/app/PayMethod/GetPaged?";
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPayMethodListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPayMethodListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfPayMethodListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfPayMethodListDto.fromJS(resultData200) : new PagedResultDtoOfPayMethodListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPayMethodListDto>(<any>null);
    }

    /**
     * 支付方式统计接口
     * @param queryData (optional) PayMethodId, CreationTime
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param routeId (optional) 
     * @param boatId (optional) 
     * @param ticketId (optional) 
     * @return Success
     */
    getPagedStat(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined, routeId: string | null | undefined, boatId: string | null | undefined, ticketId: string | null | undefined): Observable<StatsPagedResultDtoOfGetPayMethodResultDto> {
        let url_ = this.baseUrl + "/api/Stats/PayMethod/GetPagedStat?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (routeId !== undefined)
            url_ += "routeId=" + encodeURIComponent("" + routeId) + "&"; 
        if (boatId !== undefined)
            url_ += "boatId=" + encodeURIComponent("" + boatId) + "&"; 
        if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedStat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedStat(<any>response_);
                } catch (e) {
                    return <Observable<StatsPagedResultDtoOfGetPayMethodResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatsPagedResultDtoOfGetPayMethodResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedStat(response: HttpResponseBase): Observable<StatsPagedResultDtoOfGetPayMethodResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StatsPagedResultDtoOfGetPayMethodResultDto.fromJS(resultData200) : new StatsPagedResultDtoOfGetPayMethodResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatsPagedResultDtoOfGetPayMethodResultDto>(<any>null);
    }

    /**
     * 支付方式统计接口——详细
     * @param paymethodId (optional) 
     * @return Success
     */
    payMethodStatDetail(paymethodId: string | null | undefined): Observable<AccountDetailDto[]> {
        let url_ = this.baseUrl + "/api/Stats/PayMethod/PayMethodStatDetail?";
        if (paymethodId !== undefined)
            url_ += "paymethodId=" + encodeURIComponent("" + paymethodId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayMethodStatDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayMethodStatDetail(<any>response_);
                } catch (e) {
                    return <Observable<AccountDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processPayMethodStatDetail(response: HttpResponseBase): Observable<AccountDetailDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDetailDto[]>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfFlatPermissionWithLevelDto.fromJS(resultData200) : new ListResultDtoOfFlatPermissionWithLevelDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfFlatPermissionWithLevelDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPermissionsTree(): Observable<ListResultDtoOfTreePermissionDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetAllPermissionsTree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissionsTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissionsTree(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfTreePermissionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfTreePermissionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissionsTree(response: HttpResponseBase): Observable<ListResultDtoOfTreePermissionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfTreePermissionDto.fromJS(resultData200) : new ListResultDtoOfTreePermissionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfTreePermissionDto>(<any>null);
    }
}

@Injectable()
export class PowerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量增加权限
     * @param menuId (optional) 菜单Id
     * @param powerCodeList (optional) 
     * @return Success
     */
    batchCreate(menuId: string | null | undefined, powerCodeList: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Power/BatchCreate?";
        if (menuId !== undefined)
            url_ += "menuId=" + encodeURIComponent("" + menuId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(powerCodeList);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 批量删除Power的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Power/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改Power的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdatePowerInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Power/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除Power信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Power/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取PowerListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<PowerListDto> {
        let url_ = this.baseUrl + "/api/services/app/Power/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<PowerListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PowerListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<PowerListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PowerListDto.fromJS(resultData200) : new PowerListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PowerListDto>(<any>null);
    }

    /**
     * 获取编辑 Power
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetPowerForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Power/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetPowerForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPowerForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetPowerForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPowerForEditOutput.fromJS(resultData200) : new GetPowerForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPowerForEditOutput>(<any>null);
    }

    /**
     * 获取Power的分页列表信息
     * @param queryData (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfPowerListDto> {
        let url_ = this.baseUrl + "/api/services/app/Power/GetPaged?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPowerListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPowerListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfPowerListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfPowerListDto.fromJS(resultData200) : new PagedResultDtoOfPowerListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPowerListDto>(<any>null);
    }

    /**
     * 取票支持类型接口
     * @param userId (optional) 自助机用户ID
     * @return Success
     */
    machineGetTicketType(userId: number | null | undefined): Observable<GetTicketPower[]> {
        let url_ = this.baseUrl + "/api/services/app/Power/MachineGetTicketType?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMachineGetTicketType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMachineGetTicketType(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketPower[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketPower[]>><any>_observableThrow(response_);
        }));
    }

    protected processMachineGetTicketType(response: HttpResponseBase): Observable<GetTicketPower[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(GetTicketPower.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketPower[]>(<any>null);
    }
}

@Injectable()
export class PowerRoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 根据角色ID修改权限
     * @param roleId (optional) 角色ID
     * @param powerIdList (optional) 权限ID列表
     * @return Success
     */
    batchAddOrUpdate(roleId: number | null | undefined, powerIdList: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PowerRole/BatchAddOrUpdate?";
        if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(powerIdList);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchAddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchAddOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchAddOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 批量删除PowerRole的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PowerRole/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改PowerRole的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdatePowerRoleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PowerRole/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除PowerRole信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PowerRole/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取PowerRoleListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<PowerRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/PowerRole/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<PowerRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PowerRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<PowerRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PowerRoleListDto.fromJS(resultData200) : new PowerRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PowerRoleListDto>(<any>null);
    }

    /**
     * 获取编辑 PowerRole
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetPowerRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/PowerRole/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetPowerRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPowerRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetPowerRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPowerRoleForEditOutput.fromJS(resultData200) : new GetPowerRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPowerRoleForEditOutput>(<any>null);
    }

    /**
     * 获取PowerRole的分页列表信息
     * @param queryData (optional) User.XX,Branch.XX
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfPowerRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/PowerRole/GetPaged?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPowerRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPowerRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfPowerRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfPowerRoleListDto.fromJS(resultData200) : new PagedResultDtoOfPowerRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPowerRoleListDto>(<any>null);
    }

    /**
     * 根据角色ID查询权限信息
    IsCheck表示是否勾选
     * @param roleId (optional) 角色ID
     * @return Success
     */
    getPowerRoleListById(roleId: number | null | undefined): Observable<PagedResultDtoOfPowerListDto> {
        let url_ = this.baseUrl + "/api/services/app/PowerRole/GetPowerRoleListById?";
        if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPowerRoleListById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPowerRoleListById(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPowerListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPowerListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPowerRoleListById(response: HttpResponseBase): Observable<PagedResultDtoOfPowerListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfPowerListDto.fromJS(resultData200) : new PagedResultDtoOfPowerListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPowerListDto>(<any>null);
    }
}

@Injectable()
export class PriceAuditServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除PriceAudit的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PriceAudit/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改PriceAudit的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdatePriceAuditInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PriceAudit/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除PriceAudit信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PriceAudit/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取PriceAuditListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<PriceAuditListDto> {
        let url_ = this.baseUrl + "/api/services/app/PriceAudit/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<PriceAuditListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PriceAuditListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<PriceAuditListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PriceAuditListDto.fromJS(resultData200) : new PriceAuditListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PriceAuditListDto>(<any>null);
    }

    /**
     * 获取编辑 PriceAudit
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetPriceAuditForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/PriceAudit/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetPriceAuditForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPriceAuditForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetPriceAuditForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPriceAuditForEditOutput.fromJS(resultData200) : new GetPriceAuditForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPriceAuditForEditOutput>(<any>null);
    }

    /**
     * 获取PriceAudit的分页列表信息——票总票价审核
     * @param input (optional) 
     * @return Success
     */
    getPaged(input: GetPriceAuditsInput | null | undefined): Observable<PagedResultDtoOfPriceAuditListDto> {
        let url_ = this.baseUrl + "/api/services/app/PriceAudit/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPriceAuditListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPriceAuditListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfPriceAuditListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfPriceAuditListDto.fromJS(resultData200) : new PagedResultDtoOfPriceAuditListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPriceAuditListDto>(<any>null);
    }

    /**
     * 驳回重改
     * @param input (optional) 
     * @return Success
     */
    updateRejecteAudit(input: PriceAuditEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PriceAudit/UpdateRejecteAudit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRejecteAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRejecteAudit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRejecteAudit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 审核成功
     * @param input (optional) 
     * @return Success
     */
    updateThroughAudit(input: PriceAuditEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PriceAudit/UpdateThroughAudit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateThroughAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateThroughAudit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateThroughAudit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changePassword(input: ChangePasswordInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除用户头像
     * @param profilePictureId (optional) 头像ID
     * @return Success
     */
    deleteProfilePictureById(profilePictureId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/DeleteProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "profilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProfilePictureById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取当前的个人信息
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CurrentUserProfileEditDto.fromJS(resultData200) : new CurrentUserProfileEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrentUserProfileEditDto>(<any>null);
    }

    /**
     * @param profilePictureId (optional) 
     * @return Success
     */
    getProfilePictureById(profilePictureId: string | null | undefined): Observable<GetProfilePictureOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureByIdAsync?";
        if (profilePictureId !== undefined)
            url_ += "profilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutputDto.fromJS(resultData200) : new GetProfilePictureOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutputDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateCurrentUserProfile(input: CurrentUserProfileEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateProfilePicture(input: UpdateProfilePictureInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateProfilePictureAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RechargeRecordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除RechargeRecord的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RechargeRecord/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改RechargeRecord的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateRechargeRecordInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RechargeRecord/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除RechargeRecord信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RechargeRecord/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取RechargeRecordListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<RechargeRecordListDto> {
        let url_ = this.baseUrl + "/api/services/app/RechargeRecord/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<RechargeRecordListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RechargeRecordListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<RechargeRecordListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RechargeRecordListDto.fromJS(resultData200) : new RechargeRecordListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RechargeRecordListDto>(<any>null);
    }

    /**
     * 获取编辑 RechargeRecord
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetRechargeRecordForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RechargeRecord/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRechargeRecordForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRechargeRecordForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetRechargeRecordForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRechargeRecordForEditOutput.fromJS(resultData200) : new GetRechargeRecordForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRechargeRecordForEditOutput>(<any>null);
    }

    /**
     * 获取RechargeRecord的分页列表信息
     * @param queryData (optional) DeviceCode,DeviceName,Port
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfRechargeRecordListDto> {
        let url_ = this.baseUrl + "/api/services/app/RechargeRecord/GetPaged?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRechargeRecordListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRechargeRecordListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfRechargeRecordListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRechargeRecordListDto.fromJS(resultData200) : new PagedResultDtoOfRechargeRecordListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRechargeRecordListDto>(<any>null);
    }

    /**
     * 获取RechargeRecord的分页列表信息--Post方法
     * @param input (optional) 
     * @return Success
     */
    getPagedForPost(input: GetRechargeRecordsInput | null | undefined): Observable<PagedResultDtoOfRechargeRecordListDto> {
        let url_ = this.baseUrl + "/api/services/app/RechargeRecord/GetPagedForPost";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedForPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedForPost(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRechargeRecordListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRechargeRecordListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedForPost(response: HttpResponseBase): Observable<PagedResultDtoOfRechargeRecordListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRechargeRecordListDto.fromJS(resultData200) : new PagedResultDtoOfRechargeRecordListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRechargeRecordListDto>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除角色
     * @param ids (optional) 
     * @return Success
     */
    batchDelete(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/BatchDeleteAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateRoleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 服务于前端RoleComboxComponent 组件信息，
     * @param permission (optional) 权限名称
     * @return Success
     */
    getAll(permission: string | null | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (permission !== undefined)
            url_ += "permission=" + encodeURIComponent("" + permission) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleListDto.fromJS(resultData200) : new ListResultDtoOfRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param permissionNames (optional) 权限名称
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(permissionNames: string[] | null | undefined, filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetPaged?";
        if (permissionNames !== undefined)
            permissionNames && permissionNames.forEach(item => { url_ += "permissionNames=" + encodeURIComponent("" + item) + "&"; });
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRoleListDto.fromJS(resultData200) : new PagedResultDtoOfRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updatePermissions(input: UpdateRolePermissionsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/UpdatePermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RouteServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Route的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Route/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改Route的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateRouteInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Route/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除Route信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Route/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取RouteListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<RouteListDto> {
        let url_ = this.baseUrl + "/api/services/app/Route/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<RouteListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RouteListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<RouteListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RouteListDto.fromJS(resultData200) : new RouteListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RouteListDto>(<any>null);
    }

    /**
     * 获取编辑 Route
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetRouteForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Route/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRouteForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRouteForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetRouteForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRouteForEditOutput.fromJS(resultData200) : new GetRouteForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRouteForEditOutput>(<any>null);
    }

    /**
     * 获取Route的分页列表信息
     * @param input (optional) 
     * @return Success
     */
    getPaged(input: GetRoutesInput | null | undefined): Observable<PagedResultDtoOfRouteListDto> {
        let url_ = this.baseUrl + "/api/services/app/Route/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRouteListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRouteListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfRouteListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRouteListDto.fromJS(resultData200) : new PagedResultDtoOfRouteListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRouteListDto>(<any>null);
    }

    /**
     * 导出Route为excel表,等待开发。
     * @param file (optional) 
     * @return Success
     */
    importRoute(file: FileParameter | null | undefined): Observable<ExcelResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Route/ImportRoute";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportRoute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportRoute(<any>response_);
                } catch (e) {
                    return <Observable<ExcelResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExcelResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportRoute(response: HttpResponseBase): Observable<ExcelResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExcelResultDto.fromJS(resultData200) : new ExcelResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExcelResultDto>(<any>null);
    }
}

@Injectable()
export class ScenicSpotServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除ScenicSpot的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ScenicSpot/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改ScenicSpot的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateScenicSpotInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ScenicSpot/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除ScenicSpot信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ScenicSpot/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取ScenicSpotListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<ScenicSpotListDto> {
        let url_ = this.baseUrl + "/api/services/app/ScenicSpot/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ScenicSpotListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScenicSpotListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ScenicSpotListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScenicSpotListDto.fromJS(resultData200) : new ScenicSpotListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScenicSpotListDto>(<any>null);
    }

    /**
     * 获取编辑 ScenicSpot
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetScenicSpotForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ScenicSpot/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetScenicSpotForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetScenicSpotForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetScenicSpotForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetScenicSpotForEditOutput.fromJS(resultData200) : new GetScenicSpotForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetScenicSpotForEditOutput>(<any>null);
    }

    /**
     * 获取ScenicSpot的分页列表信息
     * @param queryData (optional) DeviceCode,DeviceName,Port
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfScenicSpotListDto> {
        let url_ = this.baseUrl + "/api/services/app/ScenicSpot/GetPaged?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfScenicSpotListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfScenicSpotListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfScenicSpotListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfScenicSpotListDto.fromJS(resultData200) : new PagedResultDtoOfScenicSpotListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfScenicSpotListDto>(<any>null);
    }
}

@Injectable()
export class ScheduleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Schedule的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Schedule/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改Schedule的公共方法,可以批量新增（根据开始日期和结束日期）
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateScheduleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Schedule/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除Schedule信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Schedule/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取ScheduleListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<ScheduleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Schedule/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ScheduleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScheduleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ScheduleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduleListDto.fromJS(resultData200) : new ScheduleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleListDto>(<any>null);
    }

    /**
     * 获取编辑 Schedule
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetScheduleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Schedule/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetScheduleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetScheduleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetScheduleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetScheduleForEditOutput.fromJS(resultData200) : new GetScheduleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetScheduleForEditOutput>(<any>null);
    }

    /**
     * 获取Schedule的分页列表信息
     * @param input (optional) 
     * @return Success
     */
    getPaged(input: GetSchedulesInput | null | undefined): Observable<PagedResultDtoOfScheduleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Schedule/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfScheduleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfScheduleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfScheduleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfScheduleListDto.fromJS(resultData200) : new PagedResultDtoOfScheduleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfScheduleListDto>(<any>null);
    }

    /**
     * 获取Schedule的分页列表信息--Post方法
     * @param input (optional) 
     * @return Success
     */
    getPagedForPost(input: GetSchedulesInput | null | undefined): Observable<PagedResultDtoOfScheduleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Schedule/GetPagedForPost";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedForPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedForPost(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfScheduleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfScheduleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedForPost(response: HttpResponseBase): Observable<PagedResultDtoOfScheduleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfScheduleListDto.fromJS(resultData200) : new PagedResultDtoOfScheduleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfScheduleListDto>(<any>null);
    }

    /**
     * 即将发船提示语信息
     * @param scheduleId (optional) 航班Id
     * @return Success
     */
    getTips(scheduleId: string | null | undefined): Observable<ScheduleTipDto> {
        let url_ = this.baseUrl + "/api/services/app/Schedule/GetTips?";
        if (scheduleId !== undefined)
            url_ += "scheduleId=" + encodeURIComponent("" + scheduleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTips(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTips(<any>response_);
                } catch (e) {
                    return <Observable<ScheduleTipDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScheduleTipDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTips(response: HttpResponseBase): Observable<ScheduleTipDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduleTipDto.fromJS(resultData200) : new ScheduleTipDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleTipDto>(<any>null);
    }

    /**
     * 从Excel表导入数据
     * @param file (optional) 
     * @return Success
     */
    importSchedule(file: FileParameter | null | undefined): Observable<ExcelResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Schedule/ImportSchedule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportSchedule(<any>response_);
                } catch (e) {
                    return <Observable<ExcelResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExcelResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportSchedule(response: HttpResponseBase): Observable<ExcelResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExcelResultDto.fromJS(resultData200) : new ExcelResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExcelResultDto>(<any>null);
    }

    /**
     * 驳回重改
     * @param input (optional) 
     * @return Success
     */
    updateRejecteAudit(input: ScheduleEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Schedule/UpdateRejecteAudit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRejecteAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRejecteAudit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRejecteAudit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 审核成功
     * @param input (optional) 
     * @return Success
     */
    updateThroughAudit(input: ScheduleEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Schedule/UpdateThroughAudit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateThroughAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateThroughAudit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateThroughAudit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 航线统计
     * @param queryData (optional) CreationTime
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param routeId (optional) 
     * @param boatId (optional) 
     * @param ticketId (optional) 
     * @return Success
     */
    getPagedStat(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined, routeId: string | null | undefined, boatId: string | null | undefined, ticketId: string | null | undefined): Observable<StatsPagedResultDtoOfScheduleResultDto> {
        let url_ = this.baseUrl + "/api/Stats/Schedule/GetPagedStat?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (routeId !== undefined)
            url_ += "routeId=" + encodeURIComponent("" + routeId) + "&"; 
        if (boatId !== undefined)
            url_ += "boatId=" + encodeURIComponent("" + boatId) + "&"; 
        if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedStat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedStat(<any>response_);
                } catch (e) {
                    return <Observable<StatsPagedResultDtoOfScheduleResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatsPagedResultDtoOfScheduleResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedStat(response: HttpResponseBase): Observable<StatsPagedResultDtoOfScheduleResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StatsPagedResultDtoOfScheduleResultDto.fromJS(resultData200) : new StatsPagedResultDtoOfScheduleResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatsPagedResultDtoOfScheduleResultDto>(<any>null);
    }

    /**
     * 航线统计——详情
     * @param routeId (optional) 
     * @return Success
     */
    scheduleDetailStat(routeId: string | null | undefined): Observable<StatsPagedResultDtoOfScheduleDetailResultDto> {
        let url_ = this.baseUrl + "/api/Stats/Schedule/ScheduleDetailStat?";
        if (routeId !== undefined)
            url_ += "routeId=" + encodeURIComponent("" + routeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScheduleDetailStat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScheduleDetailStat(<any>response_);
                } catch (e) {
                    return <Observable<StatsPagedResultDtoOfScheduleDetailResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatsPagedResultDtoOfScheduleDetailResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processScheduleDetailStat(response: HttpResponseBase): Observable<StatsPagedResultDtoOfScheduleDetailResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StatsPagedResultDtoOfScheduleDetailResultDto.fromJS(resultData200) : new StatsPagedResultDtoOfScheduleDetailResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatsPagedResultDtoOfScheduleDetailResultDto>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getUserConfigurations(): Observable<AbpUserConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetUserConfigurations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserConfigurations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserConfigurations(<any>response_);
                } catch (e) {
                    return <Observable<AbpUserConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AbpUserConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserConfigurations(response: HttpResponseBase): Observable<AbpUserConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AbpUserConfigurationDto.fromJS(resultData200) : new AbpUserConfigurationDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AbpUserConfigurationDto>(<any>null);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(<any>response_);
                } catch (e) {
                    return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateUserSignInTokenOutput.fromJS(resultData200) : new UpdateUserSignInTokenOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateUserSignInTokenOutput>(<any>null);
    }
}

@Injectable()
export class SettingsAppServiceBaseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SettingsAppServiceBase/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SourceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Source的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Source/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改Source的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateSourceInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Source/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除Source信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Source/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取SourceListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<SourceListDto> {
        let url_ = this.baseUrl + "/api/services/app/Source/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<SourceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SourceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<SourceListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SourceListDto.fromJS(resultData200) : new SourceListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SourceListDto>(<any>null);
    }

    /**
     * 获取编辑 Source
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetSourceForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Source/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetSourceForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSourceForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetSourceForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSourceForEditOutput.fromJS(resultData200) : new GetSourceForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSourceForEditOutput>(<any>null);
    }

    /**
     * 获取Source的分页列表信息
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfSourceListDto> {
        let url_ = this.baseUrl + "/api/services/app/Source/GetPaged?";
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSourceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSourceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfSourceListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSourceListDto.fromJS(resultData200) : new PagedResultDtoOfSourceListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSourceListDto>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: EntityDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateTenantInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | null | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<TenantEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantEditDto.fromJS(resultData200) : new TenantEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantEditDto>(<any>null);
    }

    /**
     * @param subscriptionStart (optional) 
     * @param subscriptionEnd (optional) 
     * @param creationDateStart (optional) 
     * @param creationDateEnd (optional) 
     * @param editionId (optional) 
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(subscriptionStart: moment.Moment | null | undefined, subscriptionEnd: moment.Moment | null | undefined, creationDateStart: moment.Moment | null | undefined, creationDateEnd: moment.Moment | null | undefined, editionId: number | null | undefined, filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetPaged?";
        if (subscriptionStart !== undefined)
            url_ += "subscriptionStart=" + encodeURIComponent(subscriptionStart ? "" + subscriptionStart.toJSON() : "") + "&"; 
        if (subscriptionEnd !== undefined)
            url_ += "subscriptionEnd=" + encodeURIComponent(subscriptionEnd ? "" + subscriptionEnd.toJSON() : "") + "&"; 
        if (creationDateStart !== undefined)
            url_ += "creationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toJSON() : "") + "&"; 
        if (creationDateEnd !== undefined)
            url_ += "creationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toJSON() : "") + "&"; 
        if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenantListDto.fromJS(resultData200) : new PagedResultDtoOfTenantListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | null | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantFeaturesForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTenantFeaturesEditOutput.fromJS(resultData200) : new GetTenantFeaturesEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTenantFeaturesEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(input: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unlockTenantAdmin(input: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: TenantEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateTenantFeatures(input: UpdateTenantFeaturesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 注册租户信息
     * @param input (optional) 
     * @return Success
     */
    registerTenant(input: CreateTenantDto | null | undefined): Observable<RegisterTenantResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/RegisterTenantAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(<any>response_);
                } catch (e) {
                    return <Observable<RegisterTenantResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterTenantResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterTenantResultDto.fromJS(resultData200) : new RegisterTenantResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterTenantResultDto>(<any>null);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLogo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取所有设置
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<TenantSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSettingsEditDto.fromJS(resultData200) : new TenantSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSettingsEditDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新所有设置
     * @param input (optional) 
     * @return Success
     */
    updateAllSettings(input: TenantSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TicketServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Ticket的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改Ticket的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateTicketInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除Ticket信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TicketListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<TicketListDto> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TicketListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TicketListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TicketListDto.fromJS(resultData200) : new TicketListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketListDto>(<any>null);
    }

    /**
     * 获取编辑 Ticket
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetTicketForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTicketForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketForEditOutput.fromJS(resultData200) : new GetTicketForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketForEditOutput>(<any>null);
    }

    /**
     * 获取Ticket的分页列表信息
     * @param input (optional) 
     * @return Success
     */
    getPaged(input: GetTicketsInput | null | undefined): Observable<PagedResultDtoOfTicketListDto> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTicketListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketListDto.fromJS(resultData200) : new PagedResultDtoOfTicketListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketListDto>(<any>null);
    }

    /**
     * @param queryData (optional) DeviceCode,DeviceName,Port
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPagedForSchedule(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTicketListDto> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/GetPagedForSchedule?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedForSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedForSchedule(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedForSchedule(response: HttpResponseBase): Observable<PagedResultDtoOfTicketListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketListDto.fromJS(resultData200) : new PagedResultDtoOfTicketListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketListDto>(<any>null);
    }

    /**
     * 音频上传
     * @param file (optional) 
     * @return Success
     */
    uploadAudio(file: FileParameter | null | undefined): Observable<UploadAudioDto> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/UploadAudioAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadAudio(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadAudio(<any>response_);
                } catch (e) {
                    return <Observable<UploadAudioDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UploadAudioDto>><any>_observableThrow(response_);
        }));
    }

    protected processUploadAudio(response: HttpResponseBase): Observable<UploadAudioDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UploadAudioDto.fromJS(resultData200) : new UploadAudioDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UploadAudioDto>(<any>null);
    }
}

@Injectable()
export class TicketAccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Account的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketAccount/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改Account的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateAccountInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketAccount/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除Account信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketAccount/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取AccountListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<AccountListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketAccount/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<AccountListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<AccountListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccountListDto.fromJS(resultData200) : new AccountListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountListDto>(<any>null);
    }

    /**
     * 根据Account ID 获取账单明细
     * @param accountId (optional) 
     * @return Success
     */
    getDetail(accountId: string | null | undefined): Observable<AccountDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/TicketAccount/GetDetail?";
        if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<AccountDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<AccountDetailDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDetailDto[]>(<any>null);
    }

    /**
     * 获取编辑 Account
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetAccountForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketAccount/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAccountForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAccountForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetAccountForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetAccountForEditOutput.fromJS(resultData200) : new GetAccountForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAccountForEditOutput>(<any>null);
    }

    /**
     * 获取TicketAccount的分页列表信息
     * @param input (optional) 
     * @return Success
     */
    getPaged(input: GetAccountsInput | null | undefined): Observable<PagedResultDtoOfAccountListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketAccount/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAccountListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAccountListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfAccountListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAccountListDto.fromJS(resultData200) : new PagedResultDtoOfAccountListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAccountListDto>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @return Success
     */
    ticketDetail(activityId: string | null | undefined): Observable<TicketDetailListDto[]> {
        let url_ = this.baseUrl + "/api/TicketAccount/TicketAccount/TicketDetail?";
        if (activityId !== undefined)
            url_ += "activityId=" + encodeURIComponent("" + activityId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTicketDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTicketDetail(<any>response_);
                } catch (e) {
                    return <Observable<TicketDetailListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketDetailListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processTicketDetail(response: HttpResponseBase): Observable<TicketDetailListDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TicketDetailListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketDetailListDto[]>(<any>null);
    }
}

@Injectable()
export class TicketDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TicketDetail的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetail/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改TicketDetail的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateTicketDetailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetail/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除TicketDetail信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetail/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TicketDetailListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<TicketDetailListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetail/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TicketDetailListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketDetailListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TicketDetailListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TicketDetailListDto.fromJS(resultData200) : new TicketDetailListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketDetailListDto>(<any>null);
    }

    /**
     * 生成或获取取票码
     * @param tickeDetailId (optional) 
     * @return Success
     */
    getCollectionCode(tickeDetailId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetail/GetCollectionCode?";
        if (tickeDetailId !== undefined)
            url_ += "tickeDetailId=" + encodeURIComponent("" + tickeDetailId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCollectionCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCollectionCode(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetCollectionCode(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 获取编辑 TicketDetail
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetTicketDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetail/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTicketDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketDetailForEditOutput.fromJS(resultData200) : new GetTicketDetailForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketDetailForEditOutput>(<any>null);
    }

    /**
     * 获取TicketDetail的分页列表信息
     * @param input (optional) 
     * @return Success
     */
    getPagedGet(input: GetTicketDetailsInput | null | undefined): Observable<PagedResultDtoOfTicketDetailListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetail/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedGet(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketDetailListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketDetailListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedGet(response: HttpResponseBase): Observable<PagedResultDtoOfTicketDetailListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketDetailListDto.fromJS(resultData200) : new PagedResultDtoOfTicketDetailListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketDetailListDto>(<any>null);
    }

    /**
     * 获取TicketDetail的分页列表信息
     * @param input (optional) 
     * @return Success
     */
    getPagedPost(input: GetTicketDetailsInput | null | undefined): Observable<PagedResultDtoOfTicketDetailListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetail/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedPost(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketDetailListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketDetailListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedPost(response: HttpResponseBase): Observable<PagedResultDtoOfTicketDetailListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketDetailListDto.fromJS(resultData200) : new PagedResultDtoOfTicketDetailListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketDetailListDto>(<any>null);
    }

    /**
     * 打印票据
     * @param ticketDetailIds (optional) 
     * @return Success
     */
    printTicketDetail(ticketDetailIds: string[] | null | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetail/PrintTicketDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ticketDetailIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrintTicketDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrintTicketDetail(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processPrintTicketDetail(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }
}

@Injectable()
export class TicketDetailHistoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TicketDetailHistory的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetailHistory/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改TicketDetailHistory的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateTicketDetailHistoryInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetailHistory/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除TicketDetailHistory信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetailHistory/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TicketDetailHistoryListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<TicketDetailHistoryListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetailHistory/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TicketDetailHistoryListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketDetailHistoryListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TicketDetailHistoryListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TicketDetailHistoryListDto.fromJS(resultData200) : new TicketDetailHistoryListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketDetailHistoryListDto>(<any>null);
    }

    /**
     * 获取编辑 TicketDetailHistory
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetTicketDetailHistoryForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetailHistory/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketDetailHistoryForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketDetailHistoryForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTicketDetailHistoryForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketDetailHistoryForEditOutput.fromJS(resultData200) : new GetTicketDetailHistoryForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketDetailHistoryForEditOutput>(<any>null);
    }

    /**
     * 获取TicketDetailHistory的分页列表信息
     * @param queryData (optional) DeviceCode,DeviceName,Port
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTicketDetailHistoryListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetailHistory/GetPaged?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketDetailHistoryListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketDetailHistoryListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTicketDetailHistoryListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketDetailHistoryListDto.fromJS(resultData200) : new PagedResultDtoOfTicketDetailHistoryListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketDetailHistoryListDto>(<any>null);
    }
}

@Injectable()
export class TicketIntroduceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TicketIntroduce的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketIntroduce/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改TicketIntroduce的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateTicketIntroduceInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketIntroduce/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除TicketIntroduce信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketIntroduce/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TicketIntroduceListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<TicketIntroduceListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketIntroduce/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TicketIntroduceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketIntroduceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TicketIntroduceListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TicketIntroduceListDto.fromJS(resultData200) : new TicketIntroduceListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketIntroduceListDto>(<any>null);
    }

    /**
     * 获取编辑 TicketIntroduce
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetTicketIntroduceForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketIntroduce/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketIntroduceForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketIntroduceForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTicketIntroduceForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketIntroduceForEditOutput.fromJS(resultData200) : new GetTicketIntroduceForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketIntroduceForEditOutput>(<any>null);
    }

    /**
     * 获取TicketIntroduce的分页列表信息
     * @param queryData (optional) DeviceCode,DeviceName,Port
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTicketIntroduceListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketIntroduce/GetPaged?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketIntroduceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketIntroduceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTicketIntroduceListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketIntroduceListDto.fromJS(resultData200) : new PagedResultDtoOfTicketIntroduceListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketIntroduceListDto>(<any>null);
    }
}

@Injectable()
export class TicketPriceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TicketPrice的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketPrice/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改TicketPrice的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateTicketPriceInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketPrice/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除TicketPrice信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketPrice/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TicketPriceListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<TicketPriceListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketPrice/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TicketPriceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketPriceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TicketPriceListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TicketPriceListDto.fromJS(resultData200) : new TicketPriceListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketPriceListDto>(<any>null);
    }

    /**
     * 获取编辑 TicketPrice
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetTicketPriceForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketPrice/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketPriceForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketPriceForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTicketPriceForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketPriceForEditOutput.fromJS(resultData200) : new GetTicketPriceForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketPriceForEditOutput>(<any>null);
    }

    /**
     * 获取TicketPrice的分页列表信息
     * @param input (optional) 
     * @return Success
     */
    getPagedGet(input: GetTicketPricesInput | null | undefined): Observable<PagedResultDtoOfTicketPriceListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketPrice/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedGet(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketPriceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketPriceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedGet(response: HttpResponseBase): Observable<PagedResultDtoOfTicketPriceListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketPriceListDto.fromJS(resultData200) : new PagedResultDtoOfTicketPriceListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketPriceListDto>(<any>null);
    }

    /**
     * 获取TicketPrice的分页列表信息
     * @param input (optional) 
     * @return Success
     */
    getPagedPost(input: GetTicketPricesInput | null | undefined): Observable<PagedResultDtoOfTicketPriceListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketPrice/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedPost(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketPriceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketPriceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedPost(response: HttpResponseBase): Observable<PagedResultDtoOfTicketPriceListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketPriceListDto.fromJS(resultData200) : new PagedResultDtoOfTicketPriceListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketPriceListDto>(<any>null);
    }

    /**
     * 航班审核
     * @param input (optional) 
     * @return Success
     */
    getPagedForSchedule(input: GetTicketPricesInput | null | undefined): Observable<PagedResultDtoOfTicketPriceListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketPrice/GetPagedForSchedule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedForSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedForSchedule(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketPriceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketPriceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedForSchedule(response: HttpResponseBase): Observable<PagedResultDtoOfTicketPriceListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketPriceListDto.fromJS(resultData200) : new PagedResultDtoOfTicketPriceListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketPriceListDto>(<any>null);
    }

    /**
     * 设置票型价格的启用状态
     * @param ticketPriceId (optional) 票型价格Id
     * @param isEnabled (optional) 启用状态
     * @return Success
     */
    setPriceEnable(ticketPriceId: string | null | undefined, isEnabled: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketPrice/SetPriceEnable?";
        if (ticketPriceId !== undefined)
            url_ += "ticketPriceId=" + encodeURIComponent("" + ticketPriceId) + "&"; 
        if (isEnabled !== undefined)
            url_ += "isEnabled=" + encodeURIComponent("" + isEnabled) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPriceEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPriceEnable(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetPriceEnable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TicketRoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TicketRole的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketRole/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateTicketRoleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketRole/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketRole/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TicketRoleListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<TicketRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketRole/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TicketRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TicketRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TicketRoleListDto.fromJS(resultData200) : new TicketRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketRoleListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetTicketRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketRole/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTicketRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketRoleForEditOutput.fromJS(resultData200) : new GetTicketRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketRoleForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTicketRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketRole/GetPaged?";
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTicketRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketRoleListDto.fromJS(resultData200) : new PagedResultDtoOfTicketRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketRoleListDto>(<any>null);
    }

    /**
     * 导出为excel文件
     * @return Success
     */
    getToExcelFile(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketRole/GetToExcelFile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToExcelFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToExcelFile(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetToExcelFile(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class TicketScheduleEnableServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TicketScheduleEnable的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketScheduleEnable/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改TicketScheduleEnable的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateTicketScheduleEnableInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketScheduleEnable/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除TicketScheduleEnable信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketScheduleEnable/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TicketScheduleEnableListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<TicketScheduleEnableListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketScheduleEnable/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TicketScheduleEnableListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketScheduleEnableListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TicketScheduleEnableListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TicketScheduleEnableListDto.fromJS(resultData200) : new TicketScheduleEnableListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketScheduleEnableListDto>(<any>null);
    }

    /**
     * 获取编辑 TicketScheduleEnable
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetTicketScheduleEnableForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketScheduleEnable/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketScheduleEnableForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketScheduleEnableForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTicketScheduleEnableForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketScheduleEnableForEditOutput.fromJS(resultData200) : new GetTicketScheduleEnableForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketScheduleEnableForEditOutput>(<any>null);
    }

    /**
     * 获取TicketScheduleEnable的分页列表信息
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTicketScheduleEnableListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketScheduleEnable/GetPaged?";
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketScheduleEnableListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketScheduleEnableListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTicketScheduleEnableListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketScheduleEnableListDto.fromJS(resultData200) : new PagedResultDtoOfTicketScheduleEnableListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketScheduleEnableListDto>(<any>null);
    }
}

@Injectable()
export class TicketStationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TicketStation的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketStation/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改TicketStation的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateTicketStationInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketStation/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除TicketStation信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketStation/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TicketStationListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<TicketStationListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketStation/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TicketStationListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketStationListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TicketStationListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TicketStationListDto.fromJS(resultData200) : new TicketStationListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketStationListDto>(<any>null);
    }

    /**
     * 获取编辑 TicketStation
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetTicketStationForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketStation/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketStationForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketStationForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTicketStationForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketStationForEditOutput.fromJS(resultData200) : new GetTicketStationForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketStationForEditOutput>(<any>null);
    }

    /**
     * 获取TicketStation的分页列表信息
     * @param queryData (optional) DeviceCode,DeviceName,Port
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTicketStationListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketStation/GetPaged?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketStationListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketStationListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTicketStationListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketStationListDto.fromJS(resultData200) : new PagedResultDtoOfTicketStationListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketStationListDto>(<any>null);
    }
}

@Injectable()
export class TicketStationEnableServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TicketStationEnable的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketStationEnable/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改TicketStationEnable的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateTicketStationEnableInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketStationEnable/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除TicketStationEnable信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketStationEnable/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TicketStationEnableListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<TicketStationEnableListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketStationEnable/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TicketStationEnableListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketStationEnableListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TicketStationEnableListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TicketStationEnableListDto.fromJS(resultData200) : new TicketStationEnableListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketStationEnableListDto>(<any>null);
    }

    /**
     * 获取编辑 TicketStationEnable
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetTicketStationEnableForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketStationEnable/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketStationEnableForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketStationEnableForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTicketStationEnableForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketStationEnableForEditOutput.fromJS(resultData200) : new GetTicketStationEnableForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketStationEnableForEditOutput>(<any>null);
    }

    /**
     * 获取TicketStationEnable的分页列表信息
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTicketStationEnableListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketStationEnable/GetPaged?";
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketStationEnableListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketStationEnableListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTicketStationEnableListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketStationEnableListDto.fromJS(resultData200) : new PagedResultDtoOfTicketStationEnableListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketStationEnableListDto>(<any>null);
    }
}

@Injectable()
export class TicketUserEnableServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TicketUserEnable的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketUserEnable/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改TicketUserEnable的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateTicketUserEnableInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketUserEnable/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除TicketUserEnable信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketUserEnable/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TicketUserEnableListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<TicketUserEnableListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketUserEnable/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TicketUserEnableListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketUserEnableListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TicketUserEnableListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TicketUserEnableListDto.fromJS(resultData200) : new TicketUserEnableListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketUserEnableListDto>(<any>null);
    }

    /**
     * 获取编辑 TicketUserEnable
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetTicketUserEnableForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketUserEnable/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketUserEnableForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketUserEnableForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTicketUserEnableForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketUserEnableForEditOutput.fromJS(resultData200) : new GetTicketUserEnableForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketUserEnableForEditOutput>(<any>null);
    }

    /**
     * 获取TicketUserEnable的分页列表信息
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTicketUserEnableListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketUserEnable/GetPaged?";
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketUserEnableListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketUserEnableListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTicketUserEnableListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketUserEnableListDto.fromJS(resultData200) : new PagedResultDtoOfTicketUserEnableListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketUserEnableListDto>(<any>null);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | null | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId !== undefined)
            url_ += "selectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<ComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboboxItemDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTimezones(defaultTimezoneScope: SettingScopes): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezones?";
        if (defaultTimezoneScope === undefined || defaultTimezoneScope === null)
            throw new Error("The parameter 'defaultTimezoneScope' must be defined and cannot be null.");
        else
            url_ += "defaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfNameValueDto.fromJS(resultData200) : new ListResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfNameValueDto>(<any>null);
    }
}

@Injectable()
export class TravelAgencyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TravelAgency的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TravelAgency/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改TravelAgency的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateTravelAgencyInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TravelAgency/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除TravelAgency信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TravelAgency/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TravelAgencyListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<TravelAgencyListDto> {
        let url_ = this.baseUrl + "/api/services/app/TravelAgency/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TravelAgencyListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TravelAgencyListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TravelAgencyListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TravelAgencyListDto.fromJS(resultData200) : new TravelAgencyListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TravelAgencyListDto>(<any>null);
    }

    /**
     * 获取编辑 TravelAgency
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetTravelAgencyForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TravelAgency/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTravelAgencyForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTravelAgencyForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTravelAgencyForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTravelAgencyForEditOutput.fromJS(resultData200) : new GetTravelAgencyForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTravelAgencyForEditOutput>(<any>null);
    }

    /**
     * 获取TravelAgency的分页列表信息
     * @param queryData (optional) DeviceCode,DeviceName,Port
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTravelAgencyListDto> {
        let url_ = this.baseUrl + "/api/services/app/TravelAgency/GetPaged?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTravelAgencyListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTravelAgencyListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTravelAgencyListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTravelAgencyListDto.fromJS(resultData200) : new PagedResultDtoOfTravelAgencyListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTravelAgencyListDto>(<any>null);
    }

    /**
     * 获取TravelAgency的分页列表信息--Post方法
     * @param input (optional) 
     * @return Success
     */
    getPagedForPost(input: GetTravelAgencysInput | null | undefined): Observable<PagedResultDtoOfTravelAgencyListDto> {
        let url_ = this.baseUrl + "/api/services/app/TravelAgency/GetPagedForPost";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedForPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedForPost(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTravelAgencyListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTravelAgencyListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedForPost(response: HttpResponseBase): Observable<PagedResultDtoOfTravelAgencyListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTravelAgencyListDto.fromJS(resultData200) : new PagedResultDtoOfTravelAgencyListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTravelAgencyListDto>(<any>null);
    }

    /**
     * 旅行社售票统计
     * @param queryData (optional) TravelAgencyId, CreationTime
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param routeId (optional) 
     * @param boatId (optional) 
     * @param ticketId (optional) 
     * @return Success
     */
    getPagedStat(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined, routeId: string | null | undefined, boatId: string | null | undefined, ticketId: string | null | undefined): Observable<StatsPagedResultDtoOfTravelAgencyResultDto> {
        let url_ = this.baseUrl + "/api/Stats/TravelAgency/GetPagedStat?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (routeId !== undefined)
            url_ += "routeId=" + encodeURIComponent("" + routeId) + "&"; 
        if (boatId !== undefined)
            url_ += "boatId=" + encodeURIComponent("" + boatId) + "&"; 
        if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedStat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedStat(<any>response_);
                } catch (e) {
                    return <Observable<StatsPagedResultDtoOfTravelAgencyResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatsPagedResultDtoOfTravelAgencyResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedStat(response: HttpResponseBase): Observable<StatsPagedResultDtoOfTravelAgencyResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StatsPagedResultDtoOfTravelAgencyResultDto.fromJS(resultData200) : new StatsPagedResultDtoOfTravelAgencyResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatsPagedResultDtoOfTravelAgencyResultDto>(<any>null);
    }

    /**
     * 旅行社售票统计——详细
     * @param travelAgencyId (optional) 
     * @return Success
     */
    orderSourceStatDetail(travelAgencyId: string | null | undefined): Observable<AccountDetailDto[]> {
        let url_ = this.baseUrl + "/api/Stats/TravelAgency/OrderSourceStatDetail?";
        if (travelAgencyId !== undefined)
            url_ += "travelAgencyId=" + encodeURIComponent("" + travelAgencyId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderSourceStatDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderSourceStatDetail(<any>response_);
                } catch (e) {
                    return <Observable<AccountDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processOrderSourceStatDetail(response: HttpResponseBase): Observable<AccountDetailDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDetailDto[]>(<any>null);
    }
}

@Injectable()
export class TravelTicketDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TravelTicketDetail的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TravelTicketDetail/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改TravelTicketDetail的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateTravelTicketDetailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TravelTicketDetail/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除TravelTicketDetail信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TravelTicketDetail/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TravelTicketDetailListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<TravelTicketDetailListDto> {
        let url_ = this.baseUrl + "/api/services/app/TravelTicketDetail/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TravelTicketDetailListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TravelTicketDetailListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TravelTicketDetailListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TravelTicketDetailListDto.fromJS(resultData200) : new TravelTicketDetailListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TravelTicketDetailListDto>(<any>null);
    }

    /**
     * 获取编辑 TravelTicketDetail
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetTravelTicketDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TravelTicketDetail/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTravelTicketDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTravelTicketDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTravelTicketDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTravelTicketDetailForEditOutput.fromJS(resultData200) : new GetTravelTicketDetailForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTravelTicketDetailForEditOutput>(<any>null);
    }

    /**
     * 获取TravelTicketDetail的分页列表信息
     * @param queryData (optional) DeviceCode,DeviceName,Port
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTravelTicketDetailListDto> {
        let url_ = this.baseUrl + "/api/services/app/TravelTicketDetail/GetPaged?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTravelTicketDetailListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTravelTicketDetailListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTravelTicketDetailListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTravelTicketDetailListDto.fromJS(resultData200) : new PagedResultDtoOfTravelTicketDetailListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTravelTicketDetailListDto>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除用户
     * @param ids (optional) 用户Id列表
     * @return Success
     */
    batchDelete(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 修改用户信息
     * @param id (optional) 
     * @return Success
     */
    getForEditTree(id: number | null | undefined): Observable<GetUserForEditTreeOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetForEditTree?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEditTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEditTree(<any>response_);
                } catch (e) {
                    return <Observable<GetUserForEditTreeOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserForEditTreeOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEditTree(response: HttpResponseBase): Observable<GetUserForEditTreeOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserForEditTreeOutput.fromJS(resultData200) : new GetUserForEditTreeOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditTreeOutput>(<any>null);
    }

    /**
     * 分页获取所有用户
     * @param permission (optional) 权限
     * @param role (optional) 检索角色Id列表
     * @param isEmailConfirmed (optional) 是否已验证邮箱
     * @param isActive (optional) 是否已激活
     * @param onlyLockedUsers (optional) 仅被锁定的用户
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(permission: string[] | null | undefined, role: number[] | null | undefined, isEmailConfirmed: boolean | null | undefined, isActive: boolean | null | undefined, onlyLockedUsers: boolean | null | undefined, filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetPaged?";
        if (permission !== undefined)
            permission && permission.forEach(item => { url_ += "permission=" + encodeURIComponent("" + item) + "&"; });
        if (role !== undefined)
            role && role.forEach(item => { url_ += "role=" + encodeURIComponent("" + item) + "&"; });
        if (isEmailConfirmed !== undefined)
            url_ += "isEmailConfirmed=" + encodeURIComponent("" + isEmailConfirmed) + "&"; 
        if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (onlyLockedUsers !== undefined)
            url_ += "onlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&"; 
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserListDto.fromJS(resultData200) : new PagedResultDtoOfUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserListDto>(<any>null);
    }

    /**
     * 用户的权限编辑
     * @param id (optional) 
     * @return Success
     */
    getPermissionsTreeForEdit(id: number | null | undefined): Observable<GetUserPermissionsTreeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetPermissionsTreeForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissionsTreeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionsTreeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPermissionsTreeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPermissionsTreeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPermissionsTreeForEdit(response: HttpResponseBase): Observable<GetUserPermissionsTreeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserPermissionsTreeForEditOutput.fromJS(resultData200) : new GetUserPermissionsTreeForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPermissionsTreeForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | null | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserForEditOutput.fromJS(resultData200) : new GetUserForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number | null | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserPermissionsForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserPermissionsForEditOutput.fromJS(resultData200) : new GetUserPermissionsForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPermissionsForEditOutput>(<any>null);
    }

    /**
     * 获取用户导出信息
     * @return Success
     */
    getUsersToExcel(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersToExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetPassword(input: NullableIdDtoOfInt64 | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetSpecificPermissions(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetSpecificPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unlock(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Unlock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlock(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlock(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updatePermissions(input: UpdateUserPermissionsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdatePermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetLinkedUsers?";
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLinkedUserDto.fromJS(resultData200) : new PagedResultDtoOfLinkedUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<ListResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfLinkedUserDto.fromJS(resultData200) : new ListResultDtoOfLinkedUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    linkToUser(input: LinkToUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unlinkUser(input: UnlinkUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserListExcelExporterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param userListDtos (optional) 
     * @return Success
     */
    exportToExcel(userListDtos: UserListDto[] | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/UserListExcelExporter/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userListDtos);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<ListResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<ListResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200) : new ListResultDtoOfUserLoginAttemptDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUserLoginAttemptDto>(<any>null);
    }
}

@Injectable()
export class VerifiableSetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除VerifiableSet的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VerifiableSet/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改VerifiableSet的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateVerifiableSetInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VerifiableSet/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除VerifiableSet信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VerifiableSet/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取VerifiableSetListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<VerifiableSetListDto> {
        let url_ = this.baseUrl + "/api/services/app/VerifiableSet/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<VerifiableSetListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<VerifiableSetListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<VerifiableSetListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? VerifiableSetListDto.fromJS(resultData200) : new VerifiableSetListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VerifiableSetListDto>(<any>null);
    }

    /**
     * 获取编辑 VerifiableSet
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetVerifiableSetForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/VerifiableSet/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetVerifiableSetForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetVerifiableSetForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetVerifiableSetForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetVerifiableSetForEditOutput.fromJS(resultData200) : new GetVerifiableSetForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetVerifiableSetForEditOutput>(<any>null);
    }

    /**
     * 获取VerifiableSet的分页列表信息
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfVerifiableSetListDto> {
        let url_ = this.baseUrl + "/api/services/app/VerifiableSet/GetPaged?";
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfVerifiableSetListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfVerifiableSetListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfVerifiableSetListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfVerifiableSetListDto.fromJS(resultData200) : new PagedResultDtoOfVerifiableSetListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfVerifiableSetListDto>(<any>null);
    }
}

@Injectable()
export class WebSiteLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 下载日志文件压缩包
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WebSiteLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * 获取最新的网站日志信息
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebSiteLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLatestWebLogsOutput.fromJS(resultData200) : new GetLatestWebLogsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLatestWebLogsOutput>(<any>null);
    }
}

@Injectable()
export class WechatAppConfigServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除WechatAppConfig的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatAppConfig/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改WechatAppConfig的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateWechatAppConfigInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatAppConfig/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除WechatAppConfig信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatAppConfig/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取WechatAppConfigListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | null | undefined): Observable<WechatAppConfigListDto> {
        let url_ = this.baseUrl + "/api/services/app/WechatAppConfig/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<WechatAppConfigListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WechatAppConfigListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<WechatAppConfigListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WechatAppConfigListDto.fromJS(resultData200) : new WechatAppConfigListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WechatAppConfigListDto>(<any>null);
    }

    /**
     * 获取编辑 WechatAppConfig
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | null | undefined): Observable<GetWechatAppConfigForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WechatAppConfig/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWechatAppConfigForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWechatAppConfigForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetWechatAppConfigForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWechatAppConfigForEditOutput.fromJS(resultData200) : new GetWechatAppConfigForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWechatAppConfigForEditOutput>(<any>null);
    }

    /**
     * 获取WechatAppConfig的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfWechatAppConfigListDto> {
        let url_ = this.baseUrl + "/api/services/app/WechatAppConfig/GetPaged?";
        if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWechatAppConfigListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWechatAppConfigListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfWechatAppConfigListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWechatAppConfigListDto.fromJS(resultData200) : new PagedResultDtoOfWechatAppConfigListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWechatAppConfigListDto>(<any>null);
    }

    /**
     * 将wechat app注入到容器,如果已注入则刷新注入
     * @param appId (optional) 
     * @return Success
     */
    registerWechatApp(appId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatAppConfig/RegisterWechatApp?";
        if (appId !== undefined)
            url_ += "appId=" + encodeURIComponent("" + appId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterWechatApp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterWechatApp(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterWechatApp(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class WechatMediaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    createOtherrMaterial(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/WechatMedia/CreateOtherrMaterial";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOtherrMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOtherrMaterial(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOtherrMaterial(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param appId (optional) 
     * @param mediaId (optional) 
     * @return Success
     */
    delete(appId: string | null | undefined, mediaId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatMedia/Delete?";
        if (appId !== undefined)
            url_ += "appId=" + encodeURIComponent("" + appId) + "&"; 
        if (mediaId !== undefined)
            url_ += "mediaId=" + encodeURIComponent("" + mediaId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getImageTextMaterialPaged(input: GetImageTextMaterialsInput | null | undefined): Observable<PagedResultDtoOfMediaList_News_Item> {
        let url_ = this.baseUrl + "/api/services/app/WechatMedia/GetImageTextMaterialPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImageTextMaterialPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImageTextMaterialPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMediaList_News_Item>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMediaList_News_Item>><any>_observableThrow(response_);
        }));
    }

    protected processGetImageTextMaterialPaged(response: HttpResponseBase): Observable<PagedResultDtoOfMediaList_News_Item> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfMediaList_News_Item.fromJS(resultData200) : new PagedResultDtoOfMediaList_News_Item();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMediaList_News_Item>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getOtherMaterialPaged(input: GetOtherMaterialsInput | null | undefined): Observable<PagedResultDtoOfMediaList_Others_Item> {
        let url_ = this.baseUrl + "/api/services/app/WechatMedia/GetOtherMaterialPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOtherMaterialPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOtherMaterialPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMediaList_Others_Item>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMediaList_Others_Item>><any>_observableThrow(response_);
        }));
    }

    protected processGetOtherMaterialPaged(response: HttpResponseBase): Observable<PagedResultDtoOfMediaList_Others_Item> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfMediaList_Others_Item.fromJS(resultData200) : new PagedResultDtoOfMediaList_Others_Item();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMediaList_Others_Item>(<any>null);
    }
}

@Injectable()
export class WechatMenuAppSeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrWechatEditMenu(input: CreateOrEditWechatMenuInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatMenuAppSevice/CreateOrWechatEditMenu";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrWechatEditMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrWechatEditMenu(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrWechatEditMenu(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param appId (optional) 
     * @param menuConditionalId (optional) 
     * @return Success
     */
    deleteMenuConditional(appId: string | null | undefined, menuConditionalId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatMenuAppSevice/DeleteMenuConditional?";
        if (appId !== undefined)
            url_ += "appId=" + encodeURIComponent("" + appId) + "&"; 
        if (menuConditionalId !== undefined)
            url_ += "menuConditionalId=" + encodeURIComponent("" + menuConditionalId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMenuConditional(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMenuConditional(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMenuConditional(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param appId (optional) 
     * @return Success
     */
    getMenuForEdit(appId: string | null | undefined): Observable<GetWechatMenuForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WechatMenuAppSevice/GetMenuForEdit?";
        if (appId !== undefined)
            url_ += "appId=" + encodeURIComponent("" + appId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMenuForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMenuForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWechatMenuForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWechatMenuForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMenuForEdit(response: HttpResponseBase): Observable<GetWechatMenuForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWechatMenuForEditOutput.fromJS(resultData200) : new GetWechatMenuForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWechatMenuForEditOutput>(<any>null);
    }
}

@Injectable()
export class WharfServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Wharf的方法
     * @param input (optional) 
     * @return Success
     */
    batchDelete(input: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Wharf/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改Wharf的公共方法
     * @param input (optional) 
     * @return Success
     */
    createOrUpdate(input: CreateOrUpdateWharfInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Wharf/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除Wharf信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Wharf/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取WharfListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<WharfListDto> {
        let url_ = this.baseUrl + "/api/services/app/Wharf/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<WharfListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WharfListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<WharfListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WharfListDto.fromJS(resultData200) : new WharfListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WharfListDto>(<any>null);
    }

    /**
     * 获取编辑 Wharf
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | null | undefined): Observable<GetWharfForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Wharf/GetForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWharfForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWharfForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetWharfForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWharfForEditOutput.fromJS(resultData200) : new GetWharfForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWharfForEditOutput>(<any>null);
    }

    /**
     * 获取Wharf的分页列表信息
     * @param input (optional) 
     * @return Success
     */
    getPaged(input: GetWharfsInput | null | undefined): Observable<PagedResultDtoOfWharfListDto> {
        let url_ = this.baseUrl + "/api/services/app/Wharf/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWharfListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWharfListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfWharfListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWharfListDto.fromJS(resultData200) : new PagedResultDtoOfWharfListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWharfListDto>(<any>null);
    }

    /**
     * 从Excel表导入数据
     * @param file (optional) 
     * @return Success
     */
    importWharf(file: FileParameter | null | undefined): Observable<ExcelResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Wharf/ImportWharf";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportWharf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportWharf(<any>response_);
                } catch (e) {
                    return <Observable<ExcelResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExcelResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportWharf(response: HttpResponseBase): Observable<ExcelResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExcelResultDto.fromJS(resultData200) : new ExcelResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExcelResultDto>(<any>null);
    }
}

@Injectable()
export class OperServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 游船列表
     * @return Success
     */
    boatInfo(): Observable<BoatRunningStatusDto[]> {
        let url_ = this.baseUrl + "/api/Stats/Oper/BoatInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBoatInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBoatInfo(<any>response_);
                } catch (e) {
                    return <Observable<BoatRunningStatusDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BoatRunningStatusDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processBoatInfo(response: HttpResponseBase): Observable<BoatRunningStatusDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(BoatRunningStatusDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BoatRunningStatusDto[]>(<any>null);
    }

    /**
     * 营收状态
     * @param date (optional) 
     * @return Success
     */
    revenueAnal(date: string | null | undefined, type: AnalyticType): Observable<RevenueAnalyticsResultDto> {
        let url_ = this.baseUrl + "/api/Stats/Oper/RevenueAnal?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent("" + date) + "&"; 
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRevenueAnal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRevenueAnal(<any>response_);
                } catch (e) {
                    return <Observable<RevenueAnalyticsResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RevenueAnalyticsResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processRevenueAnal(response: HttpResponseBase): Observable<RevenueAnalyticsResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RevenueAnalyticsResultDto.fromJS(resultData200) : new RevenueAnalyticsResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RevenueAnalyticsResultDto>(<any>null);
    }

    /**
     * 可售航班信息
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    scheduleInfo(startDate: string | null | undefined, endDate: string | null | undefined): Observable<ScheduleAnalResultDto[]> {
        let url_ = this.baseUrl + "/api/Stats/Oper/ScheduleInfo?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent("" + startDate) + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent("" + endDate) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScheduleInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScheduleInfo(<any>response_);
                } catch (e) {
                    return <Observable<ScheduleAnalResultDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScheduleAnalResultDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processScheduleInfo(response: HttpResponseBase): Observable<ScheduleAnalResultDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ScheduleAnalResultDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleAnalResultDto[]>(<any>null);
    }

    /**
     * 票型比例
     * @return Success
     */
    ticketRates(type: AnalyticType): Observable<TicketRatesResult[]> {
        let url_ = this.baseUrl + "/api/Stats/Oper/TicketRates?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTicketRates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTicketRates(<any>response_);
                } catch (e) {
                    return <Observable<TicketRatesResult[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketRatesResult[]>><any>_observableThrow(response_);
        }));
    }

    protected processTicketRates(response: HttpResponseBase): Observable<TicketRatesResult[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TicketRatesResult.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketRatesResult[]>(<any>null);
    }
}

@Injectable()
export class OrderSourceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 订单来源统计
     * @param queryData (optional) SourceId, CreationTime
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param routeId (optional) 
     * @param boatId (optional) 
     * @param ticketId (optional) 
     * @return Success
     */
    getPagedStat(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined, routeId: string | null | undefined, boatId: string | null | undefined, ticketId: string | null | undefined): Observable<StatsPagedResultDtoOfGetOrderSourceResultDto> {
        let url_ = this.baseUrl + "/api/Stats/OrderSource/GetPagedStat?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (routeId !== undefined)
            url_ += "routeId=" + encodeURIComponent("" + routeId) + "&"; 
        if (boatId !== undefined)
            url_ += "boatId=" + encodeURIComponent("" + boatId) + "&"; 
        if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedStat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedStat(<any>response_);
                } catch (e) {
                    return <Observable<StatsPagedResultDtoOfGetOrderSourceResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatsPagedResultDtoOfGetOrderSourceResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedStat(response: HttpResponseBase): Observable<StatsPagedResultDtoOfGetOrderSourceResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StatsPagedResultDtoOfGetOrderSourceResultDto.fromJS(resultData200) : new StatsPagedResultDtoOfGetOrderSourceResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatsPagedResultDtoOfGetOrderSourceResultDto>(<any>null);
    }

    /**
     * 订单来源统计——详细
     * @param orderSourceId (optional) 
     * @return Success
     */
    orderSourceStatDetail(orderSourceId: string | null | undefined): Observable<AccountDetailDto[]> {
        let url_ = this.baseUrl + "/api/Stats/OrderSource/OrderSourceStatDetail?";
        if (orderSourceId !== undefined)
            url_ += "orderSourceId=" + encodeURIComponent("" + orderSourceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderSourceStatDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderSourceStatDetail(<any>response_);
                } catch (e) {
                    return <Observable<AccountDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processOrderSourceStatDetail(response: HttpResponseBase): Observable<AccountDetailDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDetailDto[]>(<any>null);
    }
}

@Injectable()
export class OtaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Ota统计
     * @param queryData (optional) SourceId, CreationTime
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param routeId (optional) 
     * @param boatId (optional) 
     * @param ticketId (optional) 
     * @return Success
     */
    getPagedStat(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined, routeId: string | null | undefined, boatId: string | null | undefined, ticketId: string | null | undefined): Observable<StatsPagedResultDtoOfGetOrderSourceResultDto> {
        let url_ = this.baseUrl + "/api/Stats/Ota/GetPagedStat?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (routeId !== undefined)
            url_ += "routeId=" + encodeURIComponent("" + routeId) + "&"; 
        if (boatId !== undefined)
            url_ += "boatId=" + encodeURIComponent("" + boatId) + "&"; 
        if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedStat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedStat(<any>response_);
                } catch (e) {
                    return <Observable<StatsPagedResultDtoOfGetOrderSourceResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatsPagedResultDtoOfGetOrderSourceResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedStat(response: HttpResponseBase): Observable<StatsPagedResultDtoOfGetOrderSourceResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StatsPagedResultDtoOfGetOrderSourceResultDto.fromJS(resultData200) : new StatsPagedResultDtoOfGetOrderSourceResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatsPagedResultDtoOfGetOrderSourceResultDto>(<any>null);
    }

    /**
     * OTA售票统计——详细
     * @param otaId (optional) 
     * @return Success
     */
    orderSourceStatDetail(otaId: string | null | undefined): Observable<AccountDetailDto[]> {
        let url_ = this.baseUrl + "/api/Stats/Ota/OrderSourceStatDetail?";
        if (otaId !== undefined)
            url_ += "otaId=" + encodeURIComponent("" + otaId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderSourceStatDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderSourceStatDetail(<any>response_);
                } catch (e) {
                    return <Observable<AccountDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processOrderSourceStatDetail(response: HttpResponseBase): Observable<AccountDetailDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDetailDto[]>(<any>null);
    }
}

@Injectable()
export class ScheduleCheckServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 航班检票统计
     * @param queryData (optional) ScheduleCode 航班班次， RouteId 航线Id， BoatId 游船Id， StartTime 航行日期，
    Route.StartWharfId 检票地点ID
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPagedStat(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<StatsPagedResultDtoOfScheduleCheckResultDto> {
        let url_ = this.baseUrl + "/api/Stats/ScheduleCheck/GetPagedStat?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedStat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedStat(<any>response_);
                } catch (e) {
                    return <Observable<StatsPagedResultDtoOfScheduleCheckResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatsPagedResultDtoOfScheduleCheckResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedStat(response: HttpResponseBase): Observable<StatsPagedResultDtoOfScheduleCheckResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StatsPagedResultDtoOfScheduleCheckResultDto.fromJS(resultData200) : new StatsPagedResultDtoOfScheduleCheckResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatsPagedResultDtoOfScheduleCheckResultDto>(<any>null);
    }

    /**
     * 航班检票统计——详细
     * @param scheduleId (optional) 
     * @return Success
     */
    scheduleDetailStat(scheduleId: string | null | undefined): Observable<PagedResultDtoOfScheduleCheckDetailDto> {
        let url_ = this.baseUrl + "/api/Stats/ScheduleCheck/ScheduleDetailStat?";
        if (scheduleId !== undefined)
            url_ += "scheduleId=" + encodeURIComponent("" + scheduleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScheduleDetailStat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScheduleDetailStat(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfScheduleCheckDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfScheduleCheckDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processScheduleDetailStat(response: HttpResponseBase): Observable<PagedResultDtoOfScheduleCheckDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfScheduleCheckDetailDto.fromJS(resultData200) : new PagedResultDtoOfScheduleCheckDetailDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfScheduleCheckDetailDto>(<any>null);
    }
}

@Injectable()
export class ScheduleTicketServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 航班售票统计
     * @param queryData (optional) ScheduleCode 航班班次， RouteId 航线Id， BoatId 游船Id， StartTime 航行日期
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param ticketId (optional) 
     * @return Success
     */
    getPagedStat(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined, ticketId: string | null | undefined): Observable<StatsPagedResultDtoOfScheduleTicketResultDto> {
        let url_ = this.baseUrl + "/api/Stats/ScheduleTicket/GetPagedStat?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedStat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedStat(<any>response_);
                } catch (e) {
                    return <Observable<StatsPagedResultDtoOfScheduleTicketResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatsPagedResultDtoOfScheduleTicketResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedStat(response: HttpResponseBase): Observable<StatsPagedResultDtoOfScheduleTicketResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StatsPagedResultDtoOfScheduleTicketResultDto.fromJS(resultData200) : new StatsPagedResultDtoOfScheduleTicketResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatsPagedResultDtoOfScheduleTicketResultDto>(<any>null);
    }

    /**
     * 航班售票详情
     * @param scheduleId (optional) 
     * @return Success
     */
    scheduleDetailStat(scheduleId: string | null | undefined): Observable<PagedResultDtoOfScheduleTicketDetailResultDto> {
        let url_ = this.baseUrl + "/api/Stats/ScheduleTicket/ScheduleDetailStat?";
        if (scheduleId !== undefined)
            url_ += "scheduleId=" + encodeURIComponent("" + scheduleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScheduleDetailStat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScheduleDetailStat(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfScheduleTicketDetailResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfScheduleTicketDetailResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processScheduleDetailStat(response: HttpResponseBase): Observable<PagedResultDtoOfScheduleTicketDetailResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfScheduleTicketDetailResultDto.fromJS(resultData200) : new PagedResultDtoOfScheduleTicketDetailResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfScheduleTicketDetailResultDto>(<any>null);
    }
}

@Injectable()
export class SellerDailyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 销售员日结统计——详细
     * @param userId (optional) 
     * @return Success
     */
    detail(userId: string | null | undefined): Observable<AccountDetailDto[]> {
        let url_ = this.baseUrl + "/api/Stats/SellerDaily/Detail?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetail(<any>response_);
                } catch (e) {
                    return <Observable<AccountDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processDetail(response: HttpResponseBase): Observable<AccountDetailDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDetailDto[]>(<any>null);
    }

    /**
     * 销售员日结统计
     * @param queryData (optional) ScheduleId, CreatorId,CreationTime
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param boatId (optional) 
     * @param ticketId (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined, boatId: string | null | undefined, ticketId: string | null | undefined): Observable<StatsPagedResultDtoOfSellerDailyResultDto> {
        let url_ = this.baseUrl + "/api/Stats/SellerDaily/GetPaged?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (boatId !== undefined)
            url_ += "boatId=" + encodeURIComponent("" + boatId) + "&"; 
        if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<StatsPagedResultDtoOfSellerDailyResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatsPagedResultDtoOfSellerDailyResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<StatsPagedResultDtoOfSellerDailyResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StatsPagedResultDtoOfSellerDailyResultDto.fromJS(resultData200) : new StatsPagedResultDtoOfSellerDailyResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatsPagedResultDtoOfSellerDailyResultDto>(<any>null);
    }
}

@Injectable()
export class SellerTicketServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 售票员售票统计
     * @param queryData (optional) ScheduleId, CreatorId,CreationTime
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param boatId (optional) 
     * @param ticketId (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined, boatId: string | null | undefined, ticketId: string | null | undefined): Observable<StatsPagedResultDtoOfSellerTicketResultDto> {
        let url_ = this.baseUrl + "/api/Stats/SellerTicket/GetPaged?";
        if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (boatId !== undefined)
            url_ += "boatId=" + encodeURIComponent("" + boatId) + "&"; 
        if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<StatsPagedResultDtoOfSellerTicketResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatsPagedResultDtoOfSellerTicketResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<StatsPagedResultDtoOfSellerTicketResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StatsPagedResultDtoOfSellerTicketResultDto.fromJS(resultData200) : new StatsPagedResultDtoOfSellerTicketResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatsPagedResultDtoOfSellerTicketResultDto>(<any>null);
    }

    /**
     * 销售员售票统计——详情
     * @param userId (optional) 
     * @return Success
     */
    sellerTicketDetailStat(userId: string | null | undefined): Observable<StatsPagedResultDtoOfScheduleTicketDetailResultDto> {
        let url_ = this.baseUrl + "/api/Stats/SellerTicket/SellerTicketDetailStat?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSellerTicketDetailStat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSellerTicketDetailStat(<any>response_);
                } catch (e) {
                    return <Observable<StatsPagedResultDtoOfScheduleTicketDetailResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatsPagedResultDtoOfScheduleTicketDetailResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processSellerTicketDetailStat(response: HttpResponseBase): Observable<StatsPagedResultDtoOfScheduleTicketDetailResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StatsPagedResultDtoOfScheduleTicketDetailResultDto.fromJS(resultData200) : new StatsPagedResultDtoOfScheduleTicketDetailResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatsPagedResultDtoOfScheduleTicketDetailResultDto>(<any>null);
    }
}

@Injectable()
export class BankPayTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    testMessage(): Observable<void> {
        let url_ = this.baseUrl + "/api/Test/BankPayTest/TestMessage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestMessage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestMessage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class FinanceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 账单明细
     * @param accountId (optional) 
     * @return Success
     */
    detail(accountId: string | null | undefined): Observable<AccountDetailDto[]> {
        let url_ = this.baseUrl + "/api/TicketAccount/Finance/Detail?";
        if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetail(<any>response_);
                } catch (e) {
                    return <Observable<AccountDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processDetail(response: HttpResponseBase): Observable<AccountDetailDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDetailDto[]>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    activateAccount(model: ActivateAccountModel | null | undefined): Observable<ActivateAccountResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ActivateAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateAccount(<any>response_);
                } catch (e) {
                    return <Observable<ActivateAccountResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivateAccountResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processActivateAccount(response: HttpResponseBase): Observable<ActivateAccountResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivateAccountResultModel.fromJS(resultData200) : new ActivateAccountResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivateAccountResultModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    authenticate(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    externalAuthenticate(model: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }

    /**
     * 生成验证码
     * @param name (optional) 
     * @param tid (optional) 
     * @return Success
     */
    generateVerification(name: string | null | undefined, tid: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/GenerateVerification?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (tid !== undefined)
            url_ += "tid=" + encodeURIComponent("" + tid) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateVerification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateVerification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateVerification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param impersonationToken (optional) 
     * @return Success
     */
    impersonatedAuthenticate(impersonationToken: string | null | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (impersonationToken !== undefined)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonatedAuthenticateResultModel.fromJS(resultData200) : new ImpersonatedAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonatedAuthenticateResultModel>(<any>null);
    }

    /**
     * @param switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string | null | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken !== undefined)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchedAccountAuthenticateResultModel.fromJS(resultData200) : new SwitchedAccountAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchedAccountAuthenticateResultModel>(<any>null);
    }

    /**
     * 官网登录接口，以后需要填写游客信息（用户名密码，手机号验证码）才能登录，现在直接登录
     * @param login (optional) 
     * @return Success
     */
    webtLogin(login: Login | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/WebtLogin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWebtLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWebtLogin(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processWebtLogin(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * 微信登录接口，以后需要填写游客信息（用户名密码，手机号验证码）才能登录，现在直接登录
     * @param openId (optional) 现在可以不填写
     * @return Success
     */
    wechatLogin(openId: string | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/WechatLogin?";
        if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWechatLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWechatLogin(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processWechatLogin(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * 自助机登录接口，验证码传空字符串
     * @param model (optional) 
     * @return Success
     */
    ziZhuJiLogin(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ZiZhuJiLogin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processZiZhuJiLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processZiZhuJiLogin(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processZiZhuJiLogin(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class VerificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 生成验证码
     * @param name (optional) 验证码key
     * @param t (optional) 验证码类型
     * @param tid (optional) 租户Id(可空)
     * @return Success
     */
    generateCaptcha(name: string | null | undefined, t: CaptchaType | null | undefined, tid: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Verification/GenerateCaptcha?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (t !== undefined)
            url_ += "t=" + encodeURIComponent("" + t) + "&"; 
        if (tid !== undefined)
            url_ += "tid=" + encodeURIComponent("" + tid) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateCaptcha(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateCaptcha(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateCaptcha(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class WechatPayServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 获取OpenId
     * @param code (optional) 
     * @return Success
     */
    getOpenId(code: string | null | undefined): Observable<AjaxResult> {
        let url_ = this.baseUrl + "/api/WechatPay/GetOpenId?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOpenId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOpenId(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AjaxResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetOpenId(response: HttpResponseBase): Observable<AjaxResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AjaxResult.fromJS(resultData200) : new AjaxResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AjaxResult>(<any>null);
    }

    /**
     * 获取OpenId
     * @param appid (optional) 
     * @param secret (optional) 
     * @param grant_type (optional) 
     * @return Success
     */
    getToken(appid: string | null | undefined, secret: string | null | undefined, grant_type: string | null | undefined): Observable<AccessTokenResult> {
        let url_ = this.baseUrl + "/api/WechatPay/GetToken?";
        if (appid !== undefined)
            url_ += "appid=" + encodeURIComponent("" + appid) + "&"; 
        if (secret !== undefined)
            url_ += "secret=" + encodeURIComponent("" + secret) + "&"; 
        if (grant_type !== undefined)
            url_ += "grant_type=" + encodeURIComponent("" + grant_type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToken(<any>response_);
                } catch (e) {
                    return <Observable<AccessTokenResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccessTokenResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetToken(response: HttpResponseBase): Observable<AccessTokenResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccessTokenResult.fromJS(resultData200) : new AccessTokenResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccessTokenResult>(<any>null);
    }

    /**
     * 支付回调URL，对应于Service.Config.TenPayV3Notify
     * @return Success
     */
    payNotifyUrlGet(): Observable<void> {
        let url_ = this.baseUrl + "/api/WechatPay/PayNotifyUrl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayNotifyUrlGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayNotifyUrlGet(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPayNotifyUrlGet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 支付回调URL，对应于Service.Config.TenPayV3Notify
     * @return Success
     */
    payNotifyUrlPut(): Observable<void> {
        let url_ = this.baseUrl + "/api/WechatPay/PayNotifyUrl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayNotifyUrlPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayNotifyUrlPut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPayNotifyUrlPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 支付回调URL，对应于Service.Config.TenPayV3Notify
     * @return Success
     */
    payNotifyUrlPost(): Observable<void> {
        let url_ = this.baseUrl + "/api/WechatPay/PayNotifyUrl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayNotifyUrlPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayNotifyUrlPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPayNotifyUrlPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 根据票据Id退票，暂存订单支付状态不变，只修改票据状态，可以调用/api/services/app/ActivityTempDetail/GetDetailListByTempId查询状态
     * @param ticketDetailId (optional) 票据id
     * @return Success
     */
    refundGet(ticketDetailId: string | null | undefined): Observable<AjaxResult> {
        let url_ = this.baseUrl + "/api/WechatPay/Refund?";
        if (ticketDetailId !== undefined)
            url_ += "ticketDetailId=" + encodeURIComponent("" + ticketDetailId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefundGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefundGet(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AjaxResult>><any>_observableThrow(response_);
        }));
    }

    protected processRefundGet(response: HttpResponseBase): Observable<AjaxResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AjaxResult.fromJS(resultData200) : new AjaxResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AjaxResult>(<any>null);
    }

    /**
     * 根据票据Id退票，暂存订单支付状态不变，只修改票据状态，可以调用/api/services/app/ActivityTempDetail/GetDetailListByTempId查询状态
     * @param ticketDetailId (optional) 票据id
     * @return Success
     */
    refundPost(ticketDetailId: string | null | undefined): Observable<AjaxResult> {
        let url_ = this.baseUrl + "/api/WechatPay/Refund?";
        if (ticketDetailId !== undefined)
            url_ += "ticketDetailId=" + encodeURIComponent("" + ticketDetailId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefundPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefundPost(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AjaxResult>><any>_observableThrow(response_);
        }));
    }

    protected processRefundPost(response: HttpResponseBase): Observable<AjaxResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AjaxResult.fromJS(resultData200) : new AjaxResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AjaxResult>(<any>null);
    }

    /**
     * 发起支付请求,生成暂存订单
     * @param createActivityModel (optional) 
     * @return Success
     */
    wechatPayOrder(createActivityModel: CreateActivityModel | null | undefined): Observable<AjaxResult> {
        let url_ = this.baseUrl + "/api/WechatPay/WechatPayOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createActivityModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWechatPayOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWechatPayOrder(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AjaxResult>><any>_observableThrow(response_);
        }));
    }

    protected processWechatPayOrder(response: HttpResponseBase): Observable<AjaxResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AjaxResult.fromJS(resultData200) : new AjaxResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AjaxResult>(<any>null);
    }

    /**
     * 重新支付暂存订单
     * @param activityTempId (optional) 暂存订单Id
     * @return Success
     */
    wechatPayOrderAgain(activityTempId: string | null | undefined): Observable<AjaxResult> {
        let url_ = this.baseUrl + "/api/WechatPay/WechatPayOrderAgain?";
        if (activityTempId !== undefined)
            url_ += "activityTempId=" + encodeURIComponent("" + activityTempId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWechatPayOrderAgain(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWechatPayOrderAgain(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AjaxResult>><any>_observableThrow(response_);
        }));
    }

    protected processWechatPayOrderAgain(response: HttpResponseBase): Observable<AjaxResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AjaxResult.fromJS(resultData200) : new AjaxResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AjaxResult>(<any>null);
    }
}

export class ActivityResultModel implements IActivityResultModel {
    activityId: string | undefined;
    resultCode: string | undefined;
    resultMessage: string | undefined;
    detail: string | undefined;
    date: any | undefined;

    constructor(data?: IActivityResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.activityId = data["activityId"];
            this.resultCode = data["resultCode"];
            this.resultMessage = data["resultMessage"];
            this.detail = data["detail"];
            this.date = data["date"];
        }
    }

    static fromJS(data: any): ActivityResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["resultCode"] = this.resultCode;
        data["resultMessage"] = this.resultMessage;
        data["detail"] = this.detail;
        data["date"] = this.date;
        return data; 
    }

    clone(): ActivityResultModel {
        const json = this.toJSON();
        let result = new ActivityResultModel();
        result.init(json);
        return result;
    }
}

export interface IActivityResultModel {
    activityId: string | undefined;
    resultCode: string | undefined;
    resultMessage: string | undefined;
    detail: string | undefined;
    date: any | undefined;
}

export class CreateActivityModel implements ICreateActivityModel {
    sourceId: string | undefined;
    payMethodId: string | undefined;
    voucherNo: string | undefined;
    orderType: OrderTypeEnum | undefined;
    remark: string | undefined;
    createUserId: number | undefined;
    totalQuantity: number | undefined;
    totalAmount: number | undefined;
    activityDetails: CreateActivityDetailModel[] | undefined;
    travelAgencyId: string | undefined;
    openId: string | undefined;

    constructor(data?: ICreateActivityModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceId = data["sourceId"];
            this.payMethodId = data["payMethodId"];
            this.voucherNo = data["voucherNo"];
            this.orderType = data["orderType"];
            this.remark = data["remark"];
            this.createUserId = data["createUserId"];
            this.totalQuantity = data["totalQuantity"];
            this.totalAmount = data["totalAmount"];
            if (data["activityDetails"] && data["activityDetails"].constructor === Array) {
                this.activityDetails = [] as any;
                for (let item of data["activityDetails"])
                    this.activityDetails.push(CreateActivityDetailModel.fromJS(item));
            }
            this.travelAgencyId = data["travelAgencyId"];
            this.openId = data["openId"];
        }
    }

    static fromJS(data: any): CreateActivityModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActivityModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceId"] = this.sourceId;
        data["payMethodId"] = this.payMethodId;
        data["voucherNo"] = this.voucherNo;
        data["orderType"] = this.orderType;
        data["remark"] = this.remark;
        data["createUserId"] = this.createUserId;
        data["totalQuantity"] = this.totalQuantity;
        data["totalAmount"] = this.totalAmount;
        if (this.activityDetails && this.activityDetails.constructor === Array) {
            data["activityDetails"] = [];
            for (let item of this.activityDetails)
                data["activityDetails"].push(item.toJSON());
        }
        data["travelAgencyId"] = this.travelAgencyId;
        data["openId"] = this.openId;
        return data; 
    }

    clone(): CreateActivityModel {
        const json = this.toJSON();
        let result = new CreateActivityModel();
        result.init(json);
        return result;
    }
}

export interface ICreateActivityModel {
    sourceId: string | undefined;
    payMethodId: string | undefined;
    voucherNo: string | undefined;
    orderType: OrderTypeEnum | undefined;
    remark: string | undefined;
    createUserId: number | undefined;
    totalQuantity: number | undefined;
    totalAmount: number | undefined;
    activityDetails: CreateActivityDetailModel[] | undefined;
    travelAgencyId: string | undefined;
    openId: string | undefined;
}

export enum OrderTypeEnum {
    OrderTypeCustomer = <any>"OrderTypeCustomer", 
    OrderTypeTravelAgency = <any>"OrderTypeTravelAgency", 
}

export class CreateActivityDetailModel implements ICreateActivityDetailModel {
    quantity: number | undefined;
    ticketPriceId: string | undefined;
    scheduleId: string | undefined;
    customerId: string | undefined;

    constructor(data?: ICreateActivityDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.quantity = data["quantity"];
            this.ticketPriceId = data["ticketPriceId"];
            this.scheduleId = data["scheduleId"];
            this.customerId = data["customerId"];
        }
    }

    static fromJS(data: any): CreateActivityDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActivityDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        data["ticketPriceId"] = this.ticketPriceId;
        data["scheduleId"] = this.scheduleId;
        data["customerId"] = this.customerId;
        return data; 
    }

    clone(): CreateActivityDetailModel {
        const json = this.toJSON();
        let result = new CreateActivityDetailModel();
        result.init(json);
        return result;
    }
}

export interface ICreateActivityDetailModel {
    quantity: number | undefined;
    ticketPriceId: string | undefined;
    scheduleId: string | undefined;
    customerId: string | undefined;
}

export class Boat implements IBoat {
    branchId: string | undefined;
    boatName: string;
    boatCode: string;
    seatNumber: number;
    runStatus: RunStatusEnum | undefined;
    leader: string | undefined;
    leaderMobile: string | undefined;
    picture: string | undefined;
    auditStatus: AuditStatusEnum | undefined;
    schedules: Schedule[] | undefined;
    routeId: string | undefined;
    route: Route | undefined;
    standardNum: number | undefined;
    vipNum: number | undefined;
    compartmentNum: number | undefined;
    callName: string | undefined;
    imoNumber: string | undefined;
    createDate: moment.Moment | undefined;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    grossPower: number | undefined;
    registryPort: string | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IBoat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.boatName = data["boatName"];
            this.boatCode = data["boatCode"];
            this.seatNumber = data["seatNumber"];
            this.runStatus = data["runStatus"];
            this.leader = data["leader"];
            this.leaderMobile = data["leaderMobile"];
            this.picture = data["picture"];
            this.auditStatus = data["auditStatus"];
            if (data["schedules"] && data["schedules"].constructor === Array) {
                this.schedules = [] as any;
                for (let item of data["schedules"])
                    this.schedules.push(Schedule.fromJS(item));
            }
            this.routeId = data["routeId"];
            this.route = data["route"] ? Route.fromJS(data["route"]) : <any>undefined;
            this.standardNum = data["standardNum"];
            this.vipNum = data["vipNum"];
            this.compartmentNum = data["compartmentNum"];
            this.callName = data["callName"];
            this.imoNumber = data["imoNumber"];
            this.createDate = data["createDate"] ? moment(data["createDate"].toString()) : <any>undefined;
            this.grossWeight = data["grossWeight"];
            this.netWeight = data["netWeight"];
            this.grossPower = data["grossPower"];
            this.registryPort = data["registryPort"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Boat {
        data = typeof data === 'object' ? data : {};
        let result = new Boat();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["boatName"] = this.boatName;
        data["boatCode"] = this.boatCode;
        data["seatNumber"] = this.seatNumber;
        data["runStatus"] = this.runStatus;
        data["leader"] = this.leader;
        data["leaderMobile"] = this.leaderMobile;
        data["picture"] = this.picture;
        data["auditStatus"] = this.auditStatus;
        if (this.schedules && this.schedules.constructor === Array) {
            data["schedules"] = [];
            for (let item of this.schedules)
                data["schedules"].push(item.toJSON());
        }
        data["routeId"] = this.routeId;
        data["route"] = this.route ? this.route.toJSON() : <any>undefined;
        data["standardNum"] = this.standardNum;
        data["vipNum"] = this.vipNum;
        data["compartmentNum"] = this.compartmentNum;
        data["callName"] = this.callName;
        data["imoNumber"] = this.imoNumber;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["grossWeight"] = this.grossWeight;
        data["netWeight"] = this.netWeight;
        data["grossPower"] = this.grossPower;
        data["registryPort"] = this.registryPort;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Boat {
        const json = this.toJSON();
        let result = new Boat();
        result.init(json);
        return result;
    }
}

export interface IBoat {
    branchId: string | undefined;
    boatName: string;
    boatCode: string;
    seatNumber: number;
    runStatus: RunStatusEnum | undefined;
    leader: string | undefined;
    leaderMobile: string | undefined;
    picture: string | undefined;
    auditStatus: AuditStatusEnum | undefined;
    schedules: Schedule[] | undefined;
    routeId: string | undefined;
    route: Route | undefined;
    standardNum: number | undefined;
    vipNum: number | undefined;
    compartmentNum: number | undefined;
    callName: string | undefined;
    imoNumber: string | undefined;
    createDate: moment.Moment | undefined;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    grossPower: number | undefined;
    registryPort: string | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export enum RunStatusEnum {
    Running = <any>"Running", 
    Maintenance = <any>"Maintenance", 
}

export enum AuditStatusEnum {
    WaiteAudit = <any>"WaiteAudit", 
    ThroughAudit = <any>"ThroughAudit", 
    RejecteAudit = <any>"RejecteAudit", 
}

export class Schedule implements ISchedule {
    branchId: string | undefined;
    scheduleCode: string | undefined;
    routeId: string | undefined;
    route: Route | undefined;
    boatId: string | undefined;
    boat: Boat | undefined;
    saleDate: moment.Moment | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment;
    seatQuantity: number;
    surplusQuantity: number;
    scheduleStatus: ScheduleStatusEnum | undefined;
    auditStatus: AuditStatusEnum | undefined;
    checkStartTime: moment.Moment | undefined;
    checkEndTime: moment.Moment | undefined;
    reserveQuantity: number | undefined;
    standardNum: number | undefined;
    standardSurplusNum: number | undefined;
    standardReserveNum: number | undefined;
    vipNum: number | undefined;
    vipSurplusNum: number | undefined;
    vipReserveNum: number | undefined;
    compartmentNum: number | undefined;
    compartmentSurplusNum: number | undefined;
    compartmentReserveNum: number | undefined;
    scheduleSaleStatus: ScheduleEnum | undefined;
    remark: string | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ISchedule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.scheduleCode = data["scheduleCode"];
            this.routeId = data["routeId"];
            this.route = data["route"] ? Route.fromJS(data["route"]) : <any>undefined;
            this.boatId = data["boatId"];
            this.boat = data["boat"] ? Boat.fromJS(data["boat"]) : <any>undefined;
            this.saleDate = data["saleDate"] ? moment(data["saleDate"].toString()) : <any>undefined;
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.seatQuantity = data["seatQuantity"];
            this.surplusQuantity = data["surplusQuantity"];
            this.scheduleStatus = data["scheduleStatus"];
            this.auditStatus = data["auditStatus"];
            this.checkStartTime = data["checkStartTime"] ? moment(data["checkStartTime"].toString()) : <any>undefined;
            this.checkEndTime = data["checkEndTime"] ? moment(data["checkEndTime"].toString()) : <any>undefined;
            this.reserveQuantity = data["reserveQuantity"];
            this.standardNum = data["standardNum"];
            this.standardSurplusNum = data["standardSurplusNum"];
            this.standardReserveNum = data["standardReserveNum"];
            this.vipNum = data["vipNum"];
            this.vipSurplusNum = data["vipSurplusNum"];
            this.vipReserveNum = data["vipReserveNum"];
            this.compartmentNum = data["compartmentNum"];
            this.compartmentSurplusNum = data["compartmentSurplusNum"];
            this.compartmentReserveNum = data["compartmentReserveNum"];
            this.scheduleSaleStatus = data["scheduleSaleStatus"];
            this.remark = data["remark"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Schedule {
        data = typeof data === 'object' ? data : {};
        let result = new Schedule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["scheduleCode"] = this.scheduleCode;
        data["routeId"] = this.routeId;
        data["route"] = this.route ? this.route.toJSON() : <any>undefined;
        data["boatId"] = this.boatId;
        data["boat"] = this.boat ? this.boat.toJSON() : <any>undefined;
        data["saleDate"] = this.saleDate ? this.saleDate.toISOString() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["seatQuantity"] = this.seatQuantity;
        data["surplusQuantity"] = this.surplusQuantity;
        data["scheduleStatus"] = this.scheduleStatus;
        data["auditStatus"] = this.auditStatus;
        data["checkStartTime"] = this.checkStartTime ? this.checkStartTime.toISOString() : <any>undefined;
        data["checkEndTime"] = this.checkEndTime ? this.checkEndTime.toISOString() : <any>undefined;
        data["reserveQuantity"] = this.reserveQuantity;
        data["standardNum"] = this.standardNum;
        data["standardSurplusNum"] = this.standardSurplusNum;
        data["standardReserveNum"] = this.standardReserveNum;
        data["vipNum"] = this.vipNum;
        data["vipSurplusNum"] = this.vipSurplusNum;
        data["vipReserveNum"] = this.vipReserveNum;
        data["compartmentNum"] = this.compartmentNum;
        data["compartmentSurplusNum"] = this.compartmentSurplusNum;
        data["compartmentReserveNum"] = this.compartmentReserveNum;
        data["scheduleSaleStatus"] = this.scheduleSaleStatus;
        data["remark"] = this.remark;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Schedule {
        const json = this.toJSON();
        let result = new Schedule();
        result.init(json);
        return result;
    }
}

export interface ISchedule {
    branchId: string | undefined;
    scheduleCode: string | undefined;
    routeId: string | undefined;
    route: Route | undefined;
    boatId: string | undefined;
    boat: Boat | undefined;
    saleDate: moment.Moment | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment;
    seatQuantity: number;
    surplusQuantity: number;
    scheduleStatus: ScheduleStatusEnum | undefined;
    auditStatus: AuditStatusEnum | undefined;
    checkStartTime: moment.Moment | undefined;
    checkEndTime: moment.Moment | undefined;
    reserveQuantity: number | undefined;
    standardNum: number | undefined;
    standardSurplusNum: number | undefined;
    standardReserveNum: number | undefined;
    vipNum: number | undefined;
    vipSurplusNum: number | undefined;
    vipReserveNum: number | undefined;
    compartmentNum: number | undefined;
    compartmentSurplusNum: number | undefined;
    compartmentReserveNum: number | undefined;
    scheduleSaleStatus: ScheduleEnum | undefined;
    remark: string | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class Route implements IRoute {
    branchId: string | undefined;
    routeName: string;
    lineCode: number;
    lineInfo: string;
    lineImage: string;
    startPosition: string;
    startWharfId: string | undefined;
    startWharf: Wharf | undefined;
    endPosition: string;
    endWharfId: string | undefined;
    endWharf: Wharf | undefined;
    auditStatus: AuditStatusEnum | undefined;
    schedules: Schedule[] | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.routeName = data["routeName"];
            this.lineCode = data["lineCode"];
            this.lineInfo = data["lineInfo"];
            this.lineImage = data["lineImage"];
            this.startPosition = data["startPosition"];
            this.startWharfId = data["startWharfId"];
            this.startWharf = data["startWharf"] ? Wharf.fromJS(data["startWharf"]) : <any>undefined;
            this.endPosition = data["endPosition"];
            this.endWharfId = data["endWharfId"];
            this.endWharf = data["endWharf"] ? Wharf.fromJS(data["endWharf"]) : <any>undefined;
            this.auditStatus = data["auditStatus"];
            if (data["schedules"] && data["schedules"].constructor === Array) {
                this.schedules = [] as any;
                for (let item of data["schedules"])
                    this.schedules.push(Schedule.fromJS(item));
            }
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Route {
        data = typeof data === 'object' ? data : {};
        let result = new Route();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["routeName"] = this.routeName;
        data["lineCode"] = this.lineCode;
        data["lineInfo"] = this.lineInfo;
        data["lineImage"] = this.lineImage;
        data["startPosition"] = this.startPosition;
        data["startWharfId"] = this.startWharfId;
        data["startWharf"] = this.startWharf ? this.startWharf.toJSON() : <any>undefined;
        data["endPosition"] = this.endPosition;
        data["endWharfId"] = this.endWharfId;
        data["endWharf"] = this.endWharf ? this.endWharf.toJSON() : <any>undefined;
        data["auditStatus"] = this.auditStatus;
        if (this.schedules && this.schedules.constructor === Array) {
            data["schedules"] = [];
            for (let item of this.schedules)
                data["schedules"].push(item.toJSON());
        }
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Route {
        const json = this.toJSON();
        let result = new Route();
        result.init(json);
        return result;
    }
}

export interface IRoute {
    branchId: string | undefined;
    routeName: string;
    lineCode: number;
    lineInfo: string;
    lineImage: string;
    startPosition: string;
    startWharfId: string | undefined;
    startWharf: Wharf | undefined;
    endPosition: string;
    endWharfId: string | undefined;
    endWharf: Wharf | undefined;
    auditStatus: AuditStatusEnum | undefined;
    schedules: Schedule[] | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class User implements IUser {
    signInToken: string | undefined;
    needToChangeThePassword: boolean | undefined;
    signInTokenExpireTimeUtc: moment.Moment | undefined;
    name: string;
    profilePictureId: string | undefined;
    surname: string;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User | undefined;
    creatorUser: User | undefined;
    lastModifierUser: User | undefined;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    readonly fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number | undefined;
    isLockoutEnabled: boolean | undefined;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean | undefined;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean | undefined;
    isActive: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.signInToken = data["signInToken"];
            this.needToChangeThePassword = data["needToChangeThePassword"];
            this.signInTokenExpireTimeUtc = data["signInTokenExpireTimeUtc"] ? moment(data["signInTokenExpireTimeUtc"].toString()) : <any>undefined;
            this.name = data["name"];
            this.profilePictureId = data["profilePictureId"];
            this.surname = data["surname"];
            this.normalizedUserName = data["normalizedUserName"];
            this.normalizedEmailAddress = data["normalizedEmailAddress"];
            this.concurrencyStamp = data["concurrencyStamp"];
            if (data["tokens"] && data["tokens"].constructor === Array) {
                this.tokens = [] as any;
                for (let item of data["tokens"])
                    this.tokens.push(UserToken.fromJS(item));
            }
            this.deleterUser = data["deleterUser"] ? User.fromJS(data["deleterUser"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = data["lastModifierUser"] ? User.fromJS(data["lastModifierUser"]) : <any>undefined;
            this.authenticationSource = data["authenticationSource"];
            this.userName = data["userName"];
            this.tenantId = data["tenantId"];
            this.emailAddress = data["emailAddress"];
            (<any>this).fullName = data["fullName"];
            this.password = data["password"];
            this.emailConfirmationCode = data["emailConfirmationCode"];
            this.passwordResetCode = data["passwordResetCode"];
            this.lockoutEndDateUtc = data["lockoutEndDateUtc"] ? moment(data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.accessFailedCount = data["accessFailedCount"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.securityStamp = data["securityStamp"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            if (data["logins"] && data["logins"].constructor === Array) {
                this.logins = [] as any;
                for (let item of data["logins"])
                    this.logins.push(UserLogin.fromJS(item));
            }
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles.push(UserRole.fromJS(item));
            }
            if (data["claims"] && data["claims"].constructor === Array) {
                this.claims = [] as any;
                for (let item of data["claims"])
                    this.claims.push(UserClaim.fromJS(item));
            }
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions.push(UserPermissionSetting.fromJS(item));
            }
            if (data["settings"] && data["settings"].constructor === Array) {
                this.settings = [] as any;
                for (let item of data["settings"])
                    this.settings.push(Setting.fromJS(item));
            }
            this.isEmailConfirmed = data["isEmailConfirmed"];
            this.isActive = data["isActive"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["needToChangeThePassword"] = this.needToChangeThePassword;
        data["signInTokenExpireTimeUtc"] = this.signInTokenExpireTimeUtc ? this.signInTokenExpireTimeUtc.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["profilePictureId"] = this.profilePictureId;
        data["surname"] = this.surname;
        data["normalizedUserName"] = this.normalizedUserName;
        data["normalizedEmailAddress"] = this.normalizedEmailAddress;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (this.tokens && this.tokens.constructor === Array) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["authenticationSource"] = this.authenticationSource;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["emailAddress"] = this.emailAddress;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["passwordResetCode"] = this.passwordResetCode;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["accessFailedCount"] = this.accessFailedCount;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["securityStamp"] = this.securityStamp;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        if (this.logins && this.logins.constructor === Array) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (this.claims && this.claims.constructor === Array) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.settings && this.settings.constructor === Array) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    signInToken: string | undefined;
    needToChangeThePassword: boolean | undefined;
    signInTokenExpireTimeUtc: moment.Moment | undefined;
    name: string;
    profilePictureId: string | undefined;
    surname: string;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User | undefined;
    creatorUser: User | undefined;
    lastModifierUser: User | undefined;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number | undefined;
    isLockoutEnabled: boolean | undefined;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean | undefined;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean | undefined;
    isActive: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Branch implements IBranch {
    parentId: string | undefined;
    parent: Branch | undefined;
    branchCode: string;
    branchName: string;
    sort: number | undefined;
    level: number | undefined;
    isEnabled: boolean | undefined;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IBranch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? Branch.fromJS(data["parent"]) : <any>undefined;
            this.branchCode = data["branchCode"];
            this.branchName = data["branchName"];
            this.sort = data["sort"];
            this.level = data["level"];
            this.isEnabled = data["isEnabled"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Branch {
        data = typeof data === 'object' ? data : {};
        let result = new Branch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["sort"] = this.sort;
        data["level"] = this.level;
        data["isEnabled"] = this.isEnabled;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Branch {
        const json = this.toJSON();
        let result = new Branch();
        result.init(json);
        return result;
    }
}

export interface IBranch {
    parentId: string | undefined;
    parent: Branch | undefined;
    branchCode: string;
    branchName: string;
    sort: number | undefined;
    level: number | undefined;
    isEnabled: boolean | undefined;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export enum ScheduleStatusEnum {
    WaitCheck = <any>"WaitCheck", 
    BeginCheck = <any>"BeginCheck", 
    ScheduleRunning = <any>"ScheduleRunning", 
    Ending = <any>"Ending", 
}

export enum ScheduleEnum {
    ScheduleNormal = <any>"ScheduleNormal", 
    ScheduleStopSale = <any>"ScheduleStopSale", 
    ScheduleNotSale = <any>"ScheduleNotSale", 
}

export class Wharf implements IWharf {
    branchId: string | undefined;
    wharfName: string;
    wharfNo: string;
    wharfLeader: string;
    leaderMobile: number;
    wharfPosition: string;
    isEenable: boolean;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IWharf) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.wharfName = data["wharfName"];
            this.wharfNo = data["wharfNo"];
            this.wharfLeader = data["wharfLeader"];
            this.leaderMobile = data["leaderMobile"];
            this.wharfPosition = data["wharfPosition"];
            this.isEenable = data["isEenable"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Wharf {
        data = typeof data === 'object' ? data : {};
        let result = new Wharf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["wharfName"] = this.wharfName;
        data["wharfNo"] = this.wharfNo;
        data["wharfLeader"] = this.wharfLeader;
        data["leaderMobile"] = this.leaderMobile;
        data["wharfPosition"] = this.wharfPosition;
        data["isEenable"] = this.isEenable;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Wharf {
        const json = this.toJSON();
        let result = new Wharf();
        result.init(json);
        return result;
    }
}

export interface IWharf {
    branchId: string | undefined;
    wharfName: string;
    wharfNo: string;
    wharfLeader: string;
    leaderMobile: number;
    wharfPosition: string;
    isEenable: boolean;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class UserToken implements IUserToken {
    tenantId: number | undefined;
    userId: number | undefined;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: IUserToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.loginProvider = data["loginProvider"];
            this.name = data["name"];
            this.value = data["value"];
            this.expireDate = data["expireDate"] ? moment(data["expireDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["name"] = this.name;
        data["value"] = this.value;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserToken {
        const json = this.toJSON();
        let result = new UserToken();
        result.init(json);
        return result;
    }
}

export interface IUserToken {
    tenantId: number | undefined;
    userId: number | undefined;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
    id: number | undefined;
}

export class UserLogin implements IUserLogin {
    tenantId: number | undefined;
    userId: number | undefined;
    loginProvider: string;
    providerKey: string;
    id: number | undefined;

    constructor(data?: IUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.loginProvider = data["loginProvider"];
            this.providerKey = data["providerKey"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLogin {
        const json = this.toJSON();
        let result = new UserLogin();
        result.init(json);
        return result;
    }
}

export interface IUserLogin {
    tenantId: number | undefined;
    userId: number | undefined;
    loginProvider: string;
    providerKey: string;
    id: number | undefined;
}

export class UserRole implements IUserRole {
    tenantId: number | undefined;
    userId: number | undefined;
    roleId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.roleId = data["roleId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserRole {
        const json = this.toJSON();
        let result = new UserRole();
        result.init(json);
        return result;
    }
}

export interface IUserRole {
    tenantId: number | undefined;
    userId: number | undefined;
    roleId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class UserClaim implements IUserClaim {
    tenantId: number | undefined;
    userId: number | undefined;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.claimType = data["claimType"];
            this.claimValue = data["claimValue"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserClaim {
        const json = this.toJSON();
        let result = new UserClaim();
        result.init(json);
        return result;
    }
}

export interface IUserClaim {
    tenantId: number | undefined;
    userId: number | undefined;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class UserPermissionSetting implements IUserPermissionSetting {
    userId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IUserPermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.isGranted = data["isGranted"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserPermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserPermissionSetting {
        const json = this.toJSON();
        let result = new UserPermissionSetting();
        result.init(json);
        return result;
    }
}

export interface IUserPermissionSetting {
    userId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Setting implements ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.name = data["name"];
            this.value = data["value"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["value"] = this.value;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Setting {
        const json = this.toJSON();
        let result = new Setting();
        result.init(json);
        return result;
    }
}

export interface ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class CheckResult implements ICheckResult {
    status: number | undefined;
    msg: string | undefined;
    count: number | undefined;
    audio: string | undefined;
    show_msg: string | undefined;

    constructor(data?: ICheckResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.msg = data["msg"];
            this.count = data["count"];
            this.audio = data["audio"];
            this.show_msg = data["show_msg"];
        }
    }

    static fromJS(data: any): CheckResult {
        data = typeof data === 'object' ? data : {};
        let result = new CheckResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["count"] = this.count;
        data["audio"] = this.audio;
        data["show_msg"] = this.show_msg;
        return data; 
    }

    clone(): CheckResult {
        const json = this.toJSON();
        let result = new CheckResult();
        result.init(json);
        return result;
    }
}

export interface ICheckResult {
    status: number | undefined;
    msg: string | undefined;
    count: number | undefined;
    audio: string | undefined;
    show_msg: string | undefined;
}

export class QueryData implements IQueryData {
    field: string | undefined;
    method: string | undefined;
    value: string | undefined;
    logic: string | undefined;

    constructor(data?: IQueryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["field"];
            this.method = data["method"];
            this.value = data["value"];
            this.logic = data["logic"];
        }
    }

    static fromJS(data: any): QueryData {
        data = typeof data === 'object' ? data : {};
        let result = new QueryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["method"] = this.method;
        data["value"] = this.value;
        data["logic"] = this.logic;
        return data; 
    }

    clone(): QueryData {
        const json = this.toJSON();
        let result = new QueryData();
        result.init(json);
        return result;
    }
}

export interface IQueryData {
    field: string | undefined;
    method: string | undefined;
    value: string | undefined;
    logic: string | undefined;
}

export class PagedResultDtoOfGateHistoryResultDto implements IPagedResultDtoOfGateHistoryResultDto {
    totalCount: number | undefined;
    items: GateHistoryResultDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGateHistoryResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(GateHistoryResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGateHistoryResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGateHistoryResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGateHistoryResultDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGateHistoryResultDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGateHistoryResultDto {
    totalCount: number | undefined;
    items: GateHistoryResultDto[] | undefined;
}

/** 过闸统计页面Dto */
export class GateHistoryResultDto implements IGateHistoryResultDto {
    /** 设备名称 */
    deviceName: string | undefined;
    /** 设备代码 */
    deviceId: string | undefined;
    /** 验票介质类型 */
    verifyTypeDatas: VerifyTypeDataItem[] | undefined;
    /** 合计 */
    total: number | undefined;

    constructor(data?: IGateHistoryResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deviceName = data["deviceName"];
            this.deviceId = data["deviceId"];
            if (data["verifyTypeDatas"] && data["verifyTypeDatas"].constructor === Array) {
                this.verifyTypeDatas = [] as any;
                for (let item of data["verifyTypeDatas"])
                    this.verifyTypeDatas.push(VerifyTypeDataItem.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): GateHistoryResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GateHistoryResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceName"] = this.deviceName;
        data["deviceId"] = this.deviceId;
        if (this.verifyTypeDatas && this.verifyTypeDatas.constructor === Array) {
            data["verifyTypeDatas"] = [];
            for (let item of this.verifyTypeDatas)
                data["verifyTypeDatas"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }

    clone(): GateHistoryResultDto {
        const json = this.toJSON();
        let result = new GateHistoryResultDto();
        result.init(json);
        return result;
    }
}

/** 过闸统计页面Dto */
export interface IGateHistoryResultDto {
    /** 设备名称 */
    deviceName: string | undefined;
    /** 设备代码 */
    deviceId: string | undefined;
    /** 验票介质类型 */
    verifyTypeDatas: VerifyTypeDataItem[] | undefined;
    /** 合计 */
    total: number | undefined;
}

export class VerifyTypeDataItem implements IVerifyTypeDataItem {
    /** 类型名称 */
    typeName: string | undefined;
    /** 值 */
    value: number | undefined;

    constructor(data?: IVerifyTypeDataItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeName = data["typeName"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): VerifyTypeDataItem {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyTypeDataItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName;
        data["value"] = this.value;
        return data; 
    }

    clone(): VerifyTypeDataItem {
        const json = this.toJSON();
        let result = new VerifyTypeDataItem();
        result.init(json);
        return result;
    }
}

export interface IVerifyTypeDataItem {
    /** 类型名称 */
    typeName: string | undefined;
    /** 值 */
    value: number | undefined;
}

/** 过闸记录的查询条件 */
export class GateRecordFilters implements IGateRecordFilters {
    /** 设备类型 */
    deviceTypes: DeviceTypeEnum[] | undefined;
    /** 所有设备列表 */
    devices: Device[] | undefined;
    /** 票型 */
    ticketTypes: TicketTypeEnum[] | undefined;
    /** 所有游船 */
    boats: Boat[] | undefined;
    /** 所有操作员 */
    operators: User[] | undefined;
    /** 检票状态 */
    checkStatuses: CheckStatusEnum[] | undefined;

    constructor(data?: IGateRecordFilters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["deviceTypes"] && data["deviceTypes"].constructor === Array) {
                this.deviceTypes = [] as any;
                for (let item of data["deviceTypes"])
                    this.deviceTypes.push(item);
            }
            if (data["devices"] && data["devices"].constructor === Array) {
                this.devices = [] as any;
                for (let item of data["devices"])
                    this.devices.push(Device.fromJS(item));
            }
            if (data["ticketTypes"] && data["ticketTypes"].constructor === Array) {
                this.ticketTypes = [] as any;
                for (let item of data["ticketTypes"])
                    this.ticketTypes.push(item);
            }
            if (data["boats"] && data["boats"].constructor === Array) {
                this.boats = [] as any;
                for (let item of data["boats"])
                    this.boats.push(Boat.fromJS(item));
            }
            if (data["operators"] && data["operators"].constructor === Array) {
                this.operators = [] as any;
                for (let item of data["operators"])
                    this.operators.push(User.fromJS(item));
            }
            if (data["checkStatuses"] && data["checkStatuses"].constructor === Array) {
                this.checkStatuses = [] as any;
                for (let item of data["checkStatuses"])
                    this.checkStatuses.push(item);
            }
        }
    }

    static fromJS(data: any): GateRecordFilters {
        data = typeof data === 'object' ? data : {};
        let result = new GateRecordFilters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.deviceTypes && this.deviceTypes.constructor === Array) {
            data["deviceTypes"] = [];
            for (let item of this.deviceTypes)
                data["deviceTypes"].push(item);
        }
        if (this.devices && this.devices.constructor === Array) {
            data["devices"] = [];
            for (let item of this.devices)
                data["devices"].push(item.toJSON());
        }
        if (this.ticketTypes && this.ticketTypes.constructor === Array) {
            data["ticketTypes"] = [];
            for (let item of this.ticketTypes)
                data["ticketTypes"].push(item);
        }
        if (this.boats && this.boats.constructor === Array) {
            data["boats"] = [];
            for (let item of this.boats)
                data["boats"].push(item.toJSON());
        }
        if (this.operators && this.operators.constructor === Array) {
            data["operators"] = [];
            for (let item of this.operators)
                data["operators"].push(item.toJSON());
        }
        if (this.checkStatuses && this.checkStatuses.constructor === Array) {
            data["checkStatuses"] = [];
            for (let item of this.checkStatuses)
                data["checkStatuses"].push(item);
        }
        return data; 
    }

    clone(): GateRecordFilters {
        const json = this.toJSON();
        let result = new GateRecordFilters();
        result.init(json);
        return result;
    }
}

/** 过闸记录的查询条件 */
export interface IGateRecordFilters {
    /** 设备类型 */
    deviceTypes: DeviceTypeEnum[] | undefined;
    /** 所有设备列表 */
    devices: Device[] | undefined;
    /** 票型 */
    ticketTypes: TicketTypeEnum[] | undefined;
    /** 所有游船 */
    boats: Boat[] | undefined;
    /** 所有操作员 */
    operators: User[] | undefined;
    /** 检票状态 */
    checkStatuses: CheckStatusEnum[] | undefined;
}

export enum DeviceTypeEnum {
    TicketMachine = <any>"TicketMachine", 
    GateMachine = <any>"SelfhelpMachine", 
    FaceMachine = <any>"GateMachine", 
    SelfhelpMachine = <any>"HandMachine", 
    HandMachine = <any>"FaceMachine", 
}

export class Device implements IDevice {
    branchId: string | undefined;
    ticketStationId: string | undefined;
    deviceCode: string;
    deviceName: string;
    ipAddress: string | undefined;
    port: string | undefined;
    deviceType: DeviceTypeEnum;
    secretKey: string | undefined;
    deviceStatus: DeviceStatusEnum;
    isEnabled: boolean;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IDevice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketStationId = data["ticketStationId"];
            this.deviceCode = data["deviceCode"];
            this.deviceName = data["deviceName"];
            this.ipAddress = data["ipAddress"];
            this.port = data["port"];
            this.deviceType = data["deviceType"];
            this.secretKey = data["secretKey"];
            this.deviceStatus = data["deviceStatus"];
            this.isEnabled = data["isEnabled"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Device {
        data = typeof data === 'object' ? data : {};
        let result = new Device();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketStationId"] = this.ticketStationId;
        data["deviceCode"] = this.deviceCode;
        data["deviceName"] = this.deviceName;
        data["ipAddress"] = this.ipAddress;
        data["port"] = this.port;
        data["deviceType"] = this.deviceType;
        data["secretKey"] = this.secretKey;
        data["deviceStatus"] = this.deviceStatus;
        data["isEnabled"] = this.isEnabled;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Device {
        const json = this.toJSON();
        let result = new Device();
        result.init(json);
        return result;
    }
}

export interface IDevice {
    branchId: string | undefined;
    ticketStationId: string | undefined;
    deviceCode: string;
    deviceName: string;
    ipAddress: string | undefined;
    port: string | undefined;
    deviceType: DeviceTypeEnum;
    secretKey: string | undefined;
    deviceStatus: DeviceStatusEnum;
    isEnabled: boolean;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export enum TicketTypeEnum {
    Card = <any>"Card", 
    Paper = <any>"Paper", 
}

export enum CheckStatusEnum {
    CheckSuccess = <any>"CheckSuccess", 
    CheckFalse = <any>"CheckFalse", 
}

export enum DeviceStatusEnum {
    Not = <any>"Not", 
    Using = <any>"Using", 
    Closing = <any>"Closing", 
}

export class StatsPagedResultDtoOfGateRecordResultDto implements IStatsPagedResultDtoOfGateRecordResultDto {
    total: GateRecordResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: GateRecordResultDto[] | undefined;

    constructor(data?: IStatsPagedResultDtoOfGateRecordResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"] ? GateRecordResultDto.fromJS(data["total"]) : <any>undefined;
            if (data["filters"]) {
                this.filters = {} as any;
                for (let key in data["filters"]) {
                    if (data["filters"].hasOwnProperty(key))
                        this.filters[key] = data["filters"][key] !== undefined ? data["filters"][key] : [];
                }
            }
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(GateRecordResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatsPagedResultDtoOfGateRecordResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatsPagedResultDtoOfGateRecordResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total ? this.total.toJSON() : <any>undefined;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    data["filters"][key] = this.filters[key];
            }
        }
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StatsPagedResultDtoOfGateRecordResultDto {
        const json = this.toJSON();
        let result = new StatsPagedResultDtoOfGateRecordResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatsPagedResultDtoOfGateRecordResultDto {
    total: GateRecordResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: GateRecordResultDto[] | undefined;
}

export class GateRecordResultDto implements IGateRecordResultDto {
    user: User | undefined;
    deviceName: string | undefined;
    deviceId: string | undefined;
    returnState: ReturnStateEnum | undefined;
    ticketName: string | undefined;
    ticketNo: string | undefined;
    visitValue: string | undefined;
    statusCode: CheckStatusEnum | undefined;
    statusText: string | undefined;
    checkDate: moment.Moment | undefined;
    scheduleCode: string | undefined;
    boatName: string | undefined;

    constructor(data?: IGateRecordResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            this.deviceName = data["deviceName"];
            this.deviceId = data["deviceId"];
            this.returnState = data["returnState"];
            this.ticketName = data["ticketName"];
            this.ticketNo = data["ticketNo"];
            this.visitValue = data["visitValue"];
            this.statusCode = data["statusCode"];
            this.statusText = data["statusText"];
            this.checkDate = data["checkDate"] ? moment(data["checkDate"].toString()) : <any>undefined;
            this.scheduleCode = data["scheduleCode"];
            this.boatName = data["boatName"];
        }
    }

    static fromJS(data: any): GateRecordResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GateRecordResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["deviceName"] = this.deviceName;
        data["deviceId"] = this.deviceId;
        data["returnState"] = this.returnState;
        data["ticketName"] = this.ticketName;
        data["ticketNo"] = this.ticketNo;
        data["visitValue"] = this.visitValue;
        data["statusCode"] = this.statusCode;
        data["statusText"] = this.statusText;
        data["checkDate"] = this.checkDate ? this.checkDate.toISOString() : <any>undefined;
        data["scheduleCode"] = this.scheduleCode;
        data["boatName"] = this.boatName;
        return data; 
    }

    clone(): GateRecordResultDto {
        const json = this.toJSON();
        let result = new GateRecordResultDto();
        result.init(json);
        return result;
    }
}

export interface IGateRecordResultDto {
    user: User | undefined;
    deviceName: string | undefined;
    deviceId: string | undefined;
    returnState: ReturnStateEnum | undefined;
    ticketName: string | undefined;
    ticketNo: string | undefined;
    visitValue: string | undefined;
    statusCode: CheckStatusEnum | undefined;
    statusText: string | undefined;
    checkDate: moment.Moment | undefined;
    scheduleCode: string | undefined;
    boatName: string | undefined;
}

export enum ReturnStateEnum {
    Success = <any>"Success", 
    False = <any>"False", 
}

export class ClientVersionListDto implements IClientVersionListDto {
    /** AppName */
    appName: string;
    /** VersionName */
    versionName: string;
    /** VersionCode */
    versionCode: string;
    /** VersionDesc */
    versionDesc: string;
    /** DeviceType */
    deviceType: DeviceTypeEnum;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IClientVersionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.appName = data["appName"];
            this.versionName = data["versionName"];
            this.versionCode = data["versionCode"];
            this.versionDesc = data["versionDesc"];
            this.deviceType = data["deviceType"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ClientVersionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientVersionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appName"] = this.appName;
        data["versionName"] = this.versionName;
        data["versionCode"] = this.versionCode;
        data["versionDesc"] = this.versionDesc;
        data["deviceType"] = this.deviceType;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ClientVersionListDto {
        const json = this.toJSON();
        let result = new ClientVersionListDto();
        result.init(json);
        return result;
    }
}

export interface IClientVersionListDto {
    /** AppName */
    appName: string;
    /** VersionName */
    versionName: string;
    /** VersionCode */
    versionCode: string;
    /** VersionDesc */
    versionDesc: string;
    /** DeviceType */
    deviceType: DeviceTypeEnum;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

/** 上传图片结果Dto */
export class PictureResultDto implements IPictureResultDto {
    /** 图片地址 */
    uri: string | undefined;

    constructor(data?: IPictureResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.uri = data["uri"];
        }
    }

    static fromJS(data: any): PictureResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PictureResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uri"] = this.uri;
        return data; 
    }

    clone(): PictureResultDto {
        const json = this.toJSON();
        let result = new PictureResultDto();
        result.init(json);
        return result;
    }
}

/** 上传图片结果Dto */
export interface IPictureResultDto {
    /** 图片地址 */
    uri: string | undefined;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId: number | undefined;
    confirmationCode: string | undefined;
    /** Encrypted values for {TenantId}, {UserId} and {ConfirmationCode} */
    c: string | undefined;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.confirmationCode = data["confirmationCode"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        data["c"] = this.c;
        return data; 
    }

    clone(): ActivateEmailInput {
        const json = this.toJSON();
        let result = new ActivateEmailInput();
        result.init(json);
        return result;
    }
}

export interface IActivateEmailInput {
    userId: number | undefined;
    confirmationCode: string | undefined;
    /** Encrypted values for {TenantId}, {UserId} and {ConfirmationCode} */
    c: string | undefined;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.impersonationToken = data["impersonationToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): ImpersonateOutput {
        const json = this.toJSON();
        let result = new ImpersonateOutput();
        result.init(json);
        return result;
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId: number | undefined;
    userId: number | undefined;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): ImpersonateInput {
        const json = this.toJSON();
        let result = new ImpersonateInput();
        result.init(json);
        return result;
    }
}

export interface IImpersonateInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState | undefined;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState | undefined;
    tenantId: number | undefined;
}

export enum TenantAvailabilityState {
    Available = <any>"Available", 
    InActive = <any>"InActive", 
    NotFound = <any>"NotFound", 
}

export class RegisterInput implements IRegisterInput {
    userName: string;
    emailAddress: string;
    password: string;
    /** 验证码 */
    verificationCode: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.verificationCode = data["verificationCode"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["verificationCode"] = this.verificationCode;
        return data; 
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    userName: string;
    emailAddress: string;
    password: string;
    /** 验证码 */
    verificationCode: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean | undefined;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean | undefined;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId: number | undefined;
    resetCode: string;
    password: string;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.resetCode = data["resetCode"];
            this.password = data["password"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data; 
    }

    clone(): ResetPasswordInput {
        const json = this.toJSON();
        let result = new ResetPasswordInput();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordInput {
    userId: number | undefined;
    resetCode: string;
    password: string;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin: boolean | undefined;
    userName: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data; 
    }

    clone(): ResetPasswordOutput {
        const json = this.toJSON();
        let result = new ResetPasswordOutput();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean | undefined;
    userName: string | undefined;
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data; 
    }

    clone(): ResolveTenantIdInput {
        const json = this.toJSON();
        let result = new ResolveTenantIdInput();
        result.init(json);
        return result;
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress: string;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone(): SendEmailActivationLinkInput {
        const json = this.toJSON();
        let result = new SendEmailActivationLinkInput();
        result.init(json);
        return result;
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress: string;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone(): SendPasswordResetCodeInput {
        const json = this.toJSON();
        let result = new SendPasswordResetCodeInput();
        result.init(json);
        return result;
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number | undefined;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetTenantId = data["targetTenantId"];
            this.targetUserId = data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data; 
    }

    clone(): SwitchToLinkedAccountInput {
        const json = this.toJSON();
        let result = new SwitchToLinkedAccountInput();
        result.init(json);
        return result;
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number | undefined;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.switchAccountToken = data["switchAccountToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): SwitchToLinkedAccountOutput {
        const json = this.toJSON();
        let result = new SwitchToLinkedAccountOutput();
        result.init(json);
        return result;
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export class CreateOrUpdateAccountDetailInput implements ICreateOrUpdateAccountDetailInput {
    accountDetail: AccountDetailEditDto;

    constructor(data?: ICreateOrUpdateAccountDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.accountDetail = new AccountDetailEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.accountDetail = data["accountDetail"] ? AccountDetailEditDto.fromJS(data["accountDetail"]) : new AccountDetailEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateAccountDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateAccountDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountDetail"] = this.accountDetail ? this.accountDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateAccountDetailInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateAccountDetailInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateAccountDetailInput {
    accountDetail: AccountDetailEditDto;
}

export class AccountDetailEditDto implements IAccountDetailEditDto {
    /** Id */
    id: string | undefined;
    /** AccountId */
    accountId: string;
    /** TicketId */
    activityDetailId: string;

    constructor(data?: IAccountDetailEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.accountId = data["accountId"];
            this.activityDetailId = data["activityDetailId"];
        }
    }

    static fromJS(data: any): AccountDetailEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDetailEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accountId"] = this.accountId;
        data["activityDetailId"] = this.activityDetailId;
        return data; 
    }

    clone(): AccountDetailEditDto {
        const json = this.toJSON();
        let result = new AccountDetailEditDto();
        result.init(json);
        return result;
    }
}

export interface IAccountDetailEditDto {
    /** Id */
    id: string | undefined;
    /** AccountId */
    accountId: string;
    /** TicketId */
    activityDetailId: string;
}

export class AccountDetailListDto implements IAccountDetailListDto {
    /** BranchId */
    branchId: string | undefined;
    /** AccountId */
    accountId: string;
    /** Account */
    account: Account | undefined;
    /** TicketId */
    activityDetailId: string;
    /** Ticket */
    activityDetail: ActivityDetail | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IAccountDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.accountId = data["accountId"];
            this.account = data["account"] ? Account.fromJS(data["account"]) : <any>undefined;
            this.activityDetailId = data["activityDetailId"];
            this.activityDetail = data["activityDetail"] ? ActivityDetail.fromJS(data["activityDetail"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AccountDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["accountId"] = this.accountId;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["activityDetailId"] = this.activityDetailId;
        data["activityDetail"] = this.activityDetail ? this.activityDetail.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AccountDetailListDto {
        const json = this.toJSON();
        let result = new AccountDetailListDto();
        result.init(json);
        return result;
    }
}

export interface IAccountDetailListDto {
    /** BranchId */
    branchId: string | undefined;
    /** AccountId */
    accountId: string;
    /** Account */
    account: Account | undefined;
    /** TicketId */
    activityDetailId: string;
    /** Ticket */
    activityDetail: ActivityDetail | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class Account implements IAccount {
    branchId: string | undefined;
    accountNo: string;
    accountDate: moment.Moment;
    quantity: number;
    amount: number;
    accountStatus: AccountStatusEnum | undefined;
    collectiorId: number | undefined;
    collectior: User | undefined;
    collectionTime: moment.Moment | undefined;
    payMethodId: string | undefined;
    payMethod: PayMethod | undefined;
    remark: string | undefined;
    voucherNo: string | undefined;
    rAmount: number | undefined;
    totalAmount: number | undefined;
    rQuantity: number | undefined;
    totalQuantity: number | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.accountNo = data["accountNo"];
            this.accountDate = data["accountDate"] ? moment(data["accountDate"].toString()) : <any>undefined;
            this.quantity = data["quantity"];
            this.amount = data["amount"];
            this.accountStatus = data["accountStatus"];
            this.collectiorId = data["collectiorId"];
            this.collectior = data["collectior"] ? User.fromJS(data["collectior"]) : <any>undefined;
            this.collectionTime = data["collectionTime"] ? moment(data["collectionTime"].toString()) : <any>undefined;
            this.payMethodId = data["payMethodId"];
            this.payMethod = data["payMethod"] ? PayMethod.fromJS(data["payMethod"]) : <any>undefined;
            this.remark = data["remark"];
            this.voucherNo = data["voucherNo"];
            this.rAmount = data["rAmount"];
            this.totalAmount = data["totalAmount"];
            this.rQuantity = data["rQuantity"];
            this.totalQuantity = data["totalQuantity"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Account {
        data = typeof data === 'object' ? data : {};
        let result = new Account();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["accountNo"] = this.accountNo;
        data["accountDate"] = this.accountDate ? this.accountDate.toISOString() : <any>undefined;
        data["quantity"] = this.quantity;
        data["amount"] = this.amount;
        data["accountStatus"] = this.accountStatus;
        data["collectiorId"] = this.collectiorId;
        data["collectior"] = this.collectior ? this.collectior.toJSON() : <any>undefined;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["payMethodId"] = this.payMethodId;
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        data["remark"] = this.remark;
        data["voucherNo"] = this.voucherNo;
        data["rAmount"] = this.rAmount;
        data["totalAmount"] = this.totalAmount;
        data["rQuantity"] = this.rQuantity;
        data["totalQuantity"] = this.totalQuantity;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Account {
        const json = this.toJSON();
        let result = new Account();
        result.init(json);
        return result;
    }
}

export interface IAccount {
    branchId: string | undefined;
    accountNo: string;
    accountDate: moment.Moment;
    quantity: number;
    amount: number;
    accountStatus: AccountStatusEnum | undefined;
    collectiorId: number | undefined;
    collectior: User | undefined;
    collectionTime: moment.Moment | undefined;
    payMethodId: string | undefined;
    payMethod: PayMethod | undefined;
    remark: string | undefined;
    voucherNo: string | undefined;
    rAmount: number | undefined;
    totalAmount: number | undefined;
    rQuantity: number | undefined;
    totalQuantity: number | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ActivityDetail implements IActivityDetail {
    branchId: string | undefined;
    activityId: string | undefined;
    activity: Activity | undefined;
    ticketPriceId: string | undefined;
    ticketPrice: TicketPrice | undefined;
    quantity: number | undefined;
    unitPrice: number | undefined;
    discount: number | undefined;
    salePrice: number | undefined;
    totalAmount: number | undefined;
    remark: string | undefined;
    accountId: string | undefined;
    accountDetailId: string | undefined;
    orgDetailId: string | undefined;
    customer: Customer | undefined;
    scheduleId: string | undefined;
    schedule: Schedule | undefined;
    warePosition: WareHousePosition | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IActivityDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.activityId = data["activityId"];
            this.activity = data["activity"] ? Activity.fromJS(data["activity"]) : <any>undefined;
            this.ticketPriceId = data["ticketPriceId"];
            this.ticketPrice = data["ticketPrice"] ? TicketPrice.fromJS(data["ticketPrice"]) : <any>undefined;
            this.quantity = data["quantity"];
            this.unitPrice = data["unitPrice"];
            this.discount = data["discount"];
            this.salePrice = data["salePrice"];
            this.totalAmount = data["totalAmount"];
            this.remark = data["remark"];
            this.accountId = data["accountId"];
            this.accountDetailId = data["accountDetailId"];
            this.orgDetailId = data["orgDetailId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.scheduleId = data["scheduleId"];
            this.schedule = data["schedule"] ? Schedule.fromJS(data["schedule"]) : <any>undefined;
            this.warePosition = data["warePosition"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["ticketPriceId"] = this.ticketPriceId;
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["discount"] = this.discount;
        data["salePrice"] = this.salePrice;
        data["totalAmount"] = this.totalAmount;
        data["remark"] = this.remark;
        data["accountId"] = this.accountId;
        data["accountDetailId"] = this.accountDetailId;
        data["orgDetailId"] = this.orgDetailId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["scheduleId"] = this.scheduleId;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["warePosition"] = this.warePosition;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ActivityDetail {
        const json = this.toJSON();
        let result = new ActivityDetail();
        result.init(json);
        return result;
    }
}

export interface IActivityDetail {
    branchId: string | undefined;
    activityId: string | undefined;
    activity: Activity | undefined;
    ticketPriceId: string | undefined;
    ticketPrice: TicketPrice | undefined;
    quantity: number | undefined;
    unitPrice: number | undefined;
    discount: number | undefined;
    salePrice: number | undefined;
    totalAmount: number | undefined;
    remark: string | undefined;
    accountId: string | undefined;
    accountDetailId: string | undefined;
    orgDetailId: string | undefined;
    customer: Customer | undefined;
    scheduleId: string | undefined;
    schedule: Schedule | undefined;
    warePosition: WareHousePosition | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export enum AccountStatusEnum {
    NotAccount = <any>"IsAccount", 
    IsAccount = <any>"NotAccount", 
}

export class PayMethod implements IPayMethod {
    payName: string;
    payCode: string;
    sort: number | undefined;
    isEnabled: boolean | undefined;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IPayMethod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.payName = data["payName"];
            this.payCode = data["payCode"];
            this.sort = data["sort"];
            this.isEnabled = data["isEnabled"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PayMethod {
        data = typeof data === 'object' ? data : {};
        let result = new PayMethod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["payName"] = this.payName;
        data["payCode"] = this.payCode;
        data["sort"] = this.sort;
        data["isEnabled"] = this.isEnabled;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PayMethod {
        const json = this.toJSON();
        let result = new PayMethod();
        result.init(json);
        return result;
    }
}

export interface IPayMethod {
    payName: string;
    payCode: string;
    sort: number | undefined;
    isEnabled: boolean | undefined;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class Activity implements IActivity {
    branchId: string | undefined;
    activityNo: string | undefined;
    sourceId: string | undefined;
    source: Source | undefined;
    scheduleId: string | undefined;
    orgActivityId: string | undefined;
    activityDate: moment.Moment | undefined;
    playDate: moment.Moment | undefined;
    customerId: string | undefined;
    buyer: string | undefined;
    mobile: string | undefined;
    payMethodId: string | undefined;
    payMethod: PayMethod | undefined;
    voucherNo: string | undefined;
    payStatus: PayStatusEnum | undefined;
    activityType: ActivityTypeEnum | undefined;
    remark: string | undefined;
    isPrint: boolean | undefined;
    closed: boolean | undefined;
    totalQuantity: number | undefined;
    totalAmount: number | undefined;
    accountsId: string | undefined;
    account: Account | undefined;
    orderType: OrderTypeEnum | undefined;
    code: string | undefined;
    travelAgencyId: string | undefined;
    travelAgency: TravelAgency | undefined;
    activityDetails: ActivityDetail[] | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.activityNo = data["activityNo"];
            this.sourceId = data["sourceId"];
            this.source = data["source"] ? Source.fromJS(data["source"]) : <any>undefined;
            this.scheduleId = data["scheduleId"];
            this.orgActivityId = data["orgActivityId"];
            this.activityDate = data["activityDate"] ? moment(data["activityDate"].toString()) : <any>undefined;
            this.playDate = data["playDate"] ? moment(data["playDate"].toString()) : <any>undefined;
            this.customerId = data["customerId"];
            this.buyer = data["buyer"];
            this.mobile = data["mobile"];
            this.payMethodId = data["payMethodId"];
            this.payMethod = data["payMethod"] ? PayMethod.fromJS(data["payMethod"]) : <any>undefined;
            this.voucherNo = data["voucherNo"];
            this.payStatus = data["payStatus"];
            this.activityType = data["activityType"];
            this.remark = data["remark"];
            this.isPrint = data["isPrint"];
            this.closed = data["closed"];
            this.totalQuantity = data["totalQuantity"];
            this.totalAmount = data["totalAmount"];
            this.accountsId = data["accountsId"];
            this.account = data["account"] ? Account.fromJS(data["account"]) : <any>undefined;
            this.orderType = data["orderType"];
            this.code = data["code"];
            this.travelAgencyId = data["travelAgencyId"];
            this.travelAgency = data["travelAgency"] ? TravelAgency.fromJS(data["travelAgency"]) : <any>undefined;
            if (data["activityDetails"] && data["activityDetails"].constructor === Array) {
                this.activityDetails = [] as any;
                for (let item of data["activityDetails"])
                    this.activityDetails.push(ActivityDetail.fromJS(item));
            }
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Activity {
        data = typeof data === 'object' ? data : {};
        let result = new Activity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["activityNo"] = this.activityNo;
        data["sourceId"] = this.sourceId;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["scheduleId"] = this.scheduleId;
        data["orgActivityId"] = this.orgActivityId;
        data["activityDate"] = this.activityDate ? this.activityDate.toISOString() : <any>undefined;
        data["playDate"] = this.playDate ? this.playDate.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["buyer"] = this.buyer;
        data["mobile"] = this.mobile;
        data["payMethodId"] = this.payMethodId;
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        data["voucherNo"] = this.voucherNo;
        data["payStatus"] = this.payStatus;
        data["activityType"] = this.activityType;
        data["remark"] = this.remark;
        data["isPrint"] = this.isPrint;
        data["closed"] = this.closed;
        data["totalQuantity"] = this.totalQuantity;
        data["totalAmount"] = this.totalAmount;
        data["accountsId"] = this.accountsId;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["orderType"] = this.orderType;
        data["code"] = this.code;
        data["travelAgencyId"] = this.travelAgencyId;
        data["travelAgency"] = this.travelAgency ? this.travelAgency.toJSON() : <any>undefined;
        if (this.activityDetails && this.activityDetails.constructor === Array) {
            data["activityDetails"] = [];
            for (let item of this.activityDetails)
                data["activityDetails"].push(item.toJSON());
        }
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Activity {
        const json = this.toJSON();
        let result = new Activity();
        result.init(json);
        return result;
    }
}

export interface IActivity {
    branchId: string | undefined;
    activityNo: string | undefined;
    sourceId: string | undefined;
    source: Source | undefined;
    scheduleId: string | undefined;
    orgActivityId: string | undefined;
    activityDate: moment.Moment | undefined;
    playDate: moment.Moment | undefined;
    customerId: string | undefined;
    buyer: string | undefined;
    mobile: string | undefined;
    payMethodId: string | undefined;
    payMethod: PayMethod | undefined;
    voucherNo: string | undefined;
    payStatus: PayStatusEnum | undefined;
    activityType: ActivityTypeEnum | undefined;
    remark: string | undefined;
    isPrint: boolean | undefined;
    closed: boolean | undefined;
    totalQuantity: number | undefined;
    totalAmount: number | undefined;
    accountsId: string | undefined;
    account: Account | undefined;
    orderType: OrderTypeEnum | undefined;
    code: string | undefined;
    travelAgencyId: string | undefined;
    travelAgency: TravelAgency | undefined;
    activityDetails: ActivityDetail[] | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class TicketPrice implements ITicketPrice {
    branchId: string | undefined;
    ticketId: string | undefined;
    ticket: Ticket | undefined;
    price: number | undefined;
    discount: number;
    rDiscount: number;
    upperTime: moment.Moment | undefined;
    lowerTime: moment.Moment | undefined;
    position: PositionEnum | undefined;
    isEnabled: boolean | undefined;
    sort: number | undefined;
    ticketName: string | undefined;
    warePosition: WareHousePosition | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ITicketPrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.discount = 1;
            this.rDiscount = 1;
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketId = data["ticketId"];
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.price = data["price"];
            this.discount = data["discount"] !== undefined ? data["discount"] : 1;
            this.rDiscount = data["rDiscount"] !== undefined ? data["rDiscount"] : 1;
            this.upperTime = data["upperTime"] ? moment(data["upperTime"].toString()) : <any>undefined;
            this.lowerTime = data["lowerTime"] ? moment(data["lowerTime"].toString()) : <any>undefined;
            this.position = data["position"];
            this.isEnabled = data["isEnabled"];
            this.sort = data["sort"];
            this.ticketName = data["ticketName"];
            this.warePosition = data["warePosition"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketPrice {
        data = typeof data === 'object' ? data : {};
        let result = new TicketPrice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketId"] = this.ticketId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["price"] = this.price;
        data["discount"] = this.discount;
        data["rDiscount"] = this.rDiscount;
        data["upperTime"] = this.upperTime ? this.upperTime.toISOString() : <any>undefined;
        data["lowerTime"] = this.lowerTime ? this.lowerTime.toISOString() : <any>undefined;
        data["position"] = this.position;
        data["isEnabled"] = this.isEnabled;
        data["sort"] = this.sort;
        data["ticketName"] = this.ticketName;
        data["warePosition"] = this.warePosition;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketPrice {
        const json = this.toJSON();
        let result = new TicketPrice();
        result.init(json);
        return result;
    }
}

export interface ITicketPrice {
    branchId: string | undefined;
    ticketId: string | undefined;
    ticket: Ticket | undefined;
    price: number | undefined;
    discount: number;
    rDiscount: number;
    upperTime: moment.Moment | undefined;
    lowerTime: moment.Moment | undefined;
    position: PositionEnum | undefined;
    isEnabled: boolean | undefined;
    sort: number | undefined;
    ticketName: string | undefined;
    warePosition: WareHousePosition | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class Customer implements ICustomer {
    branchId: string | undefined;
    customerName: string;
    mobile: string;
    loginPwd: string | undefined;
    sex: SexEnum | undefined;
    country: string | undefined;
    province: string | undefined;
    city: string | undefined;
    county: string | undefined;
    certificatesNum: string;
    verifiableType: VerifiableTypeEnum;
    job: string | undefined;
    openID: string | undefined;
    photo: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ICustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.customerName = data["customerName"];
            this.mobile = data["mobile"];
            this.loginPwd = data["loginPwd"];
            this.sex = data["sex"];
            this.country = data["country"];
            this.province = data["province"];
            this.city = data["city"];
            this.county = data["county"];
            this.certificatesNum = data["certificatesNum"];
            this.verifiableType = data["verifiableType"];
            this.job = data["job"];
            this.openID = data["openID"];
            this.photo = data["photo"];
            this.dateOfBirth = data["dateOfBirth"] ? moment(data["dateOfBirth"].toString()) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Customer {
        data = typeof data === 'object' ? data : {};
        let result = new Customer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["customerName"] = this.customerName;
        data["mobile"] = this.mobile;
        data["loginPwd"] = this.loginPwd;
        data["sex"] = this.sex;
        data["country"] = this.country;
        data["province"] = this.province;
        data["city"] = this.city;
        data["county"] = this.county;
        data["certificatesNum"] = this.certificatesNum;
        data["verifiableType"] = this.verifiableType;
        data["job"] = this.job;
        data["openID"] = this.openID;
        data["photo"] = this.photo;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Customer {
        const json = this.toJSON();
        let result = new Customer();
        result.init(json);
        return result;
    }
}

export interface ICustomer {
    branchId: string | undefined;
    customerName: string;
    mobile: string;
    loginPwd: string | undefined;
    sex: SexEnum | undefined;
    country: string | undefined;
    province: string | undefined;
    city: string | undefined;
    county: string | undefined;
    certificatesNum: string;
    verifiableType: VerifiableTypeEnum;
    job: string | undefined;
    openID: string | undefined;
    photo: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export enum WareHousePosition {
    StandradPosition = <any>"StandradPosition", 
    VIPPosition = <any>"VIPPosition", 
    CompartmentPosotion = <any>"CompartmentPosotion", 
}

export class Source implements ISource {
    branchId: string | undefined;
    sourceName: string;
    sourceCode: string;
    discount: number | undefined;
    rDiscount: number | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ISource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.sourceName = data["sourceName"];
            this.sourceCode = data["sourceCode"];
            this.discount = data["discount"];
            this.rDiscount = data["rDiscount"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Source {
        data = typeof data === 'object' ? data : {};
        let result = new Source();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["sourceName"] = this.sourceName;
        data["sourceCode"] = this.sourceCode;
        data["discount"] = this.discount;
        data["rDiscount"] = this.rDiscount;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Source {
        const json = this.toJSON();
        let result = new Source();
        result.init(json);
        return result;
    }
}

export interface ISource {
    branchId: string | undefined;
    sourceName: string;
    sourceCode: string;
    discount: number | undefined;
    rDiscount: number | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export enum PayStatusEnum {
    NotPay = <any>"NotPay", 
    PayStatusPayment = <any>"PayStatusPayment", 
    PayStatusRefund = <any>"PayStatusRefund", 
    PayStatusClose = <any>"PayStatusClose", 
}

export enum ActivityTypeEnum {
    ActivityTypePayment = <any>"ActivityTypePayment", 
    ActivityTypeRefund = <any>"ActivityTypeRefund", 
}

export class TravelAgency implements ITravelAgency {
    branchId: string | undefined;
    travelName: string;
    mobile: string;
    contacts: string;
    isEnabled: boolean | undefined;
    discount: number | undefined;
    payMethod: PayMethodEnum;
    totalSum: number;
    prepaidAmount: number;
    alarmAmount: number;
    upperLimit: number | undefined;
    lowerlimit: number | undefined;
    passward: string | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ITravelAgency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.travelName = data["travelName"];
            this.mobile = data["mobile"];
            this.contacts = data["contacts"];
            this.isEnabled = data["isEnabled"];
            this.discount = data["discount"];
            this.payMethod = data["payMethod"];
            this.totalSum = data["totalSum"];
            this.prepaidAmount = data["prepaidAmount"];
            this.alarmAmount = data["alarmAmount"];
            this.upperLimit = data["upperLimit"];
            this.lowerlimit = data["lowerlimit"];
            this.passward = data["passward"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TravelAgency {
        data = typeof data === 'object' ? data : {};
        let result = new TravelAgency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["travelName"] = this.travelName;
        data["mobile"] = this.mobile;
        data["contacts"] = this.contacts;
        data["isEnabled"] = this.isEnabled;
        data["discount"] = this.discount;
        data["payMethod"] = this.payMethod;
        data["totalSum"] = this.totalSum;
        data["prepaidAmount"] = this.prepaidAmount;
        data["alarmAmount"] = this.alarmAmount;
        data["upperLimit"] = this.upperLimit;
        data["lowerlimit"] = this.lowerlimit;
        data["passward"] = this.passward;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TravelAgency {
        const json = this.toJSON();
        let result = new TravelAgency();
        result.init(json);
        return result;
    }
}

export interface ITravelAgency {
    branchId: string | undefined;
    travelName: string;
    mobile: string;
    contacts: string;
    isEnabled: boolean | undefined;
    discount: number | undefined;
    payMethod: PayMethodEnum;
    totalSum: number;
    prepaidAmount: number;
    alarmAmount: number;
    upperLimit: number | undefined;
    lowerlimit: number | undefined;
    passward: string | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class Ticket implements ITicket {
    branchId: string | undefined;
    ticketName: string;
    ticketCode: string | undefined;
    ticketMode: TicketModeEnum | undefined;
    ticketType: TicketTypeEnum | undefined;
    checkMethod: CheckMethodEnum | undefined;
    ticketClassify: TicketClassifyEnum | undefined;
    checkNum: number | undefined;
    effectiveLong: number | undefined;
    unitPrice: number | undefined;
    ticketLength: number | undefined;
    upperLimit: number | undefined;
    lowerLimit: number | undefined;
    audioName: string | undefined;
    auditStatus: AuditStatusEnum | undefined;
    isEnabled: boolean | undefined;
    sort: number | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ITicket) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketName = data["ticketName"];
            this.ticketCode = data["ticketCode"];
            this.ticketMode = data["ticketMode"];
            this.ticketType = data["ticketType"];
            this.checkMethod = data["checkMethod"];
            this.ticketClassify = data["ticketClassify"];
            this.checkNum = data["checkNum"];
            this.effectiveLong = data["effectiveLong"];
            this.unitPrice = data["unitPrice"];
            this.ticketLength = data["ticketLength"];
            this.upperLimit = data["upperLimit"];
            this.lowerLimit = data["lowerLimit"];
            this.audioName = data["audioName"];
            this.auditStatus = data["auditStatus"];
            this.isEnabled = data["isEnabled"];
            this.sort = data["sort"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Ticket {
        data = typeof data === 'object' ? data : {};
        let result = new Ticket();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketName"] = this.ticketName;
        data["ticketCode"] = this.ticketCode;
        data["ticketMode"] = this.ticketMode;
        data["ticketType"] = this.ticketType;
        data["checkMethod"] = this.checkMethod;
        data["ticketClassify"] = this.ticketClassify;
        data["checkNum"] = this.checkNum;
        data["effectiveLong"] = this.effectiveLong;
        data["unitPrice"] = this.unitPrice;
        data["ticketLength"] = this.ticketLength;
        data["upperLimit"] = this.upperLimit;
        data["lowerLimit"] = this.lowerLimit;
        data["audioName"] = this.audioName;
        data["auditStatus"] = this.auditStatus;
        data["isEnabled"] = this.isEnabled;
        data["sort"] = this.sort;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Ticket {
        const json = this.toJSON();
        let result = new Ticket();
        result.init(json);
        return result;
    }
}

export interface ITicket {
    branchId: string | undefined;
    ticketName: string;
    ticketCode: string | undefined;
    ticketMode: TicketModeEnum | undefined;
    ticketType: TicketTypeEnum | undefined;
    checkMethod: CheckMethodEnum | undefined;
    ticketClassify: TicketClassifyEnum | undefined;
    checkNum: number | undefined;
    effectiveLong: number | undefined;
    unitPrice: number | undefined;
    ticketLength: number | undefined;
    upperLimit: number | undefined;
    lowerLimit: number | undefined;
    audioName: string | undefined;
    auditStatus: AuditStatusEnum | undefined;
    isEnabled: boolean | undefined;
    sort: number | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export enum PositionEnum {
    Windows = <any>"windows", 
    Online = <any>"Online", 
}

export enum SexEnum {
    Unknown = <any>"Unknown", 
    Man = <any>"Man", 
    Woman = <any>"Woman", 
}

export enum VerifiableTypeEnum {
    IdentityCard = <any>"IdentityCard", 
    ICCard = <any>"ICCard", 
    QRCode = <any>"QRCode", 
    ReturnCard = <any>"ReturnCard", 
    TaiwanCard = <any>"TaiwanCard", 
}

export enum PayMethodEnum {
    PaySuccess = <any>"PaySuccess", 
    PayFalse = <any>"PayFalse", 
}

export enum TicketModeEnum {
    OnebyOne = <any>"OnebyOne", 
    OneByMore = <any>"OneByMore", 
}

export enum CheckMethodEnum {
    NumberCheck = <any>"NumberCheck", 
    TimeCheck = <any>"TimeCheck", 
    BalanceCheck = <any>"BalanceCheck", 
}

export enum TicketClassifyEnum {
    Adult = <any>"Adult", 
    Children = <any>"Children", 
    Old = <any>"Old", 
}

export class GetAccountDetailForEditOutput implements IGetAccountDetailForEditOutput {
    accountDetail: AccountDetailEditDto | undefined;

    constructor(data?: IGetAccountDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountDetail = data["accountDetail"] ? AccountDetailEditDto.fromJS(data["accountDetail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAccountDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountDetail"] = this.accountDetail ? this.accountDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetAccountDetailForEditOutput {
        const json = this.toJSON();
        let result = new GetAccountDetailForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAccountDetailForEditOutput {
    accountDetail: AccountDetailEditDto | undefined;
}

export class PagedResultDtoOfAccountDetailListDto implements IPagedResultDtoOfAccountDetailListDto {
    totalCount: number | undefined;
    items: AccountDetailListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAccountDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(AccountDetailListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAccountDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAccountDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfAccountDetailListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfAccountDetailListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfAccountDetailListDto {
    totalCount: number | undefined;
    items: AccountDetailListDto[] | undefined;
}

export class CreateOrUpdateActivityInput implements ICreateOrUpdateActivityInput {
    activity: ActivityEditDto;

    constructor(data?: ICreateOrUpdateActivityInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.activity = new ActivityEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.activity = data["activity"] ? ActivityEditDto.fromJS(data["activity"]) : new ActivityEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateActivityInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateActivityInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateActivityInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateActivityInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateActivityInput {
    activity: ActivityEditDto;
}

export class ActivityEditDto implements IActivityEditDto {
    /** Id */
    id: string | undefined;
    /** ActivityNo */
    activityNo: string | undefined;
    /** SourceId */
    sourceId: string | undefined;
    /** ScheduleId */
    scheduleId: string | undefined;
    /** OrgActivityId */
    orgActivityId: string | undefined;
    /** ActivityDate */
    activityDate: moment.Moment | undefined;
    /** PlayDate */
    playDate: moment.Moment | undefined;
    /** CustomerId */
    customerId: string | undefined;
    /** Buyer */
    buyer: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** PayMethodId */
    payMethodId: string | undefined;
    /** VoucherNo */
    voucherNo: string | undefined;
    /** PayStatus */
    payStatus: PayStatusEnum | undefined;
    /** ActivityType */
    activityType: ActivityTypeEnum | undefined;
    /** Remark */
    remark: string | undefined;
    /** IsPrint */
    isPrint: boolean | undefined;
    /** Closed */
    closed: boolean | undefined;
    /** TotalQuantity */
    totalQuantity: number | undefined;
    /** TotalAmount */
    totalAmount: number | undefined;
    /** AccountsId */
    accountsId: string | undefined;
    /** OrderType */
    orderType: OrderTypeEnum | undefined;

    constructor(data?: IActivityEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.activityNo = data["activityNo"];
            this.sourceId = data["sourceId"];
            this.scheduleId = data["scheduleId"];
            this.orgActivityId = data["orgActivityId"];
            this.activityDate = data["activityDate"] ? moment(data["activityDate"].toString()) : <any>undefined;
            this.playDate = data["playDate"] ? moment(data["playDate"].toString()) : <any>undefined;
            this.customerId = data["customerId"];
            this.buyer = data["buyer"];
            this.mobile = data["mobile"];
            this.payMethodId = data["payMethodId"];
            this.voucherNo = data["voucherNo"];
            this.payStatus = data["payStatus"];
            this.activityType = data["activityType"];
            this.remark = data["remark"];
            this.isPrint = data["isPrint"];
            this.closed = data["closed"];
            this.totalQuantity = data["totalQuantity"];
            this.totalAmount = data["totalAmount"];
            this.accountsId = data["accountsId"];
            this.orderType = data["orderType"];
        }
    }

    static fromJS(data: any): ActivityEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activityNo"] = this.activityNo;
        data["sourceId"] = this.sourceId;
        data["scheduleId"] = this.scheduleId;
        data["orgActivityId"] = this.orgActivityId;
        data["activityDate"] = this.activityDate ? this.activityDate.toISOString() : <any>undefined;
        data["playDate"] = this.playDate ? this.playDate.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["buyer"] = this.buyer;
        data["mobile"] = this.mobile;
        data["payMethodId"] = this.payMethodId;
        data["voucherNo"] = this.voucherNo;
        data["payStatus"] = this.payStatus;
        data["activityType"] = this.activityType;
        data["remark"] = this.remark;
        data["isPrint"] = this.isPrint;
        data["closed"] = this.closed;
        data["totalQuantity"] = this.totalQuantity;
        data["totalAmount"] = this.totalAmount;
        data["accountsId"] = this.accountsId;
        data["orderType"] = this.orderType;
        return data; 
    }

    clone(): ActivityEditDto {
        const json = this.toJSON();
        let result = new ActivityEditDto();
        result.init(json);
        return result;
    }
}

export interface IActivityEditDto {
    /** Id */
    id: string | undefined;
    /** ActivityNo */
    activityNo: string | undefined;
    /** SourceId */
    sourceId: string | undefined;
    /** ScheduleId */
    scheduleId: string | undefined;
    /** OrgActivityId */
    orgActivityId: string | undefined;
    /** ActivityDate */
    activityDate: moment.Moment | undefined;
    /** PlayDate */
    playDate: moment.Moment | undefined;
    /** CustomerId */
    customerId: string | undefined;
    /** Buyer */
    buyer: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** PayMethodId */
    payMethodId: string | undefined;
    /** VoucherNo */
    voucherNo: string | undefined;
    /** PayStatus */
    payStatus: PayStatusEnum | undefined;
    /** ActivityType */
    activityType: ActivityTypeEnum | undefined;
    /** Remark */
    remark: string | undefined;
    /** IsPrint */
    isPrint: boolean | undefined;
    /** Closed */
    closed: boolean | undefined;
    /** TotalQuantity */
    totalQuantity: number | undefined;
    /** TotalAmount */
    totalAmount: number | undefined;
    /** AccountsId */
    accountsId: string | undefined;
    /** OrderType */
    orderType: OrderTypeEnum | undefined;
}

export class PagedResultDtoOfActivityListDto implements IPagedResultDtoOfActivityListDto {
    totalCount: number | undefined;
    items: ActivityListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfActivityListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ActivityListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfActivityListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfActivityListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfActivityListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfActivityListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfActivityListDto {
    totalCount: number | undefined;
    items: ActivityListDto[] | undefined;
}

export class ActivityListDto implements IActivityListDto {
    /** BranchId */
    branchId: string | undefined;
    /** ActivityNo */
    activityNo: string | undefined;
    /** SourceId */
    sourceId: string | undefined;
    /** Source */
    source: Source | undefined;
    /** ScheduleId */
    scheduleId: string | undefined;
    /** Schedule */
    schedule: Schedule | undefined;
    /** OrgActivityId */
    orgActivityId: string | undefined;
    /** ActivityDate */
    activityDate: moment.Moment | undefined;
    /** PlayDate */
    playDate: moment.Moment | undefined;
    /** CustomerId */
    customerId: string | undefined;
    /** Customer */
    customer: Customer | undefined;
    /** Buyer */
    buyer: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** PayMethodId */
    payMethodId: string | undefined;
    /** PayMethod */
    payMethod: PayMethod | undefined;
    /** VoucherNo */
    voucherNo: string | undefined;
    /** PayStatus */
    payStatus: PayStatusEnum | undefined;
    /** ActivityType */
    activityType: ActivityTypeEnum | undefined;
    /** Remark */
    remark: string | undefined;
    /** IsPrint */
    isPrint: boolean | undefined;
    /** Closed */
    closed: boolean | undefined;
    /** TotalQuantity */
    totalQuantity: number | undefined;
    /** TotalAmount */
    totalAmount: number | undefined;
    /** AccountsId */
    accountsId: string | undefined;
    /** Account */
    account: Account | undefined;
    /** OrderType */
    orderType: OrderTypeEnum | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IActivityListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.activityNo = data["activityNo"];
            this.sourceId = data["sourceId"];
            this.source = data["source"] ? Source.fromJS(data["source"]) : <any>undefined;
            this.scheduleId = data["scheduleId"];
            this.schedule = data["schedule"] ? Schedule.fromJS(data["schedule"]) : <any>undefined;
            this.orgActivityId = data["orgActivityId"];
            this.activityDate = data["activityDate"] ? moment(data["activityDate"].toString()) : <any>undefined;
            this.playDate = data["playDate"] ? moment(data["playDate"].toString()) : <any>undefined;
            this.customerId = data["customerId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.buyer = data["buyer"];
            this.mobile = data["mobile"];
            this.payMethodId = data["payMethodId"];
            this.payMethod = data["payMethod"] ? PayMethod.fromJS(data["payMethod"]) : <any>undefined;
            this.voucherNo = data["voucherNo"];
            this.payStatus = data["payStatus"];
            this.activityType = data["activityType"];
            this.remark = data["remark"];
            this.isPrint = data["isPrint"];
            this.closed = data["closed"];
            this.totalQuantity = data["totalQuantity"];
            this.totalAmount = data["totalAmount"];
            this.accountsId = data["accountsId"];
            this.account = data["account"] ? Account.fromJS(data["account"]) : <any>undefined;
            this.orderType = data["orderType"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["activityNo"] = this.activityNo;
        data["sourceId"] = this.sourceId;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["scheduleId"] = this.scheduleId;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["orgActivityId"] = this.orgActivityId;
        data["activityDate"] = this.activityDate ? this.activityDate.toISOString() : <any>undefined;
        data["playDate"] = this.playDate ? this.playDate.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["buyer"] = this.buyer;
        data["mobile"] = this.mobile;
        data["payMethodId"] = this.payMethodId;
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        data["voucherNo"] = this.voucherNo;
        data["payStatus"] = this.payStatus;
        data["activityType"] = this.activityType;
        data["remark"] = this.remark;
        data["isPrint"] = this.isPrint;
        data["closed"] = this.closed;
        data["totalQuantity"] = this.totalQuantity;
        data["totalAmount"] = this.totalAmount;
        data["accountsId"] = this.accountsId;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["orderType"] = this.orderType;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ActivityListDto {
        const json = this.toJSON();
        let result = new ActivityListDto();
        result.init(json);
        return result;
    }
}

export interface IActivityListDto {
    /** BranchId */
    branchId: string | undefined;
    /** ActivityNo */
    activityNo: string | undefined;
    /** SourceId */
    sourceId: string | undefined;
    /** Source */
    source: Source | undefined;
    /** ScheduleId */
    scheduleId: string | undefined;
    /** Schedule */
    schedule: Schedule | undefined;
    /** OrgActivityId */
    orgActivityId: string | undefined;
    /** ActivityDate */
    activityDate: moment.Moment | undefined;
    /** PlayDate */
    playDate: moment.Moment | undefined;
    /** CustomerId */
    customerId: string | undefined;
    /** Customer */
    customer: Customer | undefined;
    /** Buyer */
    buyer: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** PayMethodId */
    payMethodId: string | undefined;
    /** PayMethod */
    payMethod: PayMethod | undefined;
    /** VoucherNo */
    voucherNo: string | undefined;
    /** PayStatus */
    payStatus: PayStatusEnum | undefined;
    /** ActivityType */
    activityType: ActivityTypeEnum | undefined;
    /** Remark */
    remark: string | undefined;
    /** IsPrint */
    isPrint: boolean | undefined;
    /** Closed */
    closed: boolean | undefined;
    /** TotalQuantity */
    totalQuantity: number | undefined;
    /** TotalAmount */
    totalAmount: number | undefined;
    /** AccountsId */
    accountsId: string | undefined;
    /** Account */
    account: Account | undefined;
    /** OrderType */
    orderType: OrderTypeEnum | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetActivityForEditOutput implements IGetActivityForEditOutput {
    activity: ActivityEditDto | undefined;

    constructor(data?: IGetActivityForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.activity = data["activity"] ? ActivityEditDto.fromJS(data["activity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetActivityForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetActivityForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetActivityForEditOutput {
        const json = this.toJSON();
        let result = new GetActivityForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetActivityForEditOutput {
    activity: ActivityEditDto | undefined;
}

export class GetActivitysInput implements IGetActivitysInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    /** 购票人证件号 */
    certificatesNum: string | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetActivitysInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.certificatesNum = data["certificatesNum"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetActivitysInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetActivitysInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["certificatesNum"] = this.certificatesNum;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetActivitysInput {
        const json = this.toJSON();
        let result = new GetActivitysInput();
        result.init(json);
        return result;
    }
}

export interface IGetActivitysInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    /** 购票人证件号 */
    certificatesNum: string | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class CreateOrUpdateActivityDetailInput implements ICreateOrUpdateActivityDetailInput {
    activityDetail: ActivityDetailEditDto;

    constructor(data?: ICreateOrUpdateActivityDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.activityDetail = new ActivityDetailEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.activityDetail = data["activityDetail"] ? ActivityDetailEditDto.fromJS(data["activityDetail"]) : new ActivityDetailEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateActivityDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateActivityDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityDetail"] = this.activityDetail ? this.activityDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateActivityDetailInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateActivityDetailInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateActivityDetailInput {
    activityDetail: ActivityDetailEditDto;
}

export class ActivityDetailEditDto implements IActivityDetailEditDto {
    /** Id */
    id: string | undefined;
    /** ActivityId */
    activityId: string | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** Quantity */
    quantity: number | undefined;
    /** UnitPrice */
    unitPrice: number | undefined;
    /** Discount */
    discount: number | undefined;
    /** SalePrice */
    salePrice: number | undefined;
    /** TotalAmount */
    totalAmount: number | undefined;
    /** Remark */
    remark: string | undefined;
    /** AccountId */
    accountId: string | undefined;
    /** AccountDetailId */
    accountDetailId: string | undefined;
    /** OrgDetailId */
    orgDetailId: string | undefined;
    /** 航班标识 */
    scheduleId: string | undefined;
    /** 仓位 */
    warePosition: WareHousePosition | undefined;

    constructor(data?: IActivityDetailEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.activityId = data["activityId"];
            this.ticketId = data["ticketId"];
            this.quantity = data["quantity"];
            this.unitPrice = data["unitPrice"];
            this.discount = data["discount"];
            this.salePrice = data["salePrice"];
            this.totalAmount = data["totalAmount"];
            this.remark = data["remark"];
            this.accountId = data["accountId"];
            this.accountDetailId = data["accountDetailId"];
            this.orgDetailId = data["orgDetailId"];
            this.scheduleId = data["scheduleId"];
            this.warePosition = data["warePosition"];
        }
    }

    static fromJS(data: any): ActivityDetailEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityDetailEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activityId"] = this.activityId;
        data["ticketId"] = this.ticketId;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["discount"] = this.discount;
        data["salePrice"] = this.salePrice;
        data["totalAmount"] = this.totalAmount;
        data["remark"] = this.remark;
        data["accountId"] = this.accountId;
        data["accountDetailId"] = this.accountDetailId;
        data["orgDetailId"] = this.orgDetailId;
        data["scheduleId"] = this.scheduleId;
        data["warePosition"] = this.warePosition;
        return data; 
    }

    clone(): ActivityDetailEditDto {
        const json = this.toJSON();
        let result = new ActivityDetailEditDto();
        result.init(json);
        return result;
    }
}

export interface IActivityDetailEditDto {
    /** Id */
    id: string | undefined;
    /** ActivityId */
    activityId: string | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** Quantity */
    quantity: number | undefined;
    /** UnitPrice */
    unitPrice: number | undefined;
    /** Discount */
    discount: number | undefined;
    /** SalePrice */
    salePrice: number | undefined;
    /** TotalAmount */
    totalAmount: number | undefined;
    /** Remark */
    remark: string | undefined;
    /** AccountId */
    accountId: string | undefined;
    /** AccountDetailId */
    accountDetailId: string | undefined;
    /** OrgDetailId */
    orgDetailId: string | undefined;
    /** 航班标识 */
    scheduleId: string | undefined;
    /** 仓位 */
    warePosition: WareHousePosition | undefined;
}

export class ActivityDetailListDto implements IActivityDetailListDto {
    /** BranchId */
    branchId: string | undefined;
    /** ActivityId */
    activityId: string | undefined;
    /** Activity */
    activity: Activity | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** Ticket */
    ticket: Ticket | undefined;
    /** Quantity */
    quantity: number | undefined;
    /** UnitPrice */
    unitPrice: number | undefined;
    /** Discount */
    discount: number | undefined;
    /** SalePrice */
    salePrice: number | undefined;
    /** TotalAmount */
    totalAmount: number | undefined;
    /** Remark */
    remark: string | undefined;
    /** AccountId */
    accountId: string | undefined;
    /** Account */
    account: Account | undefined;
    /** AccountDetailId */
    accountDetailId: string | undefined;
    /** AccountDetail */
    accountDetail: AccountDetail | undefined;
    /** OrgDetailId */
    orgDetailId: string | undefined;
    /** 航班标识 */
    scheduleId: string | undefined;
    schedule: Schedule | undefined;
    /** 仓位 */
    warePosition: WareHousePosition | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IActivityDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.activityId = data["activityId"];
            this.activity = data["activity"] ? Activity.fromJS(data["activity"]) : <any>undefined;
            this.ticketId = data["ticketId"];
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.quantity = data["quantity"];
            this.unitPrice = data["unitPrice"];
            this.discount = data["discount"];
            this.salePrice = data["salePrice"];
            this.totalAmount = data["totalAmount"];
            this.remark = data["remark"];
            this.accountId = data["accountId"];
            this.account = data["account"] ? Account.fromJS(data["account"]) : <any>undefined;
            this.accountDetailId = data["accountDetailId"];
            this.accountDetail = data["accountDetail"] ? AccountDetail.fromJS(data["accountDetail"]) : <any>undefined;
            this.orgDetailId = data["orgDetailId"];
            this.scheduleId = data["scheduleId"];
            this.schedule = data["schedule"] ? Schedule.fromJS(data["schedule"]) : <any>undefined;
            this.warePosition = data["warePosition"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["ticketId"] = this.ticketId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["discount"] = this.discount;
        data["salePrice"] = this.salePrice;
        data["totalAmount"] = this.totalAmount;
        data["remark"] = this.remark;
        data["accountId"] = this.accountId;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["accountDetailId"] = this.accountDetailId;
        data["accountDetail"] = this.accountDetail ? this.accountDetail.toJSON() : <any>undefined;
        data["orgDetailId"] = this.orgDetailId;
        data["scheduleId"] = this.scheduleId;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["warePosition"] = this.warePosition;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ActivityDetailListDto {
        const json = this.toJSON();
        let result = new ActivityDetailListDto();
        result.init(json);
        return result;
    }
}

export interface IActivityDetailListDto {
    /** BranchId */
    branchId: string | undefined;
    /** ActivityId */
    activityId: string | undefined;
    /** Activity */
    activity: Activity | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** Ticket */
    ticket: Ticket | undefined;
    /** Quantity */
    quantity: number | undefined;
    /** UnitPrice */
    unitPrice: number | undefined;
    /** Discount */
    discount: number | undefined;
    /** SalePrice */
    salePrice: number | undefined;
    /** TotalAmount */
    totalAmount: number | undefined;
    /** Remark */
    remark: string | undefined;
    /** AccountId */
    accountId: string | undefined;
    /** Account */
    account: Account | undefined;
    /** AccountDetailId */
    accountDetailId: string | undefined;
    /** AccountDetail */
    accountDetail: AccountDetail | undefined;
    /** OrgDetailId */
    orgDetailId: string | undefined;
    /** 航班标识 */
    scheduleId: string | undefined;
    schedule: Schedule | undefined;
    /** 仓位 */
    warePosition: WareHousePosition | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class AccountDetail implements IAccountDetail {
    branchId: string | undefined;
    accountId: string;
    account: Account | undefined;
    activityDetailId: string;
    activityDetail: ActivityDetail | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IAccountDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.accountId = data["accountId"];
            this.account = data["account"] ? Account.fromJS(data["account"]) : <any>undefined;
            this.activityDetailId = data["activityDetailId"];
            this.activityDetail = data["activityDetail"] ? ActivityDetail.fromJS(data["activityDetail"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AccountDetail {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["accountId"] = this.accountId;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["activityDetailId"] = this.activityDetailId;
        data["activityDetail"] = this.activityDetail ? this.activityDetail.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AccountDetail {
        const json = this.toJSON();
        let result = new AccountDetail();
        result.init(json);
        return result;
    }
}

export interface IAccountDetail {
    branchId: string | undefined;
    accountId: string;
    account: Account | undefined;
    activityDetailId: string;
    activityDetail: ActivityDetail | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetActivityDetailForEditOutput implements IGetActivityDetailForEditOutput {
    activityDetail: ActivityDetailEditDto | undefined;

    constructor(data?: IGetActivityDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.activityDetail = data["activityDetail"] ? ActivityDetailEditDto.fromJS(data["activityDetail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetActivityDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetActivityDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityDetail"] = this.activityDetail ? this.activityDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetActivityDetailForEditOutput {
        const json = this.toJSON();
        let result = new GetActivityDetailForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetActivityDetailForEditOutput {
    activityDetail: ActivityDetailEditDto | undefined;
}

export class PagedResultDtoOfActivityDetailListDto implements IPagedResultDtoOfActivityDetailListDto {
    totalCount: number | undefined;
    items: ActivityDetailListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfActivityDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ActivityDetailListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfActivityDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfActivityDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfActivityDetailListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfActivityDetailListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfActivityDetailListDto {
    totalCount: number | undefined;
    items: ActivityDetailListDto[] | undefined;
}

export class CreateOrUpdateActivityTempInput implements ICreateOrUpdateActivityTempInput {
    activityTemp: ActivityTempEditDto;

    constructor(data?: ICreateOrUpdateActivityTempInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.activityTemp = new ActivityTempEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.activityTemp = data["activityTemp"] ? ActivityTempEditDto.fromJS(data["activityTemp"]) : new ActivityTempEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateActivityTempInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateActivityTempInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityTemp"] = this.activityTemp ? this.activityTemp.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateActivityTempInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateActivityTempInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateActivityTempInput {
    activityTemp: ActivityTempEditDto;
}

export class ActivityTempEditDto implements IActivityTempEditDto {
    /** Id */
    id: string | undefined;
    /** ActivityNo */
    activityNo: string | undefined;
    /** SourceId */
    sourceId: string | undefined;
    /** ScheduleId */
    scheduleId: string | undefined;
    /** ActivityDate */
    activityDate: moment.Moment | undefined;
    /** PlayDate */
    playDate: moment.Moment | undefined;
    /** CustomerId */
    customerId: string | undefined;
    /** Customer */
    customer: Customer | undefined;
    /** OrderType */
    orderType: OrderTypeEnum | undefined;
    /** PayStatus */
    payStatus: PayStatusEnum | undefined;
    /** Buyer */
    buyer: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** PayMethodId */
    payMethodId: string | undefined;
    /** VoucherNo */
    voucherNo: string | undefined;
    /** Remark */
    remark: string | undefined;
    /** TotalQuantity */
    totalQuantity: number | undefined;
    /** TotalAmount */
    totalAmount: number | undefined;
    /** CollectionPwd */
    collectionPwd: string | undefined;
    /** CollectionCode */
    collectionCode: string | undefined;
    /** PayTime */
    payTime: moment.Moment | undefined;
    /** ActivityId */
    activityId: string | undefined;
    /** openid */
    openId: string | undefined;

    constructor(data?: IActivityTempEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.activityNo = data["activityNo"];
            this.sourceId = data["sourceId"];
            this.scheduleId = data["scheduleId"];
            this.activityDate = data["activityDate"] ? moment(data["activityDate"].toString()) : <any>undefined;
            this.playDate = data["playDate"] ? moment(data["playDate"].toString()) : <any>undefined;
            this.customerId = data["customerId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.orderType = data["orderType"];
            this.payStatus = data["payStatus"];
            this.buyer = data["buyer"];
            this.mobile = data["mobile"];
            this.payMethodId = data["payMethodId"];
            this.voucherNo = data["voucherNo"];
            this.remark = data["remark"];
            this.totalQuantity = data["totalQuantity"];
            this.totalAmount = data["totalAmount"];
            this.collectionPwd = data["collectionPwd"];
            this.collectionCode = data["collectionCode"];
            this.payTime = data["payTime"] ? moment(data["payTime"].toString()) : <any>undefined;
            this.activityId = data["activityId"];
            this.openId = data["openId"];
        }
    }

    static fromJS(data: any): ActivityTempEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityTempEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activityNo"] = this.activityNo;
        data["sourceId"] = this.sourceId;
        data["scheduleId"] = this.scheduleId;
        data["activityDate"] = this.activityDate ? this.activityDate.toISOString() : <any>undefined;
        data["playDate"] = this.playDate ? this.playDate.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["orderType"] = this.orderType;
        data["payStatus"] = this.payStatus;
        data["buyer"] = this.buyer;
        data["mobile"] = this.mobile;
        data["payMethodId"] = this.payMethodId;
        data["voucherNo"] = this.voucherNo;
        data["remark"] = this.remark;
        data["totalQuantity"] = this.totalQuantity;
        data["totalAmount"] = this.totalAmount;
        data["collectionPwd"] = this.collectionPwd;
        data["collectionCode"] = this.collectionCode;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["activityId"] = this.activityId;
        data["openId"] = this.openId;
        return data; 
    }

    clone(): ActivityTempEditDto {
        const json = this.toJSON();
        let result = new ActivityTempEditDto();
        result.init(json);
        return result;
    }
}

export interface IActivityTempEditDto {
    /** Id */
    id: string | undefined;
    /** ActivityNo */
    activityNo: string | undefined;
    /** SourceId */
    sourceId: string | undefined;
    /** ScheduleId */
    scheduleId: string | undefined;
    /** ActivityDate */
    activityDate: moment.Moment | undefined;
    /** PlayDate */
    playDate: moment.Moment | undefined;
    /** CustomerId */
    customerId: string | undefined;
    /** Customer */
    customer: Customer | undefined;
    /** OrderType */
    orderType: OrderTypeEnum | undefined;
    /** PayStatus */
    payStatus: PayStatusEnum | undefined;
    /** Buyer */
    buyer: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** PayMethodId */
    payMethodId: string | undefined;
    /** VoucherNo */
    voucherNo: string | undefined;
    /** Remark */
    remark: string | undefined;
    /** TotalQuantity */
    totalQuantity: number | undefined;
    /** TotalAmount */
    totalAmount: number | undefined;
    /** CollectionPwd */
    collectionPwd: string | undefined;
    /** CollectionCode */
    collectionCode: string | undefined;
    /** PayTime */
    payTime: moment.Moment | undefined;
    /** ActivityId */
    activityId: string | undefined;
    /** openid */
    openId: string | undefined;
}

export class ActivityTempListDto implements IActivityTempListDto {
    /** BranchId */
    branchId: string | undefined;
    /** ActivityNo */
    activityNo: string | undefined;
    /** SourceId */
    sourceId: string | undefined;
    /** Source */
    source: Source | undefined;
    /** ScheduleId */
    scheduleId: string | undefined;
    /** Schedule */
    schedule: Schedule | undefined;
    /** ActivityDate */
    activityDate: moment.Moment | undefined;
    /** PlayDate */
    playDate: moment.Moment | undefined;
    /** CustomerId */
    customerId: string | undefined;
    /** Customer */
    customer: Customer | undefined;
    /** OrderType */
    orderType: OrderTypeEnum | undefined;
    /** PayStatus */
    payStatus: PayStatusEnum | undefined;
    /** Buyer */
    buyer: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** PayMethodId */
    payMethodId: string | undefined;
    /** PayMethod */
    payMethod: PayMethod | undefined;
    /** VoucherNo */
    voucherNo: string | undefined;
    /** Remark */
    remark: string | undefined;
    /** TotalQuantity */
    totalQuantity: number | undefined;
    /** TotalAmount */
    totalAmount: number | undefined;
    /** CollectionPwd */
    collectionPwd: string | undefined;
    /** Collector */
    collector: string | undefined;
    /** CollectionCode */
    collectionCode: string | undefined;
    /** PayTime */
    payTime: moment.Moment | undefined;
    /** ActivityId */
    activityId: string | undefined;
    /** Activity */
    activity: Activity | undefined;
    /** openid */
    openId: string | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IActivityTempListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.activityNo = data["activityNo"];
            this.sourceId = data["sourceId"];
            this.source = data["source"] ? Source.fromJS(data["source"]) : <any>undefined;
            this.scheduleId = data["scheduleId"];
            this.schedule = data["schedule"] ? Schedule.fromJS(data["schedule"]) : <any>undefined;
            this.activityDate = data["activityDate"] ? moment(data["activityDate"].toString()) : <any>undefined;
            this.playDate = data["playDate"] ? moment(data["playDate"].toString()) : <any>undefined;
            this.customerId = data["customerId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.orderType = data["orderType"];
            this.payStatus = data["payStatus"];
            this.buyer = data["buyer"];
            this.mobile = data["mobile"];
            this.payMethodId = data["payMethodId"];
            this.payMethod = data["payMethod"] ? PayMethod.fromJS(data["payMethod"]) : <any>undefined;
            this.voucherNo = data["voucherNo"];
            this.remark = data["remark"];
            this.totalQuantity = data["totalQuantity"];
            this.totalAmount = data["totalAmount"];
            this.collectionPwd = data["collectionPwd"];
            this.collector = data["collector"];
            this.collectionCode = data["collectionCode"];
            this.payTime = data["payTime"] ? moment(data["payTime"].toString()) : <any>undefined;
            this.activityId = data["activityId"];
            this.activity = data["activity"] ? Activity.fromJS(data["activity"]) : <any>undefined;
            this.openId = data["openId"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityTempListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityTempListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["activityNo"] = this.activityNo;
        data["sourceId"] = this.sourceId;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["scheduleId"] = this.scheduleId;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["activityDate"] = this.activityDate ? this.activityDate.toISOString() : <any>undefined;
        data["playDate"] = this.playDate ? this.playDate.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["orderType"] = this.orderType;
        data["payStatus"] = this.payStatus;
        data["buyer"] = this.buyer;
        data["mobile"] = this.mobile;
        data["payMethodId"] = this.payMethodId;
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        data["voucherNo"] = this.voucherNo;
        data["remark"] = this.remark;
        data["totalQuantity"] = this.totalQuantity;
        data["totalAmount"] = this.totalAmount;
        data["collectionPwd"] = this.collectionPwd;
        data["collector"] = this.collector;
        data["collectionCode"] = this.collectionCode;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["openId"] = this.openId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ActivityTempListDto {
        const json = this.toJSON();
        let result = new ActivityTempListDto();
        result.init(json);
        return result;
    }
}

export interface IActivityTempListDto {
    /** BranchId */
    branchId: string | undefined;
    /** ActivityNo */
    activityNo: string | undefined;
    /** SourceId */
    sourceId: string | undefined;
    /** Source */
    source: Source | undefined;
    /** ScheduleId */
    scheduleId: string | undefined;
    /** Schedule */
    schedule: Schedule | undefined;
    /** ActivityDate */
    activityDate: moment.Moment | undefined;
    /** PlayDate */
    playDate: moment.Moment | undefined;
    /** CustomerId */
    customerId: string | undefined;
    /** Customer */
    customer: Customer | undefined;
    /** OrderType */
    orderType: OrderTypeEnum | undefined;
    /** PayStatus */
    payStatus: PayStatusEnum | undefined;
    /** Buyer */
    buyer: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** PayMethodId */
    payMethodId: string | undefined;
    /** PayMethod */
    payMethod: PayMethod | undefined;
    /** VoucherNo */
    voucherNo: string | undefined;
    /** Remark */
    remark: string | undefined;
    /** TotalQuantity */
    totalQuantity: number | undefined;
    /** TotalAmount */
    totalAmount: number | undefined;
    /** CollectionPwd */
    collectionPwd: string | undefined;
    /** Collector */
    collector: string | undefined;
    /** CollectionCode */
    collectionCode: string | undefined;
    /** PayTime */
    payTime: moment.Moment | undefined;
    /** ActivityId */
    activityId: string | undefined;
    /** Activity */
    activity: Activity | undefined;
    /** openid */
    openId: string | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetActivityTempForEditOutput implements IGetActivityTempForEditOutput {
    activityTemp: ActivityTempEditDto | undefined;

    constructor(data?: IGetActivityTempForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.activityTemp = data["activityTemp"] ? ActivityTempEditDto.fromJS(data["activityTemp"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetActivityTempForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetActivityTempForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityTemp"] = this.activityTemp ? this.activityTemp.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetActivityTempForEditOutput {
        const json = this.toJSON();
        let result = new GetActivityTempForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetActivityTempForEditOutput {
    activityTemp: ActivityTempEditDto | undefined;
}

export class GetActivityTempsInput implements IGetActivityTempsInput {
    /** 可以用OpenId查询(用游客Id--CustomerId表票的使用者，不是购买人) */
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetActivityTempsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetActivityTempsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetActivityTempsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetActivityTempsInput {
        const json = this.toJSON();
        let result = new GetActivityTempsInput();
        result.init(json);
        return result;
    }
}

export interface IGetActivityTempsInput {
    /** 可以用OpenId查询(用游客Id--CustomerId表票的使用者，不是购买人) */
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfActivityTempListDto implements IPagedResultDtoOfActivityTempListDto {
    totalCount: number | undefined;
    items: ActivityTempListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfActivityTempListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ActivityTempListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfActivityTempListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfActivityTempListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfActivityTempListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfActivityTempListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfActivityTempListDto {
    totalCount: number | undefined;
    items: ActivityTempListDto[] | undefined;
}

export class CreateOrUpdateActivityTempDetailInput implements ICreateOrUpdateActivityTempDetailInput {
    activityTempDetail: ActivityTempDetailEditDto;

    constructor(data?: ICreateOrUpdateActivityTempDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.activityTempDetail = new ActivityTempDetailEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.activityTempDetail = data["activityTempDetail"] ? ActivityTempDetailEditDto.fromJS(data["activityTempDetail"]) : new ActivityTempDetailEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateActivityTempDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateActivityTempDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityTempDetail"] = this.activityTempDetail ? this.activityTempDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateActivityTempDetailInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateActivityTempDetailInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateActivityTempDetailInput {
    activityTempDetail: ActivityTempDetailEditDto;
}

export class ActivityTempDetailEditDto implements IActivityTempDetailEditDto {
    /** Id */
    id: string | undefined;
    /** ActivityTempId */
    activityTempId: string;
    /** TicketId */
    ticketId: string;
    /** TicketName */
    ticketName: string;
    /** SalePrice */
    salePrice: number;
    /** Quantity */
    quantity: number;
    /** UniPrice */
    uniPrice: number;
    /** Discount */
    discount: number;
    /** 航班标识 */
    scheduleId: string | undefined;
    /** 票型价格标识 */
    ticketPriceId: string | undefined;
    /** 仓位 */
    warePosition: WareHousePosition | undefined;

    constructor(data?: IActivityTempDetailEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.activityTempId = data["activityTempId"];
            this.ticketId = data["ticketId"];
            this.ticketName = data["ticketName"];
            this.salePrice = data["salePrice"];
            this.quantity = data["quantity"];
            this.uniPrice = data["uniPrice"];
            this.discount = data["discount"];
            this.scheduleId = data["scheduleId"];
            this.ticketPriceId = data["ticketPriceId"];
            this.warePosition = data["warePosition"];
        }
    }

    static fromJS(data: any): ActivityTempDetailEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityTempDetailEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activityTempId"] = this.activityTempId;
        data["ticketId"] = this.ticketId;
        data["ticketName"] = this.ticketName;
        data["salePrice"] = this.salePrice;
        data["quantity"] = this.quantity;
        data["uniPrice"] = this.uniPrice;
        data["discount"] = this.discount;
        data["scheduleId"] = this.scheduleId;
        data["ticketPriceId"] = this.ticketPriceId;
        data["warePosition"] = this.warePosition;
        return data; 
    }

    clone(): ActivityTempDetailEditDto {
        const json = this.toJSON();
        let result = new ActivityTempDetailEditDto();
        result.init(json);
        return result;
    }
}

export interface IActivityTempDetailEditDto {
    /** Id */
    id: string | undefined;
    /** ActivityTempId */
    activityTempId: string;
    /** TicketId */
    ticketId: string;
    /** TicketName */
    ticketName: string;
    /** SalePrice */
    salePrice: number;
    /** Quantity */
    quantity: number;
    /** UniPrice */
    uniPrice: number;
    /** Discount */
    discount: number;
    /** 航班标识 */
    scheduleId: string | undefined;
    /** 票型价格标识 */
    ticketPriceId: string | undefined;
    /** 仓位 */
    warePosition: WareHousePosition | undefined;
}

export class ActivityTempDetailListDto implements IActivityTempDetailListDto {
    /** BranchId */
    branchId: string | undefined;
    /** ActivityTempId */
    activityTempId: string;
    /** ActivityTemp */
    activityTemp: ActivityTemp | undefined;
    /** TicketId */
    ticketId: string;
    /** Ticket */
    ticket: Ticket | undefined;
    /** TicketName */
    ticketName: string;
    /** SalePrice */
    salePrice: number;
    /** Quantity */
    quantity: number;
    /** UniPrice */
    uniPrice: number;
    /** Discount */
    discount: number;
    /** 航班标识 */
    scheduleId: string | undefined;
    schedule: Schedule | undefined;
    ticketPrice: TicketPrice | undefined;
    /** 票型价格标识 */
    ticketPriceId: string | undefined;
    /** 票据信息 */
    ticketDetail: TicketDetail | undefined;
    /** 会员标识 */
    customerId: string | undefined;
    customer: Customer | undefined;
    /** 仓位 */
    warePosition: WareHousePosition | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IActivityTempDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.activityTempId = data["activityTempId"];
            this.activityTemp = data["activityTemp"] ? ActivityTemp.fromJS(data["activityTemp"]) : <any>undefined;
            this.ticketId = data["ticketId"];
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.ticketName = data["ticketName"];
            this.salePrice = data["salePrice"];
            this.quantity = data["quantity"];
            this.uniPrice = data["uniPrice"];
            this.discount = data["discount"];
            this.scheduleId = data["scheduleId"];
            this.schedule = data["schedule"] ? Schedule.fromJS(data["schedule"]) : <any>undefined;
            this.ticketPrice = data["ticketPrice"] ? TicketPrice.fromJS(data["ticketPrice"]) : <any>undefined;
            this.ticketPriceId = data["ticketPriceId"];
            this.ticketDetail = data["ticketDetail"] ? TicketDetail.fromJS(data["ticketDetail"]) : <any>undefined;
            this.customerId = data["customerId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.warePosition = data["warePosition"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityTempDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityTempDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["activityTempId"] = this.activityTempId;
        data["activityTemp"] = this.activityTemp ? this.activityTemp.toJSON() : <any>undefined;
        data["ticketId"] = this.ticketId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["ticketName"] = this.ticketName;
        data["salePrice"] = this.salePrice;
        data["quantity"] = this.quantity;
        data["uniPrice"] = this.uniPrice;
        data["discount"] = this.discount;
        data["scheduleId"] = this.scheduleId;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        data["ticketPriceId"] = this.ticketPriceId;
        data["ticketDetail"] = this.ticketDetail ? this.ticketDetail.toJSON() : <any>undefined;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["warePosition"] = this.warePosition;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ActivityTempDetailListDto {
        const json = this.toJSON();
        let result = new ActivityTempDetailListDto();
        result.init(json);
        return result;
    }
}

export interface IActivityTempDetailListDto {
    /** BranchId */
    branchId: string | undefined;
    /** ActivityTempId */
    activityTempId: string;
    /** ActivityTemp */
    activityTemp: ActivityTemp | undefined;
    /** TicketId */
    ticketId: string;
    /** Ticket */
    ticket: Ticket | undefined;
    /** TicketName */
    ticketName: string;
    /** SalePrice */
    salePrice: number;
    /** Quantity */
    quantity: number;
    /** UniPrice */
    uniPrice: number;
    /** Discount */
    discount: number;
    /** 航班标识 */
    scheduleId: string | undefined;
    schedule: Schedule | undefined;
    ticketPrice: TicketPrice | undefined;
    /** 票型价格标识 */
    ticketPriceId: string | undefined;
    /** 票据信息 */
    ticketDetail: TicketDetail | undefined;
    /** 会员标识 */
    customerId: string | undefined;
    customer: Customer | undefined;
    /** 仓位 */
    warePosition: WareHousePosition | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ActivityTemp implements IActivityTemp {
    branchId: string | undefined;
    activityNo: string | undefined;
    sourceId: string | undefined;
    source: Source | undefined;
    scheduleId: string | undefined;
    activityDate: moment.Moment | undefined;
    playDate: moment.Moment | undefined;
    customerId: string | undefined;
    orderType: OrderTypeEnum | undefined;
    payStatus: PayStatusEnum | undefined;
    buyer: string | undefined;
    mobile: string | undefined;
    payMethodId: string | undefined;
    payMethod: PayMethod | undefined;
    voucherNo: string | undefined;
    remark: string | undefined;
    totalQuantity: number | undefined;
    totalAmount: number | undefined;
    collectionPwd: string | undefined;
    collector: string | undefined;
    collectionCode: string | undefined;
    payTime: moment.Moment | undefined;
    activityId: string | undefined;
    travelAgencyId: string | undefined;
    travelAgency: TravelAgency | undefined;
    activityDetails: ActivityTempDetail[] | undefined;
    openId: string | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IActivityTemp) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.activityNo = data["activityNo"];
            this.sourceId = data["sourceId"];
            this.source = data["source"] ? Source.fromJS(data["source"]) : <any>undefined;
            this.scheduleId = data["scheduleId"];
            this.activityDate = data["activityDate"] ? moment(data["activityDate"].toString()) : <any>undefined;
            this.playDate = data["playDate"] ? moment(data["playDate"].toString()) : <any>undefined;
            this.customerId = data["customerId"];
            this.orderType = data["orderType"];
            this.payStatus = data["payStatus"];
            this.buyer = data["buyer"];
            this.mobile = data["mobile"];
            this.payMethodId = data["payMethodId"];
            this.payMethod = data["payMethod"] ? PayMethod.fromJS(data["payMethod"]) : <any>undefined;
            this.voucherNo = data["voucherNo"];
            this.remark = data["remark"];
            this.totalQuantity = data["totalQuantity"];
            this.totalAmount = data["totalAmount"];
            this.collectionPwd = data["collectionPwd"];
            this.collector = data["collector"];
            this.collectionCode = data["collectionCode"];
            this.payTime = data["payTime"] ? moment(data["payTime"].toString()) : <any>undefined;
            this.activityId = data["activityId"];
            this.travelAgencyId = data["travelAgencyId"];
            this.travelAgency = data["travelAgency"] ? TravelAgency.fromJS(data["travelAgency"]) : <any>undefined;
            if (data["activityDetails"] && data["activityDetails"].constructor === Array) {
                this.activityDetails = [] as any;
                for (let item of data["activityDetails"])
                    this.activityDetails.push(ActivityTempDetail.fromJS(item));
            }
            this.openId = data["openId"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityTemp {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityTemp();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["activityNo"] = this.activityNo;
        data["sourceId"] = this.sourceId;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["scheduleId"] = this.scheduleId;
        data["activityDate"] = this.activityDate ? this.activityDate.toISOString() : <any>undefined;
        data["playDate"] = this.playDate ? this.playDate.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["orderType"] = this.orderType;
        data["payStatus"] = this.payStatus;
        data["buyer"] = this.buyer;
        data["mobile"] = this.mobile;
        data["payMethodId"] = this.payMethodId;
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        data["voucherNo"] = this.voucherNo;
        data["remark"] = this.remark;
        data["totalQuantity"] = this.totalQuantity;
        data["totalAmount"] = this.totalAmount;
        data["collectionPwd"] = this.collectionPwd;
        data["collector"] = this.collector;
        data["collectionCode"] = this.collectionCode;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["activityId"] = this.activityId;
        data["travelAgencyId"] = this.travelAgencyId;
        data["travelAgency"] = this.travelAgency ? this.travelAgency.toJSON() : <any>undefined;
        if (this.activityDetails && this.activityDetails.constructor === Array) {
            data["activityDetails"] = [];
            for (let item of this.activityDetails)
                data["activityDetails"].push(item.toJSON());
        }
        data["openId"] = this.openId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ActivityTemp {
        const json = this.toJSON();
        let result = new ActivityTemp();
        result.init(json);
        return result;
    }
}

export interface IActivityTemp {
    branchId: string | undefined;
    activityNo: string | undefined;
    sourceId: string | undefined;
    source: Source | undefined;
    scheduleId: string | undefined;
    activityDate: moment.Moment | undefined;
    playDate: moment.Moment | undefined;
    customerId: string | undefined;
    orderType: OrderTypeEnum | undefined;
    payStatus: PayStatusEnum | undefined;
    buyer: string | undefined;
    mobile: string | undefined;
    payMethodId: string | undefined;
    payMethod: PayMethod | undefined;
    voucherNo: string | undefined;
    remark: string | undefined;
    totalQuantity: number | undefined;
    totalAmount: number | undefined;
    collectionPwd: string | undefined;
    collector: string | undefined;
    collectionCode: string | undefined;
    payTime: moment.Moment | undefined;
    activityId: string | undefined;
    travelAgencyId: string | undefined;
    travelAgency: TravelAgency | undefined;
    activityDetails: ActivityTempDetail[] | undefined;
    openId: string | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class TicketDetail implements ITicketDetail {
    branchId: string | undefined;
    ticketNo: string | undefined;
    activityDetailId: string | undefined;
    activityDetail: ActivityDetail | undefined;
    activityId: string | undefined;
    orgActivityDetailId: string | undefined;
    orgActivityId: string | undefined;
    customerId: string | undefined;
    customer: Customer | undefined;
    ticketId: string | undefined;
    qrCode: string | undefined;
    checkingQuantity: number | undefined;
    checkedQuantity: number | undefined;
    startDateTime: moment.Moment | undefined;
    endDateTime: moment.Moment | undefined;
    checkMethod: CheckMethodEnum | undefined;
    routeId: string | undefined;
    route: Route | undefined;
    scheduleId: string | undefined;
    schedule: Schedule | undefined;
    boatId: string | undefined;
    boat: Boat | undefined;
    ticketStatus: TicketStatusEnum | undefined;
    checkTime: moment.Moment | undefined;
    isPrint: boolean | undefined;
    collectionCode: string | undefined;
    warePosition: WareHousePosition | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ITicketDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketNo = data["ticketNo"];
            this.activityDetailId = data["activityDetailId"];
            this.activityDetail = data["activityDetail"] ? ActivityDetail.fromJS(data["activityDetail"]) : <any>undefined;
            this.activityId = data["activityId"];
            this.orgActivityDetailId = data["orgActivityDetailId"];
            this.orgActivityId = data["orgActivityId"];
            this.customerId = data["customerId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.ticketId = data["ticketId"];
            this.qrCode = data["qrCode"];
            this.checkingQuantity = data["checkingQuantity"];
            this.checkedQuantity = data["checkedQuantity"];
            this.startDateTime = data["startDateTime"] ? moment(data["startDateTime"].toString()) : <any>undefined;
            this.endDateTime = data["endDateTime"] ? moment(data["endDateTime"].toString()) : <any>undefined;
            this.checkMethod = data["checkMethod"];
            this.routeId = data["routeId"];
            this.route = data["route"] ? Route.fromJS(data["route"]) : <any>undefined;
            this.scheduleId = data["scheduleId"];
            this.schedule = data["schedule"] ? Schedule.fromJS(data["schedule"]) : <any>undefined;
            this.boatId = data["boatId"];
            this.boat = data["boat"] ? Boat.fromJS(data["boat"]) : <any>undefined;
            this.ticketStatus = data["ticketStatus"];
            this.checkTime = data["checkTime"] ? moment(data["checkTime"].toString()) : <any>undefined;
            this.isPrint = data["isPrint"];
            this.collectionCode = data["collectionCode"];
            this.warePosition = data["warePosition"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketDetail {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketNo"] = this.ticketNo;
        data["activityDetailId"] = this.activityDetailId;
        data["activityDetail"] = this.activityDetail ? this.activityDetail.toJSON() : <any>undefined;
        data["activityId"] = this.activityId;
        data["orgActivityDetailId"] = this.orgActivityDetailId;
        data["orgActivityId"] = this.orgActivityId;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["ticketId"] = this.ticketId;
        data["qrCode"] = this.qrCode;
        data["checkingQuantity"] = this.checkingQuantity;
        data["checkedQuantity"] = this.checkedQuantity;
        data["startDateTime"] = this.startDateTime ? this.startDateTime.toISOString() : <any>undefined;
        data["endDateTime"] = this.endDateTime ? this.endDateTime.toISOString() : <any>undefined;
        data["checkMethod"] = this.checkMethod;
        data["routeId"] = this.routeId;
        data["route"] = this.route ? this.route.toJSON() : <any>undefined;
        data["scheduleId"] = this.scheduleId;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["boatId"] = this.boatId;
        data["boat"] = this.boat ? this.boat.toJSON() : <any>undefined;
        data["ticketStatus"] = this.ticketStatus;
        data["checkTime"] = this.checkTime ? this.checkTime.toISOString() : <any>undefined;
        data["isPrint"] = this.isPrint;
        data["collectionCode"] = this.collectionCode;
        data["warePosition"] = this.warePosition;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketDetail {
        const json = this.toJSON();
        let result = new TicketDetail();
        result.init(json);
        return result;
    }
}

export interface ITicketDetail {
    branchId: string | undefined;
    ticketNo: string | undefined;
    activityDetailId: string | undefined;
    activityDetail: ActivityDetail | undefined;
    activityId: string | undefined;
    orgActivityDetailId: string | undefined;
    orgActivityId: string | undefined;
    customerId: string | undefined;
    customer: Customer | undefined;
    ticketId: string | undefined;
    qrCode: string | undefined;
    checkingQuantity: number | undefined;
    checkedQuantity: number | undefined;
    startDateTime: moment.Moment | undefined;
    endDateTime: moment.Moment | undefined;
    checkMethod: CheckMethodEnum | undefined;
    routeId: string | undefined;
    route: Route | undefined;
    scheduleId: string | undefined;
    schedule: Schedule | undefined;
    boatId: string | undefined;
    boat: Boat | undefined;
    ticketStatus: TicketStatusEnum | undefined;
    checkTime: moment.Moment | undefined;
    isPrint: boolean | undefined;
    collectionCode: string | undefined;
    warePosition: WareHousePosition | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ActivityTempDetail implements IActivityTempDetail {
    branchId: string | undefined;
    activityTempId: string;
    activityTemp: ActivityTemp | undefined;
    ticketPriceId: string | undefined;
    ticketPrice: TicketPrice | undefined;
    ticketName: string;
    salePrice: number;
    quantity: number;
    uniPrice: number;
    discount: number;
    totalAmount: number | undefined;
    customerId: string | undefined;
    customer: Customer | undefined;
    scheduleId: string | undefined;
    schedule: Schedule | undefined;
    warePosition: WareHousePosition | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IActivityTempDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.activityTempId = data["activityTempId"];
            this.activityTemp = data["activityTemp"] ? ActivityTemp.fromJS(data["activityTemp"]) : <any>undefined;
            this.ticketPriceId = data["ticketPriceId"];
            this.ticketPrice = data["ticketPrice"] ? TicketPrice.fromJS(data["ticketPrice"]) : <any>undefined;
            this.ticketName = data["ticketName"];
            this.salePrice = data["salePrice"];
            this.quantity = data["quantity"];
            this.uniPrice = data["uniPrice"];
            this.discount = data["discount"];
            this.totalAmount = data["totalAmount"];
            this.customerId = data["customerId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.scheduleId = data["scheduleId"];
            this.schedule = data["schedule"] ? Schedule.fromJS(data["schedule"]) : <any>undefined;
            this.warePosition = data["warePosition"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityTempDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityTempDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["activityTempId"] = this.activityTempId;
        data["activityTemp"] = this.activityTemp ? this.activityTemp.toJSON() : <any>undefined;
        data["ticketPriceId"] = this.ticketPriceId;
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        data["ticketName"] = this.ticketName;
        data["salePrice"] = this.salePrice;
        data["quantity"] = this.quantity;
        data["uniPrice"] = this.uniPrice;
        data["discount"] = this.discount;
        data["totalAmount"] = this.totalAmount;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["scheduleId"] = this.scheduleId;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["warePosition"] = this.warePosition;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ActivityTempDetail {
        const json = this.toJSON();
        let result = new ActivityTempDetail();
        result.init(json);
        return result;
    }
}

export interface IActivityTempDetail {
    branchId: string | undefined;
    activityTempId: string;
    activityTemp: ActivityTemp | undefined;
    ticketPriceId: string | undefined;
    ticketPrice: TicketPrice | undefined;
    ticketName: string;
    salePrice: number;
    quantity: number;
    uniPrice: number;
    discount: number;
    totalAmount: number | undefined;
    customerId: string | undefined;
    customer: Customer | undefined;
    scheduleId: string | undefined;
    schedule: Schedule | undefined;
    warePosition: WareHousePosition | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export enum TicketStatusEnum {
    Activate = <any>"Activate", 
    Used = <any>"Used", 
    TicketRefund = <any>"TicketRefund", 
}

export class GetActivityTempDetailForEditOutput implements IGetActivityTempDetailForEditOutput {
    activityTempDetail: ActivityTempDetailEditDto | undefined;

    constructor(data?: IGetActivityTempDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.activityTempDetail = data["activityTempDetail"] ? ActivityTempDetailEditDto.fromJS(data["activityTempDetail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetActivityTempDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetActivityTempDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityTempDetail"] = this.activityTempDetail ? this.activityTempDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetActivityTempDetailForEditOutput {
        const json = this.toJSON();
        let result = new GetActivityTempDetailForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetActivityTempDetailForEditOutput {
    activityTempDetail: ActivityTempDetailEditDto | undefined;
}

export class PagedResultDtoOfActivityTempDetailListDto implements IPagedResultDtoOfActivityTempDetailListDto {
    totalCount: number | undefined;
    items: ActivityTempDetailListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfActivityTempDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ActivityTempDetailListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfActivityTempDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfActivityTempDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfActivityTempDetailListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfActivityTempDetailListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfActivityTempDetailListDto {
    totalCount: number | undefined;
    items: ActivityTempDetailListDto[] | undefined;
}

export class FileDto implements IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }

    clone(): FileDto {
        const json = this.toJSON();
        let result = new FileDto();
        result.init(json);
        return result;
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
    totalCount: number | undefined;
    items: EntityChangeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfEntityChangeListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfEntityChangeListDto {
    totalCount: number | undefined;
    items: EntityChangeListDto[] | undefined;
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: moment.Moment | undefined;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType | undefined;
    readonly changeTypeName: string | undefined;
    entityChangeSetId: number | undefined;
    id: number | undefined;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.changeTime = data["changeTime"] ? moment(data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = data["entityTypeFullName"];
            this.changeType = data["changeType"];
            (<any>this).changeTypeName = data["changeTypeName"];
            this.entityChangeSetId = data["entityChangeSetId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityChangeListDto {
        const json = this.toJSON();
        let result = new EntityChangeListDto();
        result.init(json);
        return result;
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: moment.Moment | undefined;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType | undefined;
    changeTypeName: string | undefined;
    entityChangeSetId: number | undefined;
    id: number | undefined;
}

export enum EntityChangeType {
    Created = <any>"Created", 
    Updated = <any>"Updated", 
    Deleted = <any>"Deleted", 
}

export class NameValueDto implements INameValueDto {
    name: string | undefined;
    value: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone(): NameValueDto {
        const json = this.toJSON();
        let result = new NameValueDto();
        result.init(json);
        return result;
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount: number | undefined;
    items: AuditLogListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfAuditLogListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number | undefined;
    items: AuditLogListDto[] | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
    /** 用户Id */
    userId: number | undefined;
    /** 用户名 */
    userName: string | undefined;
    /** 模拟租户Id */
    impersonatorTenantId: number | undefined;
    /** 模拟用户Id */
    impersonatorUserId: number | undefined;
    /** 服务名称 */
    serviceName: string | undefined;
    /** 方法名称 */
    methodName: string | undefined;
    /** 参数 */
    parameters: string | undefined;
    /** 执行时间 */
    executionTime: moment.Moment | undefined;
    /** 持续时间 */
    executionDuration: number | undefined;
    /** 客户端ip地址 */
    clientIpAddress: string | undefined;
    /** 客户端 */
    clientName: string | undefined;
    /** 浏览器信息 */
    browserInfo: string | undefined;
    /** 异常 */
    exception: string | undefined;
    customData: string | undefined;
    id: number | undefined;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.serviceName = data["serviceName"];
            this.methodName = data["methodName"];
            this.parameters = data["parameters"];
            this.executionTime = data["executionTime"] ? moment(data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = data["executionDuration"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.exception = data["exception"];
            this.customData = data["customData"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data; 
    }

    clone(): AuditLogListDto {
        const json = this.toJSON();
        let result = new AuditLogListDto();
        result.init(json);
        return result;
    }
}

export interface IAuditLogListDto {
    /** 用户Id */
    userId: number | undefined;
    /** 用户名 */
    userName: string | undefined;
    /** 模拟租户Id */
    impersonatorTenantId: number | undefined;
    /** 模拟用户Id */
    impersonatorUserId: number | undefined;
    /** 服务名称 */
    serviceName: string | undefined;
    /** 方法名称 */
    methodName: string | undefined;
    /** 参数 */
    parameters: string | undefined;
    /** 执行时间 */
    executionTime: moment.Moment | undefined;
    /** 持续时间 */
    executionDuration: number | undefined;
    /** 客户端ip地址 */
    clientIpAddress: string | undefined;
    /** 客户端 */
    clientName: string | undefined;
    /** 浏览器信息 */
    browserInfo: string | undefined;
    /** 异常 */
    exception: string | undefined;
    customData: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfLoginLogModel implements IPagedResultDtoOfLoginLogModel {
    totalCount: number | undefined;
    items: LoginLogModel[] | undefined;

    constructor(data?: IPagedResultDtoOfLoginLogModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(LoginLogModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLoginLogModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLoginLogModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfLoginLogModel {
        const json = this.toJSON();
        let result = new PagedResultDtoOfLoginLogModel();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfLoginLogModel {
    totalCount: number | undefined;
    items: LoginLogModel[] | undefined;
}

/** 显示登录信息 */
export class LoginLogModel implements ILoginLogModel {
    /** 用户名或邮箱 */
    userNameOrEmailAddress: string | undefined;
    /** 登录端 */
    sourceName: string | undefined;
    /** 登录端编码 */
    sourceCode: string | undefined;
    /** IP地址 */
    clientIpAddress: string | undefined;
    /** 执行时间 */
    executionTime: moment.Moment | undefined;
    /** 是否包含异常 */
    hasException: boolean | undefined;
    /** 异常 */
    exception: string | undefined;

    constructor(data?: ILoginLogModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.sourceName = data["sourceName"];
            this.sourceCode = data["sourceCode"];
            this.clientIpAddress = data["clientIpAddress"];
            this.executionTime = data["executionTime"] ? moment(data["executionTime"].toString()) : <any>undefined;
            this.hasException = data["hasException"];
            this.exception = data["exception"];
        }
    }

    static fromJS(data: any): LoginLogModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginLogModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["sourceName"] = this.sourceName;
        data["sourceCode"] = this.sourceCode;
        data["clientIpAddress"] = this.clientIpAddress;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["hasException"] = this.hasException;
        data["exception"] = this.exception;
        return data; 
    }

    clone(): LoginLogModel {
        const json = this.toJSON();
        let result = new LoginLogModel();
        result.init(json);
        return result;
    }
}

/** 显示登录信息 */
export interface ILoginLogModel {
    /** 用户名或邮箱 */
    userNameOrEmailAddress: string | undefined;
    /** 登录端 */
    sourceName: string | undefined;
    /** 登录端编码 */
    sourceCode: string | undefined;
    /** IP地址 */
    clientIpAddress: string | undefined;
    /** 执行时间 */
    executionTime: moment.Moment | undefined;
    /** 是否包含异常 */
    hasException: boolean | undefined;
    /** 异常 */
    exception: string | undefined;
}

export class CreateOrUpdateBoatInput implements ICreateOrUpdateBoatInput {
    boat: BoatEditDto;

    constructor(data?: ICreateOrUpdateBoatInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.boat = new BoatEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.boat = data["boat"] ? BoatEditDto.fromJS(data["boat"]) : new BoatEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateBoatInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateBoatInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["boat"] = this.boat ? this.boat.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateBoatInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateBoatInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateBoatInput {
    boat: BoatEditDto;
}

export class BoatEditDto implements IBoatEditDto {
    /** Id */
    id: string | undefined;
    /** BoatName */
    boatName: string;
    /** BoatCode */
    boatCode: string;
    /** SeatNumber */
    seatNumber: number;
    /** RunStatus */
    runStatus: RunStatusEnum | undefined;
    /** Leader */
    leader: string | undefined;
    /** 图片地址 */
    picture: string | undefined;
    /** LeaderMobile */
    leaderMobile: string | undefined;
    /** AuditStatus */
    auditStatus: AuditStatusEnum | undefined;
    /** 航线标识 */
    routeId: string | undefined;
    /** 标准仓数量 */
    standardNum: number | undefined;
    /** VIP仓数量 */
    vipNum: number | undefined;
    /** 包间数量 */
    compartmentNum: number | undefined;
    /** 游船呼号 */
    callName: string | undefined;
    /** IMO编号 */
    imoNumber: string | undefined;
    /** 建成日期 */
    createDate: moment.Moment | undefined;
    /** 总吨 */
    grossWeight: number | undefined;
    /** 净吨 */
    netWeight: number | undefined;
    /** 总功率 */
    grossPower: number | undefined;
    /** 船籍港 */
    registryPort: string | undefined;

    constructor(data?: IBoatEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.boatName = data["boatName"];
            this.boatCode = data["boatCode"];
            this.seatNumber = data["seatNumber"];
            this.runStatus = data["runStatus"];
            this.leader = data["leader"];
            this.picture = data["picture"];
            this.leaderMobile = data["leaderMobile"];
            this.auditStatus = data["auditStatus"];
            this.routeId = data["routeId"];
            this.standardNum = data["standardNum"];
            this.vipNum = data["vipNum"];
            this.compartmentNum = data["compartmentNum"];
            this.callName = data["callName"];
            this.imoNumber = data["imoNumber"];
            this.createDate = data["createDate"] ? moment(data["createDate"].toString()) : <any>undefined;
            this.grossWeight = data["grossWeight"];
            this.netWeight = data["netWeight"];
            this.grossPower = data["grossPower"];
            this.registryPort = data["registryPort"];
        }
    }

    static fromJS(data: any): BoatEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new BoatEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["boatName"] = this.boatName;
        data["boatCode"] = this.boatCode;
        data["seatNumber"] = this.seatNumber;
        data["runStatus"] = this.runStatus;
        data["leader"] = this.leader;
        data["picture"] = this.picture;
        data["leaderMobile"] = this.leaderMobile;
        data["auditStatus"] = this.auditStatus;
        data["routeId"] = this.routeId;
        data["standardNum"] = this.standardNum;
        data["vipNum"] = this.vipNum;
        data["compartmentNum"] = this.compartmentNum;
        data["callName"] = this.callName;
        data["imoNumber"] = this.imoNumber;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["grossWeight"] = this.grossWeight;
        data["netWeight"] = this.netWeight;
        data["grossPower"] = this.grossPower;
        data["registryPort"] = this.registryPort;
        return data; 
    }

    clone(): BoatEditDto {
        const json = this.toJSON();
        let result = new BoatEditDto();
        result.init(json);
        return result;
    }
}

export interface IBoatEditDto {
    /** Id */
    id: string | undefined;
    /** BoatName */
    boatName: string;
    /** BoatCode */
    boatCode: string;
    /** SeatNumber */
    seatNumber: number;
    /** RunStatus */
    runStatus: RunStatusEnum | undefined;
    /** Leader */
    leader: string | undefined;
    /** 图片地址 */
    picture: string | undefined;
    /** LeaderMobile */
    leaderMobile: string | undefined;
    /** AuditStatus */
    auditStatus: AuditStatusEnum | undefined;
    /** 航线标识 */
    routeId: string | undefined;
    /** 标准仓数量 */
    standardNum: number | undefined;
    /** VIP仓数量 */
    vipNum: number | undefined;
    /** 包间数量 */
    compartmentNum: number | undefined;
    /** 游船呼号 */
    callName: string | undefined;
    /** IMO编号 */
    imoNumber: string | undefined;
    /** 建成日期 */
    createDate: moment.Moment | undefined;
    /** 总吨 */
    grossWeight: number | undefined;
    /** 净吨 */
    netWeight: number | undefined;
    /** 总功率 */
    grossPower: number | undefined;
    /** 船籍港 */
    registryPort: string | undefined;
}

export class BoatListDto implements IBoatListDto {
    /** BranchId */
    branchId: string | undefined;
    /** BoatName */
    boatName: string;
    /** BoatCode */
    boatCode: string;
    /** SeatNumber */
    seatNumber: number;
    /** RunStatus */
    runStatus: RunStatusEnum | undefined;
    /** Leader */
    leader: string | undefined;
    /** LeaderMobile */
    leaderMobile: string | undefined;
    /** 图片地址 */
    picture: string | undefined;
    /** AuditStatus */
    auditStatus: AuditStatusEnum | undefined;
    /** CreatorUser */
    creatorUser: User | undefined;
    /** 航线标识 */
    routeId: string | undefined;
    route: Route | undefined;
    /** 标准仓数量 */
    standardNum: number | undefined;
    /** VIP仓数量 */
    vipNum: number | undefined;
    /** 包间数量 */
    compartmentNum: number | undefined;
    /** 游船呼号 */
    callName: string | undefined;
    /** IMO编号 */
    imoNumber: string | undefined;
    /** 建成日期 */
    createDate: moment.Moment | undefined;
    /** 总吨 */
    grossWeight: number | undefined;
    /** 净吨 */
    netWeight: number | undefined;
    /** 总功率 */
    grossPower: number | undefined;
    /** 船籍港 */
    registryPort: string | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IBoatListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.boatName = data["boatName"];
            this.boatCode = data["boatCode"];
            this.seatNumber = data["seatNumber"];
            this.runStatus = data["runStatus"];
            this.leader = data["leader"];
            this.leaderMobile = data["leaderMobile"];
            this.picture = data["picture"];
            this.auditStatus = data["auditStatus"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.routeId = data["routeId"];
            this.route = data["route"] ? Route.fromJS(data["route"]) : <any>undefined;
            this.standardNum = data["standardNum"];
            this.vipNum = data["vipNum"];
            this.compartmentNum = data["compartmentNum"];
            this.callName = data["callName"];
            this.imoNumber = data["imoNumber"];
            this.createDate = data["createDate"] ? moment(data["createDate"].toString()) : <any>undefined;
            this.grossWeight = data["grossWeight"];
            this.netWeight = data["netWeight"];
            this.grossPower = data["grossPower"];
            this.registryPort = data["registryPort"];
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BoatListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BoatListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["boatName"] = this.boatName;
        data["boatCode"] = this.boatCode;
        data["seatNumber"] = this.seatNumber;
        data["runStatus"] = this.runStatus;
        data["leader"] = this.leader;
        data["leaderMobile"] = this.leaderMobile;
        data["picture"] = this.picture;
        data["auditStatus"] = this.auditStatus;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["routeId"] = this.routeId;
        data["route"] = this.route ? this.route.toJSON() : <any>undefined;
        data["standardNum"] = this.standardNum;
        data["vipNum"] = this.vipNum;
        data["compartmentNum"] = this.compartmentNum;
        data["callName"] = this.callName;
        data["imoNumber"] = this.imoNumber;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["grossWeight"] = this.grossWeight;
        data["netWeight"] = this.netWeight;
        data["grossPower"] = this.grossPower;
        data["registryPort"] = this.registryPort;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): BoatListDto {
        const json = this.toJSON();
        let result = new BoatListDto();
        result.init(json);
        return result;
    }
}

export interface IBoatListDto {
    /** BranchId */
    branchId: string | undefined;
    /** BoatName */
    boatName: string;
    /** BoatCode */
    boatCode: string;
    /** SeatNumber */
    seatNumber: number;
    /** RunStatus */
    runStatus: RunStatusEnum | undefined;
    /** Leader */
    leader: string | undefined;
    /** LeaderMobile */
    leaderMobile: string | undefined;
    /** 图片地址 */
    picture: string | undefined;
    /** AuditStatus */
    auditStatus: AuditStatusEnum | undefined;
    /** CreatorUser */
    creatorUser: User | undefined;
    /** 航线标识 */
    routeId: string | undefined;
    route: Route | undefined;
    /** 标准仓数量 */
    standardNum: number | undefined;
    /** VIP仓数量 */
    vipNum: number | undefined;
    /** 包间数量 */
    compartmentNum: number | undefined;
    /** 游船呼号 */
    callName: string | undefined;
    /** IMO编号 */
    imoNumber: string | undefined;
    /** 建成日期 */
    createDate: moment.Moment | undefined;
    /** 总吨 */
    grossWeight: number | undefined;
    /** 净吨 */
    netWeight: number | undefined;
    /** 总功率 */
    grossPower: number | undefined;
    /** 船籍港 */
    registryPort: string | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetBoatForEditOutput implements IGetBoatForEditOutput {
    boat: BoatEditDto | undefined;

    constructor(data?: IGetBoatForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.boat = data["boat"] ? BoatEditDto.fromJS(data["boat"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBoatForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBoatForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["boat"] = this.boat ? this.boat.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetBoatForEditOutput {
        const json = this.toJSON();
        let result = new GetBoatForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetBoatForEditOutput {
    boat: BoatEditDto | undefined;
}

export class GetBoatsInput implements IGetBoatsInput {
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetBoatsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetBoatsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBoatsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetBoatsInput {
        const json = this.toJSON();
        let result = new GetBoatsInput();
        result.init(json);
        return result;
    }
}

export interface IGetBoatsInput {
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfBoatListDto implements IPagedResultDtoOfBoatListDto {
    totalCount: number | undefined;
    items: BoatListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBoatListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(BoatListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBoatListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBoatListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfBoatListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfBoatListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfBoatListDto {
    totalCount: number | undefined;
    items: BoatListDto[] | undefined;
}

export class ExcelResultDto implements IExcelResultDto {
    result: boolean | undefined;
    errorMessage: string | undefined;

    constructor(data?: IExcelResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.result = data["result"];
            this.errorMessage = data["errorMessage"];
        }
    }

    static fromJS(data: any): ExcelResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExcelResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["errorMessage"] = this.errorMessage;
        return data; 
    }

    clone(): ExcelResultDto {
        const json = this.toJSON();
        let result = new ExcelResultDto();
        result.init(json);
        return result;
    }
}

export interface IExcelResultDto {
    result: boolean | undefined;
    errorMessage: string | undefined;
}

export class CreateOrUpdateBookInput implements ICreateOrUpdateBookInput {
    book: BookEditDto;

    constructor(data?: ICreateOrUpdateBookInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.book = new BookEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.book = data["book"] ? BookEditDto.fromJS(data["book"]) : new BookEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateBookInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateBookInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["book"] = this.book ? this.book.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateBookInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateBookInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateBookInput {
    book: BookEditDto;
}

export class BookEditDto implements IBookEditDto {
    /** Id */
    id: number | undefined;
    /** 书名 */
    name: string;
    /** 书籍类型 */
    type: BookType | undefined;
    /** 发布时间 */
    publishDate: moment.Moment | undefined;
    /** 价格 */
    price: number | undefined;

    constructor(data?: IBookEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.type = data["type"];
            this.publishDate = data["publishDate"] ? moment(data["publishDate"].toString()) : <any>undefined;
            this.price = data["price"];
        }
    }

    static fromJS(data: any): BookEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new BookEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["publishDate"] = this.publishDate ? this.publishDate.toISOString() : <any>undefined;
        data["price"] = this.price;
        return data; 
    }

    clone(): BookEditDto {
        const json = this.toJSON();
        let result = new BookEditDto();
        result.init(json);
        return result;
    }
}

export interface IBookEditDto {
    /** Id */
    id: number | undefined;
    /** 书名 */
    name: string;
    /** 书籍类型 */
    type: BookType | undefined;
    /** 发布时间 */
    publishDate: moment.Moment | undefined;
    /** 价格 */
    price: number | undefined;
}

export enum BookType {
    Undefined = <any>"Undefined", 
    Advanture = <any>"Advanture", 
    Biography = <any>"Biography", 
    Dystopia = <any>"Dystopia", 
    Fantastic = <any>"Fantastic", 
    Horror = <any>"Horror", 
    Science = <any>"Science", 
    ScienceFiction = <any>"ScienceFiction", 
    Poetry = <any>"Poetry", 
}

export class BookListDto implements IBookListDto {
    /** 书名 */
    name: string;
    /** 书籍类型 */
    type: BookType | undefined;
    /** 发布时间 */
    publishDate: moment.Moment | undefined;
    /** 价格 */
    price: number | undefined;
    id: number | undefined;

    constructor(data?: IBookListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.type = data["type"];
            this.publishDate = data["publishDate"] ? moment(data["publishDate"].toString()) : <any>undefined;
            this.price = data["price"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BookListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BookListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["publishDate"] = this.publishDate ? this.publishDate.toISOString() : <any>undefined;
        data["price"] = this.price;
        data["id"] = this.id;
        return data; 
    }

    clone(): BookListDto {
        const json = this.toJSON();
        let result = new BookListDto();
        result.init(json);
        return result;
    }
}

export interface IBookListDto {
    /** 书名 */
    name: string;
    /** 书籍类型 */
    type: BookType | undefined;
    /** 发布时间 */
    publishDate: moment.Moment | undefined;
    /** 价格 */
    price: number | undefined;
    id: number | undefined;
}

export class GetBookForEditOutput implements IGetBookForEditOutput {
    book: BookEditDto | undefined;

    constructor(data?: IGetBookForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.book = data["book"] ? BookEditDto.fromJS(data["book"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBookForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBookForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["book"] = this.book ? this.book.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetBookForEditOutput {
        const json = this.toJSON();
        let result = new GetBookForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetBookForEditOutput {
    book: BookEditDto | undefined;
}

export class PagedResultDtoOfBookListDto implements IPagedResultDtoOfBookListDto {
    totalCount: number | undefined;
    items: BookListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBookListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(BookListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBookListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBookListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfBookListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfBookListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfBookListDto {
    totalCount: number | undefined;
    items: BookListDto[] | undefined;
}

export class CreateOrUpdateBranchInput implements ICreateOrUpdateBranchInput {
    branch: BranchEditDto;

    constructor(data?: ICreateOrUpdateBranchInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.branch = new BranchEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.branch = data["branch"] ? BranchEditDto.fromJS(data["branch"]) : new BranchEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateBranchInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateBranchInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateBranchInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateBranchInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateBranchInput {
    branch: BranchEditDto;
}

export class BranchEditDto implements IBranchEditDto {
    /** Id */
    id: string | undefined;
    /** ParentId */
    parentId: string | undefined;
    /** Parent */
    parent: Branch | undefined;
    /** BranchCode */
    branchCode: string;
    /** BranchName */
    branchName: string;
    /** Sort */
    sort: number | undefined;
    /** Level */
    level: number | undefined;
    /** IsEnabled */
    isEnabled: boolean | undefined;

    constructor(data?: IBranchEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? Branch.fromJS(data["parent"]) : <any>undefined;
            this.branchCode = data["branchCode"];
            this.branchName = data["branchName"];
            this.sort = data["sort"];
            this.level = data["level"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): BranchEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["sort"] = this.sort;
        data["level"] = this.level;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }

    clone(): BranchEditDto {
        const json = this.toJSON();
        let result = new BranchEditDto();
        result.init(json);
        return result;
    }
}

export interface IBranchEditDto {
    /** Id */
    id: string | undefined;
    /** ParentId */
    parentId: string | undefined;
    /** Parent */
    parent: Branch | undefined;
    /** BranchCode */
    branchCode: string;
    /** BranchName */
    branchName: string;
    /** Sort */
    sort: number | undefined;
    /** Level */
    level: number | undefined;
    /** IsEnabled */
    isEnabled: boolean | undefined;
}

export class BranchListDto implements IBranchListDto {
    /** ParentId */
    parentId: string | undefined;
    /** Parent */
    parent: Branch | undefined;
    /** BranchCode */
    branchCode: string;
    /** BranchName */
    branchName: string;
    /** Sort */
    sort: number | undefined;
    /** Level */
    level: number | undefined;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IBranchListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? Branch.fromJS(data["parent"]) : <any>undefined;
            this.branchCode = data["branchCode"];
            this.branchName = data["branchName"];
            this.sort = data["sort"];
            this.level = data["level"];
            this.isEnabled = data["isEnabled"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BranchListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["sort"] = this.sort;
        data["level"] = this.level;
        data["isEnabled"] = this.isEnabled;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): BranchListDto {
        const json = this.toJSON();
        let result = new BranchListDto();
        result.init(json);
        return result;
    }
}

export interface IBranchListDto {
    /** ParentId */
    parentId: string | undefined;
    /** Parent */
    parent: Branch | undefined;
    /** BranchCode */
    branchCode: string;
    /** BranchName */
    branchName: string;
    /** Sort */
    sort: number | undefined;
    /** Level */
    level: number | undefined;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetBranchForEditOutput implements IGetBranchForEditOutput {
    branch: BranchEditDto | undefined;

    constructor(data?: IGetBranchForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branch = data["branch"] ? BranchEditDto.fromJS(data["branch"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBranchForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBranchForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetBranchForEditOutput {
        const json = this.toJSON();
        let result = new GetBranchForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetBranchForEditOutput {
    branch: BranchEditDto | undefined;
}

export class PagedResultDtoOfBranchListDto implements IPagedResultDtoOfBranchListDto {
    totalCount: number | undefined;
    items: BranchListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBranchListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(BranchListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBranchListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBranchListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfBranchListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfBranchListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfBranchListDto {
    totalCount: number | undefined;
    items: BranchListDto[] | undefined;
}

export class CreateOrUpdateBranchUserInput implements ICreateOrUpdateBranchUserInput {
    branchUser: BranchUserEditDto;

    constructor(data?: ICreateOrUpdateBranchUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.branchUser = new BranchUserEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.branchUser = data["branchUser"] ? BranchUserEditDto.fromJS(data["branchUser"]) : new BranchUserEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateBranchUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateBranchUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchUser"] = this.branchUser ? this.branchUser.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateBranchUserInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateBranchUserInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateBranchUserInput {
    branchUser: BranchUserEditDto;
}

export class BranchUserEditDto implements IBranchUserEditDto {
    /** Id */
    id: string | undefined;
    /** BranchId */
    branchId: string | undefined;
    /** UserId */
    userId: number | undefined;

    constructor(data?: IBranchUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.branchId = data["branchId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): BranchUserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchUserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["branchId"] = this.branchId;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): BranchUserEditDto {
        const json = this.toJSON();
        let result = new BranchUserEditDto();
        result.init(json);
        return result;
    }
}

export interface IBranchUserEditDto {
    /** Id */
    id: string | undefined;
    /** BranchId */
    branchId: string | undefined;
    /** UserId */
    userId: number | undefined;
}

export class BranchUserListDto implements IBranchUserListDto {
    /** BranchId */
    branchId: string | undefined;
    /** Branch */
    branch: Branch | undefined;
    /** UserId */
    userId: number | undefined;
    /** User */
    user: User | undefined;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IBranchUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.userId = data["userId"];
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BranchUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): BranchUserListDto {
        const json = this.toJSON();
        let result = new BranchUserListDto();
        result.init(json);
        return result;
    }
}

export interface IBranchUserListDto {
    /** BranchId */
    branchId: string | undefined;
    /** Branch */
    branch: Branch | undefined;
    /** UserId */
    userId: number | undefined;
    /** User */
    user: User | undefined;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetBranchUserForEditOutput implements IGetBranchUserForEditOutput {
    branchUser: BranchUserEditDto | undefined;

    constructor(data?: IGetBranchUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchUser = data["branchUser"] ? BranchUserEditDto.fromJS(data["branchUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBranchUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBranchUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchUser"] = this.branchUser ? this.branchUser.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetBranchUserForEditOutput {
        const json = this.toJSON();
        let result = new GetBranchUserForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetBranchUserForEditOutput {
    branchUser: BranchUserEditDto | undefined;
}

export class PagedResultDtoOfBranchUserListDto implements IPagedResultDtoOfBranchUserListDto {
    totalCount: number | undefined;
    items: BranchUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBranchUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(BranchUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBranchUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBranchUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfBranchUserListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfBranchUserListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfBranchUserListDto {
    totalCount: number | undefined;
    items: BranchUserListDto[] | undefined;
}

export class CreateOrUpdateCheckRecordInput implements ICreateOrUpdateCheckRecordInput {
    checkRecord: CheckRecordEditDto;

    constructor(data?: ICreateOrUpdateCheckRecordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.checkRecord = new CheckRecordEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.checkRecord = data["checkRecord"] ? CheckRecordEditDto.fromJS(data["checkRecord"]) : new CheckRecordEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateCheckRecordInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateCheckRecordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkRecord"] = this.checkRecord ? this.checkRecord.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateCheckRecordInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateCheckRecordInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateCheckRecordInput {
    checkRecord: CheckRecordEditDto;
}

export class CheckRecordEditDto implements ICheckRecordEditDto {
    /** Id */
    id: string | undefined;
    /** Mobile */
    mobile: string;
    /** MassageType */
    massageType: MassageTypeEnum;
    /** CheckExplain */
    checkExplain: string;
    /** Captcha */
    captcha: string;
    /** IsEnabled */
    isEnabled: boolean;
    /** CheckTime */
    checkTime: moment.Moment;

    constructor(data?: ICheckRecordEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.mobile = data["mobile"];
            this.massageType = data["massageType"];
            this.checkExplain = data["checkExplain"];
            this.captcha = data["captcha"];
            this.isEnabled = data["isEnabled"];
            this.checkTime = data["checkTime"] ? moment(data["checkTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CheckRecordEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckRecordEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["mobile"] = this.mobile;
        data["massageType"] = this.massageType;
        data["checkExplain"] = this.checkExplain;
        data["captcha"] = this.captcha;
        data["isEnabled"] = this.isEnabled;
        data["checkTime"] = this.checkTime ? this.checkTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CheckRecordEditDto {
        const json = this.toJSON();
        let result = new CheckRecordEditDto();
        result.init(json);
        return result;
    }
}

export interface ICheckRecordEditDto {
    /** Id */
    id: string | undefined;
    /** Mobile */
    mobile: string;
    /** MassageType */
    massageType: MassageTypeEnum;
    /** CheckExplain */
    checkExplain: string;
    /** Captcha */
    captcha: string;
    /** IsEnabled */
    isEnabled: boolean;
    /** CheckTime */
    checkTime: moment.Moment;
}

export enum MassageTypeEnum {
    Common = <any>"Common", 
}

export class CheckRecordListDto implements ICheckRecordListDto {
    /** Mobile */
    mobile: string;
    /** MassageType */
    massageType: MassageTypeEnum;
    /** CheckExplain */
    checkExplain: string;
    /** Captcha */
    captcha: string;
    /** IsEnabled */
    isEnabled: boolean;
    /** CheckTime */
    checkTime: moment.Moment;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ICheckRecordListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mobile = data["mobile"];
            this.massageType = data["massageType"];
            this.checkExplain = data["checkExplain"];
            this.captcha = data["captcha"];
            this.isEnabled = data["isEnabled"];
            this.checkTime = data["checkTime"] ? moment(data["checkTime"].toString()) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CheckRecordListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckRecordListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mobile"] = this.mobile;
        data["massageType"] = this.massageType;
        data["checkExplain"] = this.checkExplain;
        data["captcha"] = this.captcha;
        data["isEnabled"] = this.isEnabled;
        data["checkTime"] = this.checkTime ? this.checkTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CheckRecordListDto {
        const json = this.toJSON();
        let result = new CheckRecordListDto();
        result.init(json);
        return result;
    }
}

export interface ICheckRecordListDto {
    /** Mobile */
    mobile: string;
    /** MassageType */
    massageType: MassageTypeEnum;
    /** CheckExplain */
    checkExplain: string;
    /** Captcha */
    captcha: string;
    /** IsEnabled */
    isEnabled: boolean;
    /** CheckTime */
    checkTime: moment.Moment;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetCheckRecordForEditOutput implements IGetCheckRecordForEditOutput {
    checkRecord: CheckRecordEditDto | undefined;

    constructor(data?: IGetCheckRecordForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.checkRecord = data["checkRecord"] ? CheckRecordEditDto.fromJS(data["checkRecord"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCheckRecordForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCheckRecordForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkRecord"] = this.checkRecord ? this.checkRecord.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCheckRecordForEditOutput {
        const json = this.toJSON();
        let result = new GetCheckRecordForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCheckRecordForEditOutput {
    checkRecord: CheckRecordEditDto | undefined;
}

export class PagedResultDtoOfCheckRecordListDto implements IPagedResultDtoOfCheckRecordListDto {
    totalCount: number | undefined;
    items: CheckRecordListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCheckRecordListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(CheckRecordListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCheckRecordListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCheckRecordListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCheckRecordListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCheckRecordListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCheckRecordListDto {
    totalCount: number | undefined;
    items: CheckRecordListDto[] | undefined;
}

export class CreateOrUpdateClientVersionInput implements ICreateOrUpdateClientVersionInput {
    clientVersion: ClientVersionEditDto;

    constructor(data?: ICreateOrUpdateClientVersionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.clientVersion = new ClientVersionEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.clientVersion = data["clientVersion"] ? ClientVersionEditDto.fromJS(data["clientVersion"]) : new ClientVersionEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateClientVersionInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateClientVersionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientVersion"] = this.clientVersion ? this.clientVersion.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateClientVersionInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateClientVersionInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateClientVersionInput {
    clientVersion: ClientVersionEditDto;
}

export class ClientVersionEditDto implements IClientVersionEditDto {
    /** Id */
    id: string | undefined;
    /** AppName */
    appName: string;
    /** VersionName */
    versionName: string;
    /** VersionCode */
    versionCode: string;
    /** VersionDesc */
    versionDesc: string;
    /** DeviceType */
    deviceType: DeviceTypeEnum;

    constructor(data?: IClientVersionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.appName = data["appName"];
            this.versionName = data["versionName"];
            this.versionCode = data["versionCode"];
            this.versionDesc = data["versionDesc"];
            this.deviceType = data["deviceType"];
        }
    }

    static fromJS(data: any): ClientVersionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientVersionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["appName"] = this.appName;
        data["versionName"] = this.versionName;
        data["versionCode"] = this.versionCode;
        data["versionDesc"] = this.versionDesc;
        data["deviceType"] = this.deviceType;
        return data; 
    }

    clone(): ClientVersionEditDto {
        const json = this.toJSON();
        let result = new ClientVersionEditDto();
        result.init(json);
        return result;
    }
}

export interface IClientVersionEditDto {
    /** Id */
    id: string | undefined;
    /** AppName */
    appName: string;
    /** VersionName */
    versionName: string;
    /** VersionCode */
    versionCode: string;
    /** VersionDesc */
    versionDesc: string;
    /** DeviceType */
    deviceType: DeviceTypeEnum;
}

export class GetClientVersionForEditOutput implements IGetClientVersionForEditOutput {
    clientVersion: ClientVersionEditDto | undefined;

    constructor(data?: IGetClientVersionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientVersion = data["clientVersion"] ? ClientVersionEditDto.fromJS(data["clientVersion"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetClientVersionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetClientVersionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientVersion"] = this.clientVersion ? this.clientVersion.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetClientVersionForEditOutput {
        const json = this.toJSON();
        let result = new GetClientVersionForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetClientVersionForEditOutput {
    clientVersion: ClientVersionEditDto | undefined;
}

export class PagedResultDtoOfClientVersionListDto implements IPagedResultDtoOfClientVersionListDto {
    totalCount: number | undefined;
    items: ClientVersionListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfClientVersionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ClientVersionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfClientVersionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfClientVersionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfClientVersionListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfClientVersionListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfClientVersionListDto {
    totalCount: number | undefined;
    items: ClientVersionListDto[] | undefined;
}

export class CreateOrUpdateCommonCustomerInput implements ICreateOrUpdateCommonCustomerInput {
    commonCustomer: CommonCustomerEditDto;

    constructor(data?: ICreateOrUpdateCommonCustomerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.commonCustomer = new CommonCustomerEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.commonCustomer = data["commonCustomer"] ? CommonCustomerEditDto.fromJS(data["commonCustomer"]) : new CommonCustomerEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateCommonCustomerInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateCommonCustomerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commonCustomer"] = this.commonCustomer ? this.commonCustomer.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateCommonCustomerInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateCommonCustomerInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateCommonCustomerInput {
    commonCustomer: CommonCustomerEditDto;
}

/** 的列表DTO Yozeev.BusinessLogic.CommonCustomer */
export class CommonCustomerEditDto implements ICommonCustomerEditDto {
    /** Id */
    id: string | undefined;
    /** MainCustomerId */
    mainCustomerId: string | undefined;
    /** ViceCustomerId */
    viceCustomerId: string | undefined;
    /** CustomerName */
    customerName: string;
    /** Mobile */
    mobile: string;
    /** Sex */
    sex: SexEnum | undefined;
    /** CertificatesNum */
    certificatesNum: string;
    /** VerifiableType */
    verifiableType: VerifiableTypeEnum;

    constructor(data?: ICommonCustomerEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.mainCustomerId = data["mainCustomerId"];
            this.viceCustomerId = data["viceCustomerId"];
            this.customerName = data["customerName"];
            this.mobile = data["mobile"];
            this.sex = data["sex"];
            this.certificatesNum = data["certificatesNum"];
            this.verifiableType = data["verifiableType"];
        }
    }

    static fromJS(data: any): CommonCustomerEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommonCustomerEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["mainCustomerId"] = this.mainCustomerId;
        data["viceCustomerId"] = this.viceCustomerId;
        data["customerName"] = this.customerName;
        data["mobile"] = this.mobile;
        data["sex"] = this.sex;
        data["certificatesNum"] = this.certificatesNum;
        data["verifiableType"] = this.verifiableType;
        return data; 
    }

    clone(): CommonCustomerEditDto {
        const json = this.toJSON();
        let result = new CommonCustomerEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.CommonCustomer */
export interface ICommonCustomerEditDto {
    /** Id */
    id: string | undefined;
    /** MainCustomerId */
    mainCustomerId: string | undefined;
    /** ViceCustomerId */
    viceCustomerId: string | undefined;
    /** CustomerName */
    customerName: string;
    /** Mobile */
    mobile: string;
    /** Sex */
    sex: SexEnum | undefined;
    /** CertificatesNum */
    certificatesNum: string;
    /** VerifiableType */
    verifiableType: VerifiableTypeEnum;
}

/** 的编辑DTO Yozeev.BusinessLogic.CommonCustomer */
export class CommonCustomerListDto implements ICommonCustomerListDto {
    /** BranchId */
    branchId: string | undefined;
    /** MainCustomerId */
    mainCustomerId: string | undefined;
    /** ViceCustomerId */
    viceCustomerId: string | undefined;
    /** ViceCustomer */
    viceCustomer: Customer | undefined;
    /** CustomerName */
    customerName: string;
    /** Mobile */
    mobile: string;
    /** Sex */
    sex: SexEnum | undefined;
    /** CertificatesNum */
    certificatesNum: string;
    /** VerifiableType */
    verifiableType: VerifiableTypeEnum;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ICommonCustomerListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.mainCustomerId = data["mainCustomerId"];
            this.viceCustomerId = data["viceCustomerId"];
            this.viceCustomer = data["viceCustomer"] ? Customer.fromJS(data["viceCustomer"]) : <any>undefined;
            this.customerName = data["customerName"];
            this.mobile = data["mobile"];
            this.sex = data["sex"];
            this.certificatesNum = data["certificatesNum"];
            this.verifiableType = data["verifiableType"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CommonCustomerListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommonCustomerListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["mainCustomerId"] = this.mainCustomerId;
        data["viceCustomerId"] = this.viceCustomerId;
        data["viceCustomer"] = this.viceCustomer ? this.viceCustomer.toJSON() : <any>undefined;
        data["customerName"] = this.customerName;
        data["mobile"] = this.mobile;
        data["sex"] = this.sex;
        data["certificatesNum"] = this.certificatesNum;
        data["verifiableType"] = this.verifiableType;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CommonCustomerListDto {
        const json = this.toJSON();
        let result = new CommonCustomerListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.CommonCustomer */
export interface ICommonCustomerListDto {
    /** BranchId */
    branchId: string | undefined;
    /** MainCustomerId */
    mainCustomerId: string | undefined;
    /** ViceCustomerId */
    viceCustomerId: string | undefined;
    /** ViceCustomer */
    viceCustomer: Customer | undefined;
    /** CustomerName */
    customerName: string;
    /** Mobile */
    mobile: string;
    /** Sex */
    sex: SexEnum | undefined;
    /** CertificatesNum */
    certificatesNum: string;
    /** VerifiableType */
    verifiableType: VerifiableTypeEnum;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

/** 读取可编辑的Dto */
export class GetCommonCustomerForEditOutput implements IGetCommonCustomerForEditOutput {
    commonCustomer: CommonCustomerEditDto | undefined;
    sexEnumTypeEnum: KeyValuePairOfStringAndString[] | undefined;
    verifiableTypeEnumTypeEnum: KeyValuePairOfStringAndString[] | undefined;

    constructor(data?: IGetCommonCustomerForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.commonCustomer = data["commonCustomer"] ? CommonCustomerEditDto.fromJS(data["commonCustomer"]) : <any>undefined;
            if (data["sexEnumTypeEnum"] && data["sexEnumTypeEnum"].constructor === Array) {
                this.sexEnumTypeEnum = [] as any;
                for (let item of data["sexEnumTypeEnum"])
                    this.sexEnumTypeEnum.push(KeyValuePairOfStringAndString.fromJS(item));
            }
            if (data["verifiableTypeEnumTypeEnum"] && data["verifiableTypeEnumTypeEnum"].constructor === Array) {
                this.verifiableTypeEnumTypeEnum = [] as any;
                for (let item of data["verifiableTypeEnumTypeEnum"])
                    this.verifiableTypeEnumTypeEnum.push(KeyValuePairOfStringAndString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetCommonCustomerForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCommonCustomerForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commonCustomer"] = this.commonCustomer ? this.commonCustomer.toJSON() : <any>undefined;
        if (this.sexEnumTypeEnum && this.sexEnumTypeEnum.constructor === Array) {
            data["sexEnumTypeEnum"] = [];
            for (let item of this.sexEnumTypeEnum)
                data["sexEnumTypeEnum"].push(item.toJSON());
        }
        if (this.verifiableTypeEnumTypeEnum && this.verifiableTypeEnumTypeEnum.constructor === Array) {
            data["verifiableTypeEnumTypeEnum"] = [];
            for (let item of this.verifiableTypeEnumTypeEnum)
                data["verifiableTypeEnumTypeEnum"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetCommonCustomerForEditOutput {
        const json = this.toJSON();
        let result = new GetCommonCustomerForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetCommonCustomerForEditOutput {
    commonCustomer: CommonCustomerEditDto | undefined;
    sexEnumTypeEnum: KeyValuePairOfStringAndString[] | undefined;
    verifiableTypeEnumTypeEnum: KeyValuePairOfStringAndString[] | undefined;
}

export class KeyValuePairOfStringAndString implements IKeyValuePairOfStringAndString {
    readonly key: string | undefined;
    readonly value: string | undefined;

    constructor(data?: IKeyValuePairOfStringAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).key = data["key"];
            (<any>this).value = data["value"];
        }
    }

    static fromJS(data: any): KeyValuePairOfStringAndString {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValuePairOfStringAndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }

    clone(): KeyValuePairOfStringAndString {
        const json = this.toJSON();
        let result = new KeyValuePairOfStringAndString();
        result.init(json);
        return result;
    }
}

export interface IKeyValuePairOfStringAndString {
    key: string | undefined;
    value: string | undefined;
}

export class PagedResultDtoOfCommonCustomerListDto implements IPagedResultDtoOfCommonCustomerListDto {
    totalCount: number | undefined;
    items: CommonCustomerListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCommonCustomerListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(CommonCustomerListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCommonCustomerListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCommonCustomerListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCommonCustomerListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCommonCustomerListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCommonCustomerListDto {
    totalCount: number | undefined;
    items: CommonCustomerListDto[] | undefined;
}

export class CommonLookupFindUsersInput implements ICommonLookupFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filterText: string | undefined;

    constructor(data?: ICommonLookupFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filterText = data["filterText"];
        }
    }

    static fromJS(data: any): CommonLookupFindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new CommonLookupFindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filterText"] = this.filterText;
        return data; 
    }

    clone(): CommonLookupFindUsersInput {
        const json = this.toJSON();
        let result = new CommonLookupFindUsersInput();
        result.init(json);
        return result;
    }
}

export interface ICommonLookupFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filterText: string | undefined;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount: number | undefined;
    items: NameValueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfNameValueDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfNameValueDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number | undefined;
    items: NameValueDto[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): GetDefaultEditionNameOutput {
        const json = this.toJSON();
        let result = new GetDefaultEditionNameOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfSubscribableEditionComboboxItemDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isFree = data["isFree"];
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }

    clone(): SubscribableEditionComboboxItemDto {
        const json = this.toJSON();
        let result = new SubscribableEditionComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class ListResultDtoOfComboboxItemDtoTOfInt32 implements IListResultDtoOfComboboxItemDtoTOfInt32 {
    items: ComboboxItemDtoTOfInt32[] | undefined;

    constructor(data?: IListResultDtoOfComboboxItemDtoTOfInt32) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ComboboxItemDtoTOfInt32.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfComboboxItemDtoTOfInt32 {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfComboboxItemDtoTOfInt32();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfComboboxItemDtoTOfInt32 {
        const json = this.toJSON();
        let result = new ListResultDtoOfComboboxItemDtoTOfInt32();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfComboboxItemDtoTOfInt32 {
    items: ComboboxItemDtoTOfInt32[] | undefined;
}

export class ComboboxItemDtoTOfInt32 implements IComboboxItemDtoTOfInt32 {
    value: number | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;

    constructor(data?: IComboboxItemDtoTOfInt32) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDtoTOfInt32 {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDtoTOfInt32();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }

    clone(): ComboboxItemDtoTOfInt32 {
        const json = this.toJSON();
        let result = new ComboboxItemDtoTOfInt32();
        result.init(json);
        return result;
    }
}

export interface IComboboxItemDtoTOfInt32 {
    value: number | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class CustomerEditDto implements ICustomerEditDto {
    /** Id */
    id: string | undefined;
    /** CustomerName */
    customerName: string;
    /** Mobile */
    mobile: string;
    /** LoginPwd */
    loginPwd: string | undefined;
    /** Sex */
    sex: SexEnum | undefined;
    /** Country */
    country: string | undefined;
    /** Province */
    province: string | undefined;
    /** City */
    city: string | undefined;
    /** County */
    county: string | undefined;
    /** CertificatesNum */
    certificatesNum: string;
    /** VerifiableType */
    verifiableType: VerifiableTypeEnum;
    /** Job */
    job: string | undefined;
    /** OpenID */
    openID: string | undefined;
    /** Photo */
    photo: string | undefined;
    /** DateOfBirth */
    dateOfBirth: moment.Moment | undefined;
    dateOfBirthStr: string | undefined;

    constructor(data?: ICustomerEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.customerName = data["customerName"];
            this.mobile = data["mobile"];
            this.loginPwd = data["loginPwd"];
            this.sex = data["sex"];
            this.country = data["country"];
            this.province = data["province"];
            this.city = data["city"];
            this.county = data["county"];
            this.certificatesNum = data["certificatesNum"];
            this.verifiableType = data["verifiableType"];
            this.job = data["job"];
            this.openID = data["openID"];
            this.photo = data["photo"];
            this.dateOfBirth = data["dateOfBirth"] ? moment(data["dateOfBirth"].toString()) : <any>undefined;
            this.dateOfBirthStr = data["dateOfBirthStr"];
        }
    }

    static fromJS(data: any): CustomerEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerName"] = this.customerName;
        data["mobile"] = this.mobile;
        data["loginPwd"] = this.loginPwd;
        data["sex"] = this.sex;
        data["country"] = this.country;
        data["province"] = this.province;
        data["city"] = this.city;
        data["county"] = this.county;
        data["certificatesNum"] = this.certificatesNum;
        data["verifiableType"] = this.verifiableType;
        data["job"] = this.job;
        data["openID"] = this.openID;
        data["photo"] = this.photo;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["dateOfBirthStr"] = this.dateOfBirthStr;
        return data; 
    }

    clone(): CustomerEditDto {
        const json = this.toJSON();
        let result = new CustomerEditDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerEditDto {
    /** Id */
    id: string | undefined;
    /** CustomerName */
    customerName: string;
    /** Mobile */
    mobile: string;
    /** LoginPwd */
    loginPwd: string | undefined;
    /** Sex */
    sex: SexEnum | undefined;
    /** Country */
    country: string | undefined;
    /** Province */
    province: string | undefined;
    /** City */
    city: string | undefined;
    /** County */
    county: string | undefined;
    /** CertificatesNum */
    certificatesNum: string;
    /** VerifiableType */
    verifiableType: VerifiableTypeEnum;
    /** Job */
    job: string | undefined;
    /** OpenID */
    openID: string | undefined;
    /** Photo */
    photo: string | undefined;
    /** DateOfBirth */
    dateOfBirth: moment.Moment | undefined;
    dateOfBirthStr: string | undefined;
}

export class AjaxResult implements IAjaxResult {
    isSuccess: boolean | undefined;
    message: string | undefined;
    absoluteUri: string | undefined;
    isException: boolean | undefined;
    primaryId: any | undefined;
    data: any | undefined;

    constructor(data?: IAjaxResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isSuccess = data["isSuccess"];
            this.message = data["message"];
            this.absoluteUri = data["absoluteUri"];
            this.isException = data["isException"];
            this.primaryId = data["primaryId"];
            this.data = data["data"];
        }
    }

    static fromJS(data: any): AjaxResult {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["message"] = this.message;
        data["absoluteUri"] = this.absoluteUri;
        data["isException"] = this.isException;
        data["primaryId"] = this.primaryId;
        data["data"] = this.data;
        return data; 
    }

    clone(): AjaxResult {
        const json = this.toJSON();
        let result = new AjaxResult();
        result.init(json);
        return result;
    }
}

export interface IAjaxResult {
    isSuccess: boolean | undefined;
    message: string | undefined;
    absoluteUri: string | undefined;
    isException: boolean | undefined;
    primaryId: any | undefined;
    data: any | undefined;
}

export class CreateOrUpdateCustomerInput implements ICreateOrUpdateCustomerInput {
    /** 游客信息编辑Dto */
    customer: CustomerEditDto;
    /** 设置随机密码 */
    setRandomPassword: boolean | undefined;
    /** 有错误时，操作选择，默认提示报错，1表示替换该游客信息，2表是跳过该游客信息 */
    operation: string | undefined;

    constructor(data?: ICreateOrUpdateCustomerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.customer = new CustomerEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.customer = data["customer"] ? CustomerEditDto.fromJS(data["customer"]) : new CustomerEditDto();
            this.setRandomPassword = data["setRandomPassword"];
            this.operation = data["operation"];
        }
    }

    static fromJS(data: any): CreateOrUpdateCustomerInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateCustomerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["setRandomPassword"] = this.setRandomPassword;
        data["operation"] = this.operation;
        return data; 
    }

    clone(): CreateOrUpdateCustomerInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateCustomerInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateCustomerInput {
    /** 游客信息编辑Dto */
    customer: CustomerEditDto;
    /** 设置随机密码 */
    setRandomPassword: boolean | undefined;
    /** 有错误时，操作选择，默认提示报错，1表示替换该游客信息，2表是跳过该游客信息 */
    operation: string | undefined;
}

/** 判断客户是否已经存在的dto */
export class CustomerExistsDto implements ICustomerExistsDto {
    exist: boolean | undefined;
    customer: CustomerEditDto | undefined;

    constructor(data?: ICustomerExistsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.exist = data["exist"];
            this.customer = data["customer"] ? CustomerEditDto.fromJS(data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerExistsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerExistsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exist"] = this.exist;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CustomerExistsDto {
        const json = this.toJSON();
        let result = new CustomerExistsDto();
        result.init(json);
        return result;
    }
}

/** 判断客户是否已经存在的dto */
export interface ICustomerExistsDto {
    exist: boolean | undefined;
    customer: CustomerEditDto | undefined;
}

export class CustomerListDto implements ICustomerListDto {
    /** BranchId */
    branchId: string | undefined;
    /** CustomerName */
    customerName: string;
    /** Mobile */
    mobile: string;
    /** Sex */
    sex: SexEnum | undefined;
    /** Country */
    country: string | undefined;
    /** Province */
    province: string | undefined;
    /** City */
    city: string | undefined;
    /** County */
    county: string | undefined;
    /** CertificatesNum */
    certificatesNum: string;
    /** VerifiableType */
    verifiableType: VerifiableTypeEnum;
    /** Job */
    job: string | undefined;
    /** OpenID */
    openID: string | undefined;
    /** Photo */
    photo: string | undefined;
    /** DateOfBirth */
    dateOfBirth: moment.Moment | undefined;
    readonly dateOfBirthStr: string | undefined;
    readonly creationTimeStr: string | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ICustomerListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.customerName = data["customerName"];
            this.mobile = data["mobile"];
            this.sex = data["sex"];
            this.country = data["country"];
            this.province = data["province"];
            this.city = data["city"];
            this.county = data["county"];
            this.certificatesNum = data["certificatesNum"];
            this.verifiableType = data["verifiableType"];
            this.job = data["job"];
            this.openID = data["openID"];
            this.photo = data["photo"];
            this.dateOfBirth = data["dateOfBirth"] ? moment(data["dateOfBirth"].toString()) : <any>undefined;
            (<any>this).dateOfBirthStr = data["dateOfBirthStr"];
            (<any>this).creationTimeStr = data["creationTimeStr"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CustomerListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["customerName"] = this.customerName;
        data["mobile"] = this.mobile;
        data["sex"] = this.sex;
        data["country"] = this.country;
        data["province"] = this.province;
        data["city"] = this.city;
        data["county"] = this.county;
        data["certificatesNum"] = this.certificatesNum;
        data["verifiableType"] = this.verifiableType;
        data["job"] = this.job;
        data["openID"] = this.openID;
        data["photo"] = this.photo;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["dateOfBirthStr"] = this.dateOfBirthStr;
        data["creationTimeStr"] = this.creationTimeStr;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CustomerListDto {
        const json = this.toJSON();
        let result = new CustomerListDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerListDto {
    /** BranchId */
    branchId: string | undefined;
    /** CustomerName */
    customerName: string;
    /** Mobile */
    mobile: string;
    /** Sex */
    sex: SexEnum | undefined;
    /** Country */
    country: string | undefined;
    /** Province */
    province: string | undefined;
    /** City */
    city: string | undefined;
    /** County */
    county: string | undefined;
    /** CertificatesNum */
    certificatesNum: string;
    /** VerifiableType */
    verifiableType: VerifiableTypeEnum;
    /** Job */
    job: string | undefined;
    /** OpenID */
    openID: string | undefined;
    /** Photo */
    photo: string | undefined;
    /** DateOfBirth */
    dateOfBirth: moment.Moment | undefined;
    dateOfBirthStr: string | undefined;
    creationTimeStr: string | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetCustomerForEditOutput implements IGetCustomerForEditOutput {
    customer: CustomerEditDto | undefined;

    constructor(data?: IGetCustomerForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customer = data["customer"] ? CustomerEditDto.fromJS(data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCustomerForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCustomerForEditOutput {
        const json = this.toJSON();
        let result = new GetCustomerForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCustomerForEditOutput {
    customer: CustomerEditDto | undefined;
}

export class GetCustomersInput implements IGetCustomersInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetCustomersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetCustomersInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetCustomersInput {
        const json = this.toJSON();
        let result = new GetCustomersInput();
        result.init(json);
        return result;
    }
}

export interface IGetCustomersInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCustomerListDto implements IPagedResultDtoOfCustomerListDto {
    totalCount: number | undefined;
    items: CustomerListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCustomerListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(CustomerListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomerListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomerListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCustomerListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCustomerListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCustomerListDto {
    totalCount: number | undefined;
    items: CustomerListDto[] | undefined;
}

export class UploadUserPictureResultDto implements IUploadUserPictureResultDto {
    uri: string | undefined;

    constructor(data?: IUploadUserPictureResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.uri = data["uri"];
        }
    }

    static fromJS(data: any): UploadUserPictureResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UploadUserPictureResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uri"] = this.uri;
        return data; 
    }

    clone(): UploadUserPictureResultDto {
        const json = this.toJSON();
        let result = new UploadUserPictureResultDto();
        result.init(json);
        return result;
    }
}

export interface IUploadUserPictureResultDto {
    uri: string | undefined;
}

export class UploadUserPictureDto implements IUploadUserPictureDto {
    pictureString: string | undefined;

    constructor(data?: IUploadUserPictureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pictureString = data["pictureString"];
        }
    }

    static fromJS(data: any): UploadUserPictureDto {
        data = typeof data === 'object' ? data : {};
        let result = new UploadUserPictureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pictureString"] = this.pictureString;
        return data; 
    }

    clone(): UploadUserPictureDto {
        const json = this.toJSON();
        let result = new UploadUserPictureDto();
        result.init(json);
        return result;
    }
}

export interface IUploadUserPictureDto {
    pictureString: string | undefined;
}

export class CreateOrUpdateDateDictionaryInput implements ICreateOrUpdateDateDictionaryInput {
    dateDictionary: DateDictionaryEditDto;

    constructor(data?: ICreateOrUpdateDateDictionaryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dateDictionary = new DateDictionaryEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.dateDictionary = data["dateDictionary"] ? DateDictionaryEditDto.fromJS(data["dateDictionary"]) : new DateDictionaryEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateDateDictionaryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateDateDictionaryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateDictionary"] = this.dateDictionary ? this.dateDictionary.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateDateDictionaryInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateDateDictionaryInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateDateDictionaryInput {
    dateDictionary: DateDictionaryEditDto;
}

export class DateDictionaryEditDto implements IDateDictionaryEditDto {
    /** Id */
    id: string | undefined;
    /** DictionaryName */
    dictionaryName: string;
    /** DictionaryCode */
    dictionaryCode: string;
    /** Sort */
    sort: number;
    /** ParentId */
    parentId: string | undefined;
    /** Parent */
    parent: DateDictionary | undefined;
    /** Explain */
    explain: string;

    constructor(data?: IDateDictionaryEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.dictionaryName = data["dictionaryName"];
            this.dictionaryCode = data["dictionaryCode"];
            this.sort = data["sort"];
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? DateDictionary.fromJS(data["parent"]) : <any>undefined;
            this.explain = data["explain"];
        }
    }

    static fromJS(data: any): DateDictionaryEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateDictionaryEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dictionaryName"] = this.dictionaryName;
        data["dictionaryCode"] = this.dictionaryCode;
        data["sort"] = this.sort;
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["explain"] = this.explain;
        return data; 
    }

    clone(): DateDictionaryEditDto {
        const json = this.toJSON();
        let result = new DateDictionaryEditDto();
        result.init(json);
        return result;
    }
}

export interface IDateDictionaryEditDto {
    /** Id */
    id: string | undefined;
    /** DictionaryName */
    dictionaryName: string;
    /** DictionaryCode */
    dictionaryCode: string;
    /** Sort */
    sort: number;
    /** ParentId */
    parentId: string | undefined;
    /** Parent */
    parent: DateDictionary | undefined;
    /** Explain */
    explain: string;
}

export class DateDictionary implements IDateDictionary {
    dictionaryName: string;
    dictionaryCode: string;
    sort: number;
    parentId: string | undefined;
    parent: DateDictionary | undefined;
    explain: string;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IDateDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dictionaryName = data["dictionaryName"];
            this.dictionaryCode = data["dictionaryCode"];
            this.sort = data["sort"];
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? DateDictionary.fromJS(data["parent"]) : <any>undefined;
            this.explain = data["explain"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DateDictionary {
        data = typeof data === 'object' ? data : {};
        let result = new DateDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dictionaryName"] = this.dictionaryName;
        data["dictionaryCode"] = this.dictionaryCode;
        data["sort"] = this.sort;
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["explain"] = this.explain;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DateDictionary {
        const json = this.toJSON();
        let result = new DateDictionary();
        result.init(json);
        return result;
    }
}

export interface IDateDictionary {
    dictionaryName: string;
    dictionaryCode: string;
    sort: number;
    parentId: string | undefined;
    parent: DateDictionary | undefined;
    explain: string;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class DateDictionaryListDto implements IDateDictionaryListDto {
    /** DictionaryName */
    dictionaryName: string;
    /** DictionaryCode */
    dictionaryCode: string;
    /** Sort */
    sort: number;
    /** ParentId */
    parentId: string | undefined;
    /** Parent */
    parent: DateDictionary | undefined;
    /** Explain */
    explain: string;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IDateDictionaryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dictionaryName = data["dictionaryName"];
            this.dictionaryCode = data["dictionaryCode"];
            this.sort = data["sort"];
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? DateDictionary.fromJS(data["parent"]) : <any>undefined;
            this.explain = data["explain"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DateDictionaryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateDictionaryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dictionaryName"] = this.dictionaryName;
        data["dictionaryCode"] = this.dictionaryCode;
        data["sort"] = this.sort;
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["explain"] = this.explain;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DateDictionaryListDto {
        const json = this.toJSON();
        let result = new DateDictionaryListDto();
        result.init(json);
        return result;
    }
}

export interface IDateDictionaryListDto {
    /** DictionaryName */
    dictionaryName: string;
    /** DictionaryCode */
    dictionaryCode: string;
    /** Sort */
    sort: number;
    /** ParentId */
    parentId: string | undefined;
    /** Parent */
    parent: DateDictionary | undefined;
    /** Explain */
    explain: string;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetDateDictionaryForEditOutput implements IGetDateDictionaryForEditOutput {
    dateDictionary: DateDictionaryEditDto | undefined;

    constructor(data?: IGetDateDictionaryForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateDictionary = data["dateDictionary"] ? DateDictionaryEditDto.fromJS(data["dateDictionary"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetDateDictionaryForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDateDictionaryForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateDictionary"] = this.dateDictionary ? this.dateDictionary.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDateDictionaryForEditOutput {
        const json = this.toJSON();
        let result = new GetDateDictionaryForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDateDictionaryForEditOutput {
    dateDictionary: DateDictionaryEditDto | undefined;
}

export class PagedResultDtoOfDateDictionaryListDto implements IPagedResultDtoOfDateDictionaryListDto {
    totalCount: number | undefined;
    items: DateDictionaryListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDateDictionaryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(DateDictionaryListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDateDictionaryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDateDictionaryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDateDictionaryListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDateDictionaryListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDateDictionaryListDto {
    totalCount: number | undefined;
    items: DateDictionaryListDto[] | undefined;
}

export class CreateOrUpdateDeviceInput implements ICreateOrUpdateDeviceInput {
    device: DeviceEditDto;

    constructor(data?: ICreateOrUpdateDeviceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.device = new DeviceEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.device = data["device"] ? DeviceEditDto.fromJS(data["device"]) : new DeviceEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateDeviceInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateDeviceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateDeviceInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateDeviceInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateDeviceInput {
    device: DeviceEditDto;
}

export class DeviceEditDto implements IDeviceEditDto {
    /** Id */
    id: string | undefined;
    /** TicketStationId */
    ticketStationId: string | undefined;
    /** DeviceCode */
    deviceCode: string;
    /** DeviceName */
    deviceName: string;
    /** IPAddress */
    ipAddress: string;
    /** Port */
    port: string;
    /** DeviceType */
    deviceType: DeviceTypeEnum;
    /** SecretKey */
    secretKey: string;
    /** IsEnabled */
    isEnabled: boolean;
    /** DeviceStatus */
    deviceStatus: DeviceStatusEnum;
    /** 访问类型名称列表 */
    verifiableTypes: VerifiableTypeEnum[] | undefined;

    constructor(data?: IDeviceEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ticketStationId = data["ticketStationId"];
            this.deviceCode = data["deviceCode"];
            this.deviceName = data["deviceName"];
            this.ipAddress = data["ipAddress"];
            this.port = data["port"];
            this.deviceType = data["deviceType"];
            this.secretKey = data["secretKey"];
            this.isEnabled = data["isEnabled"];
            this.deviceStatus = data["deviceStatus"];
            if (data["verifiableTypes"] && data["verifiableTypes"].constructor === Array) {
                this.verifiableTypes = [] as any;
                for (let item of data["verifiableTypes"])
                    this.verifiableTypes.push(item);
            }
        }
    }

    static fromJS(data: any): DeviceEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketStationId"] = this.ticketStationId;
        data["deviceCode"] = this.deviceCode;
        data["deviceName"] = this.deviceName;
        data["ipAddress"] = this.ipAddress;
        data["port"] = this.port;
        data["deviceType"] = this.deviceType;
        data["secretKey"] = this.secretKey;
        data["isEnabled"] = this.isEnabled;
        data["deviceStatus"] = this.deviceStatus;
        if (this.verifiableTypes && this.verifiableTypes.constructor === Array) {
            data["verifiableTypes"] = [];
            for (let item of this.verifiableTypes)
                data["verifiableTypes"].push(item);
        }
        return data; 
    }

    clone(): DeviceEditDto {
        const json = this.toJSON();
        let result = new DeviceEditDto();
        result.init(json);
        return result;
    }
}

export interface IDeviceEditDto {
    /** Id */
    id: string | undefined;
    /** TicketStationId */
    ticketStationId: string | undefined;
    /** DeviceCode */
    deviceCode: string;
    /** DeviceName */
    deviceName: string;
    /** IPAddress */
    ipAddress: string;
    /** Port */
    port: string;
    /** DeviceType */
    deviceType: DeviceTypeEnum;
    /** SecretKey */
    secretKey: string;
    /** IsEnabled */
    isEnabled: boolean;
    /** DeviceStatus */
    deviceStatus: DeviceStatusEnum;
    /** 访问类型名称列表 */
    verifiableTypes: VerifiableTypeEnum[] | undefined;
}

export class DeviceListDto implements IDeviceListDto {
    /** BranchId */
    branchId: string | undefined;
    /** TicketStationId */
    ticketStationId: string | undefined;
    /** DeviceCode */
    deviceCode: string;
    /** DeviceName */
    deviceName: string;
    /** IPAddress */
    ipAddress: string;
    /** Port */
    port: string;
    /** DeviceType */
    deviceType: DeviceTypeEnum;
    /** SecretKey */
    secretKey: string;
    /** IsEnabled */
    isEnabled: boolean;
    /** DeviceStatus */
    deviceStatus: DeviceStatusEnum;
    /** 访问类型名称列表 */
    verifiableTypes: VerifiableTypeEnum[] | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IDeviceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketStationId = data["ticketStationId"];
            this.deviceCode = data["deviceCode"];
            this.deviceName = data["deviceName"];
            this.ipAddress = data["ipAddress"];
            this.port = data["port"];
            this.deviceType = data["deviceType"];
            this.secretKey = data["secretKey"];
            this.isEnabled = data["isEnabled"];
            this.deviceStatus = data["deviceStatus"];
            if (data["verifiableTypes"] && data["verifiableTypes"].constructor === Array) {
                this.verifiableTypes = [] as any;
                for (let item of data["verifiableTypes"])
                    this.verifiableTypes.push(item);
            }
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DeviceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketStationId"] = this.ticketStationId;
        data["deviceCode"] = this.deviceCode;
        data["deviceName"] = this.deviceName;
        data["ipAddress"] = this.ipAddress;
        data["port"] = this.port;
        data["deviceType"] = this.deviceType;
        data["secretKey"] = this.secretKey;
        data["isEnabled"] = this.isEnabled;
        data["deviceStatus"] = this.deviceStatus;
        if (this.verifiableTypes && this.verifiableTypes.constructor === Array) {
            data["verifiableTypes"] = [];
            for (let item of this.verifiableTypes)
                data["verifiableTypes"].push(item);
        }
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DeviceListDto {
        const json = this.toJSON();
        let result = new DeviceListDto();
        result.init(json);
        return result;
    }
}

export interface IDeviceListDto {
    /** BranchId */
    branchId: string | undefined;
    /** TicketStationId */
    ticketStationId: string | undefined;
    /** DeviceCode */
    deviceCode: string;
    /** DeviceName */
    deviceName: string;
    /** IPAddress */
    ipAddress: string;
    /** Port */
    port: string;
    /** DeviceType */
    deviceType: DeviceTypeEnum;
    /** SecretKey */
    secretKey: string;
    /** IsEnabled */
    isEnabled: boolean;
    /** DeviceStatus */
    deviceStatus: DeviceStatusEnum;
    /** 访问类型名称列表 */
    verifiableTypes: VerifiableTypeEnum[] | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetDeviceForEditOutput implements IGetDeviceForEditOutput {
    device: DeviceEditDto | undefined;

    constructor(data?: IGetDeviceForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.device = data["device"] ? DeviceEditDto.fromJS(data["device"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetDeviceForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDeviceForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDeviceForEditOutput {
        const json = this.toJSON();
        let result = new GetDeviceForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDeviceForEditOutput {
    device: DeviceEditDto | undefined;
}

/** 证件类型Dto */
export class IdentityTypeDto implements IIdentityTypeDto {
    identityType: VerifiableTypeEnum | undefined;
    identityName: string | undefined;

    constructor(data?: IIdentityTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.identityType = data["identityType"];
            this.identityName = data["identityName"];
        }
    }

    static fromJS(data: any): IdentityTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identityType"] = this.identityType;
        data["identityName"] = this.identityName;
        return data; 
    }

    clone(): IdentityTypeDto {
        const json = this.toJSON();
        let result = new IdentityTypeDto();
        result.init(json);
        return result;
    }
}

/** 证件类型Dto */
export interface IIdentityTypeDto {
    identityType: VerifiableTypeEnum | undefined;
    identityName: string | undefined;
}

export class GetDevicesInput implements IGetDevicesInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetDevicesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetDevicesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDevicesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetDevicesInput {
        const json = this.toJSON();
        let result = new GetDevicesInput();
        result.init(json);
        return result;
    }
}

export interface IGetDevicesInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfDeviceListDto implements IPagedResultDtoOfDeviceListDto {
    totalCount: number | undefined;
    items: DeviceListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDeviceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(DeviceListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDeviceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDeviceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDeviceListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDeviceListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDeviceListDto {
    totalCount: number | undefined;
    items: DeviceListDto[] | undefined;
}

export class HeartBeatResult implements IHeartBeatResult {
    status: number | undefined;

    constructor(data?: IHeartBeatResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
        }
    }

    static fromJS(data: any): HeartBeatResult {
        data = typeof data === 'object' ? data : {};
        let result = new HeartBeatResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        return data; 
    }

    clone(): HeartBeatResult {
        const json = this.toJSON();
        let result = new HeartBeatResult();
        result.init(json);
        return result;
    }
}

export interface IHeartBeatResult {
    status: number | undefined;
}

export class CreateOrUpdateEditionDto implements ICreateOrUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];

    constructor(data?: ICreateOrUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : new EditionEditDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateOrUpdateEditionDto {
        const json = this.toJSON();
        let result = new CreateOrUpdateEditionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export class EditionEditDto implements IEditionEditDto {
    id: number | undefined;
    displayName: string;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }

    clone(): EditionEditDto {
        const json = this.toJSON();
        let result = new EditionEditDto();
        result.init(json);
        return result;
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition: EditionEditDto | undefined;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [] as any;
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetEditionEditOutput {
        const json = this.toJSON();
        let result = new GetEditionEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto | undefined;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto | undefined;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? FeatureInputTypeDto.fromJS(data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data; 
    }

    clone(): FlatFeatureDto {
        const json = this.toJSON();
        let result = new FlatFeatureDto();
        result.init(json);
        return result;
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;
    itemSource: LocalizableComboboxItemSourceDto | undefined;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
            this.itemSource = data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data; 
    }

    clone(): FeatureInputTypeDto {
        const json = this.toJSON();
        let result = new FeatureInputTypeDto();
        result.init(json);
        return result;
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;
    itemSource: LocalizableComboboxItemSourceDto | undefined;
}

export class IValueValidator implements IIValueValidator {
    readonly name: string | undefined;
    readonly attributes: { [key: string] : any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).name = data["name"];
            if (data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        (<any>this).attributes[key] = data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        return data; 
    }

    clone(): IValueValidator {
        const json = this.toJSON();
        let result = new IValueValidator();
        result.init(json);
        return result;
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): LocalizableComboboxItemSourceDto {
        const json = this.toJSON();
        let result = new LocalizableComboboxItemSourceDto();
        result.init(json);
        return result;
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data; 
    }

    clone(): LocalizableComboboxItemDto {
        const json = this.toJSON();
        let result = new LocalizableComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfEditionListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfEditionListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;
}

export class EditionListDto implements IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): EditionListDto {
        const json = this.toJSON();
        let result = new EditionListDto();
        result.init(json);
        return result;
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class MoveTenantsToAnotherEditionDto implements IMoveTenantsToAnotherEditionDto {
    sourceEditionId: number | undefined;
    targetEditionId: number | undefined;

    constructor(data?: IMoveTenantsToAnotherEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceEditionId = data["sourceEditionId"];
            this.targetEditionId = data["targetEditionId"];
        }
    }

    static fromJS(data: any): MoveTenantsToAnotherEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveTenantsToAnotherEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceEditionId"] = this.sourceEditionId;
        data["targetEditionId"] = this.targetEditionId;
        return data; 
    }

    clone(): MoveTenantsToAnotherEditionDto {
        const json = this.toJSON();
        let result = new MoveTenantsToAnotherEditionDto();
        result.init(json);
        return result;
    }
}

export interface IMoveTenantsToAnotherEditionDto {
    sourceEditionId: number | undefined;
    targetEditionId: number | undefined;
}

export class CreateOrUpdateGateRecordInput implements ICreateOrUpdateGateRecordInput {
    gateRecord: GateRecordEditDto;

    constructor(data?: ICreateOrUpdateGateRecordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.gateRecord = new GateRecordEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.gateRecord = data["gateRecord"] ? GateRecordEditDto.fromJS(data["gateRecord"]) : new GateRecordEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateGateRecordInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateGateRecordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateRecord"] = this.gateRecord ? this.gateRecord.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateGateRecordInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateGateRecordInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateGateRecordInput {
    gateRecord: GateRecordEditDto;
}

export class GateRecordEditDto implements IGateRecordEditDto {
    /** Id */
    id: string | undefined;
    /** DeviceId */
    deviceId: string;
    /** VerifiableType */
    verifiableType: VerifiableTypeEnum;
    /** VerifiableValue */
    verifiableValue: string;
    /** ReturnState */
    returnState: ReturnStateEnum;
    /** ReturnInfo */
    returnInfo: string;

    constructor(data?: IGateRecordEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.deviceId = data["deviceId"];
            this.verifiableType = data["verifiableType"];
            this.verifiableValue = data["verifiableValue"];
            this.returnState = data["returnState"];
            this.returnInfo = data["returnInfo"];
        }
    }

    static fromJS(data: any): GateRecordEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GateRecordEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceId"] = this.deviceId;
        data["verifiableType"] = this.verifiableType;
        data["verifiableValue"] = this.verifiableValue;
        data["returnState"] = this.returnState;
        data["returnInfo"] = this.returnInfo;
        return data; 
    }

    clone(): GateRecordEditDto {
        const json = this.toJSON();
        let result = new GateRecordEditDto();
        result.init(json);
        return result;
    }
}

export interface IGateRecordEditDto {
    /** Id */
    id: string | undefined;
    /** DeviceId */
    deviceId: string;
    /** VerifiableType */
    verifiableType: VerifiableTypeEnum;
    /** VerifiableValue */
    verifiableValue: string;
    /** ReturnState */
    returnState: ReturnStateEnum;
    /** ReturnInfo */
    returnInfo: string;
}

export class GateRecordListDto implements IGateRecordListDto {
    /** BranchId */
    branchId: string | undefined;
    /** DeviceId */
    deviceId: string;
    /** VerifiableType */
    verifiableType: VerifiableTypeEnum;
    /** VerifiableValue */
    verifiableValue: string;
    /** ReturnState */
    returnState: ReturnStateEnum;
    /** ReturnInfo */
    returnInfo: string;
    /** Device */
    device: Device | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGateRecordListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.deviceId = data["deviceId"];
            this.verifiableType = data["verifiableType"];
            this.verifiableValue = data["verifiableValue"];
            this.returnState = data["returnState"];
            this.returnInfo = data["returnInfo"];
            this.device = data["device"] ? Device.fromJS(data["device"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GateRecordListDto {
        data = typeof data === 'object' ? data : {};
        let result = new GateRecordListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["deviceId"] = this.deviceId;
        data["verifiableType"] = this.verifiableType;
        data["verifiableValue"] = this.verifiableValue;
        data["returnState"] = this.returnState;
        data["returnInfo"] = this.returnInfo;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GateRecordListDto {
        const json = this.toJSON();
        let result = new GateRecordListDto();
        result.init(json);
        return result;
    }
}

export interface IGateRecordListDto {
    /** BranchId */
    branchId: string | undefined;
    /** DeviceId */
    deviceId: string;
    /** VerifiableType */
    verifiableType: VerifiableTypeEnum;
    /** VerifiableValue */
    verifiableValue: string;
    /** ReturnState */
    returnState: ReturnStateEnum;
    /** ReturnInfo */
    returnInfo: string;
    /** Device */
    device: Device | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetGateRecordForEditOutput implements IGetGateRecordForEditOutput {
    gateRecord: GateRecordEditDto | undefined;

    constructor(data?: IGetGateRecordForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gateRecord = data["gateRecord"] ? GateRecordEditDto.fromJS(data["gateRecord"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetGateRecordForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGateRecordForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateRecord"] = this.gateRecord ? this.gateRecord.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetGateRecordForEditOutput {
        const json = this.toJSON();
        let result = new GetGateRecordForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetGateRecordForEditOutput {
    gateRecord: GateRecordEditDto | undefined;
}

export class PagedResultDtoOfGateRecordListDto implements IPagedResultDtoOfGateRecordListDto {
    totalCount: number | undefined;
    items: GateRecordListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGateRecordListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(GateRecordListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGateRecordListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGateRecordListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGateRecordListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGateRecordListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGateRecordListDto {
    totalCount: number | undefined;
    items: GateRecordListDto[] | undefined;
}

export class RecurringJobInput implements IRecurringJobInput {
    jobId: string[] | undefined;

    constructor(data?: IRecurringJobInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["jobId"] && data["jobId"].constructor === Array) {
                this.jobId = [] as any;
                for (let item of data["jobId"])
                    this.jobId.push(item);
            }
        }
    }

    static fromJS(data: any): RecurringJobInput {
        data = typeof data === 'object' ? data : {};
        let result = new RecurringJobInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.jobId && this.jobId.constructor === Array) {
            data["jobId"] = [];
            for (let item of this.jobId)
                data["jobId"].push(item);
        }
        return data; 
    }

    clone(): RecurringJobInput {
        const json = this.toJSON();
        let result = new RecurringJobInput();
        result.init(json);
        return result;
    }
}

export interface IRecurringJobInput {
    jobId: string[] | undefined;
}

export enum JobState {
    Plan = <any>"Plan", 
    Runing = <any>"Runing", 
    Success = <any>"Success", 
    Faile = <any>"Faile", 
    Delete = <any>"Delete", 
    Waiting = <any>"Waiting", 
    Enqueued = <any>"Enqueued", 
    Fetched = <any>"Fetched", 
    EnqueuedJob = <any>"EnqueuedJob", 
}

export class PagedResultDtoOfHangFireStorageJob implements IPagedResultDtoOfHangFireStorageJob {
    totalCount: number | undefined;
    items: HangFireStorageJob[] | undefined;

    constructor(data?: IPagedResultDtoOfHangFireStorageJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(HangFireStorageJob.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfHangFireStorageJob {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfHangFireStorageJob();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfHangFireStorageJob {
        const json = this.toJSON();
        let result = new PagedResultDtoOfHangFireStorageJob();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfHangFireStorageJob {
    totalCount: number | undefined;
    items: HangFireStorageJob[] | undefined;
}

export class HangFireStorageJob implements IHangFireStorageJob {
    key: string | undefined;
    state: boolean | undefined;
    createAt: moment.Moment | undefined;
    totalDuration: number | undefined;
    jobName: string | undefined;
    exceptionMessage: string | undefined;
    exceptionType: string | undefined;
    exceptionDetails: string | undefined;
    reson: string | undefined;
    serverId: string | undefined;
    resultState: string | undefined;
    retryAt: moment.Moment | undefined;
    enqueueAt: moment.Moment | undefined;
    options: string | undefined;
    parentName: string | undefined;
    parentId: string | undefined;
    queueName: string | undefined;
    length: number | undefined;
    fetched: number | undefined;
    firstJobs: EnqueuedJobListDto[] | undefined;

    constructor(data?: IHangFireStorageJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.state = data["state"];
            this.createAt = data["createAt"] ? moment(data["createAt"].toString()) : <any>undefined;
            this.totalDuration = data["totalDuration"];
            this.jobName = data["jobName"];
            this.exceptionMessage = data["exceptionMessage"];
            this.exceptionType = data["exceptionType"];
            this.exceptionDetails = data["exceptionDetails"];
            this.reson = data["reson"];
            this.serverId = data["serverId"];
            this.resultState = data["resultState"];
            this.retryAt = data["retryAt"] ? moment(data["retryAt"].toString()) : <any>undefined;
            this.enqueueAt = data["enqueueAt"] ? moment(data["enqueueAt"].toString()) : <any>undefined;
            this.options = data["options"];
            this.parentName = data["parentName"];
            this.parentId = data["parentId"];
            this.queueName = data["queueName"];
            this.length = data["length"];
            this.fetched = data["fetched"];
            if (data["firstJobs"] && data["firstJobs"].constructor === Array) {
                this.firstJobs = [] as any;
                for (let item of data["firstJobs"])
                    this.firstJobs.push(EnqueuedJobListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HangFireStorageJob {
        data = typeof data === 'object' ? data : {};
        let result = new HangFireStorageJob();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["state"] = this.state;
        data["createAt"] = this.createAt ? this.createAt.toISOString() : <any>undefined;
        data["totalDuration"] = this.totalDuration;
        data["jobName"] = this.jobName;
        data["exceptionMessage"] = this.exceptionMessage;
        data["exceptionType"] = this.exceptionType;
        data["exceptionDetails"] = this.exceptionDetails;
        data["reson"] = this.reson;
        data["serverId"] = this.serverId;
        data["resultState"] = this.resultState;
        data["retryAt"] = this.retryAt ? this.retryAt.toISOString() : <any>undefined;
        data["enqueueAt"] = this.enqueueAt ? this.enqueueAt.toISOString() : <any>undefined;
        data["options"] = this.options;
        data["parentName"] = this.parentName;
        data["parentId"] = this.parentId;
        data["queueName"] = this.queueName;
        data["length"] = this.length;
        data["fetched"] = this.fetched;
        if (this.firstJobs && this.firstJobs.constructor === Array) {
            data["firstJobs"] = [];
            for (let item of this.firstJobs)
                data["firstJobs"].push(item.toJSON());
        }
        return data; 
    }

    clone(): HangFireStorageJob {
        const json = this.toJSON();
        let result = new HangFireStorageJob();
        result.init(json);
        return result;
    }
}

export interface IHangFireStorageJob {
    key: string | undefined;
    state: boolean | undefined;
    createAt: moment.Moment | undefined;
    totalDuration: number | undefined;
    jobName: string | undefined;
    exceptionMessage: string | undefined;
    exceptionType: string | undefined;
    exceptionDetails: string | undefined;
    reson: string | undefined;
    serverId: string | undefined;
    resultState: string | undefined;
    retryAt: moment.Moment | undefined;
    enqueueAt: moment.Moment | undefined;
    options: string | undefined;
    parentName: string | undefined;
    parentId: string | undefined;
    queueName: string | undefined;
    length: number | undefined;
    fetched: number | undefined;
    firstJobs: EnqueuedJobListDto[] | undefined;
}

export class EnqueuedJobListDto implements IEnqueuedJobListDto {
    key: string | undefined;
    createAt: moment.Moment | undefined;
    jobName: string | undefined;
    resultState: string | undefined;

    constructor(data?: IEnqueuedJobListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.createAt = data["createAt"] ? moment(data["createAt"].toString()) : <any>undefined;
            this.jobName = data["jobName"];
            this.resultState = data["resultState"];
        }
    }

    static fromJS(data: any): EnqueuedJobListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnqueuedJobListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["createAt"] = this.createAt ? this.createAt.toISOString() : <any>undefined;
        data["jobName"] = this.jobName;
        data["resultState"] = this.resultState;
        return data; 
    }

    clone(): EnqueuedJobListDto {
        const json = this.toJSON();
        let result = new EnqueuedJobListDto();
        result.init(json);
        return result;
    }
}

export interface IEnqueuedJobListDto {
    key: string | undefined;
    createAt: moment.Moment | undefined;
    jobName: string | undefined;
    resultState: string | undefined;
}

export class RecurringResultList implements IRecurringResultList {
    columnHeaders: ColumnHeader[] | undefined;
    recurringListJobDtos: PagedResultDtoOfRecurringListJobDto | undefined;

    constructor(data?: IRecurringResultList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["columnHeaders"] && data["columnHeaders"].constructor === Array) {
                this.columnHeaders = [] as any;
                for (let item of data["columnHeaders"])
                    this.columnHeaders.push(ColumnHeader.fromJS(item));
            }
            this.recurringListJobDtos = data["recurringListJobDtos"] ? PagedResultDtoOfRecurringListJobDto.fromJS(data["recurringListJobDtos"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RecurringResultList {
        data = typeof data === 'object' ? data : {};
        let result = new RecurringResultList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.columnHeaders && this.columnHeaders.constructor === Array) {
            data["columnHeaders"] = [];
            for (let item of this.columnHeaders)
                data["columnHeaders"].push(item.toJSON());
        }
        data["recurringListJobDtos"] = this.recurringListJobDtos ? this.recurringListJobDtos.toJSON() : <any>undefined;
        return data; 
    }

    clone(): RecurringResultList {
        const json = this.toJSON();
        let result = new RecurringResultList();
        result.init(json);
        return result;
    }
}

export interface IRecurringResultList {
    columnHeaders: ColumnHeader[] | undefined;
    recurringListJobDtos: PagedResultDtoOfRecurringListJobDto | undefined;
}

export class ColumnHeader implements IColumnHeader {
    propertyName: string | undefined;
    columnType: ColumnType | undefined;

    constructor(data?: IColumnHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.propertyName = data["propertyName"];
            this.columnType = data["columnType"];
        }
    }

    static fromJS(data: any): ColumnHeader {
        data = typeof data === 'object' ? data : {};
        let result = new ColumnHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["columnType"] = this.columnType;
        return data; 
    }

    clone(): ColumnHeader {
        const json = this.toJSON();
        let result = new ColumnHeader();
        result.init(json);
        return result;
    }
}

export interface IColumnHeader {
    propertyName: string | undefined;
    columnType: ColumnType | undefined;
}

export class PagedResultDtoOfRecurringListJobDto implements IPagedResultDtoOfRecurringListJobDto {
    totalCount: number | undefined;
    items: RecurringListJobDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRecurringListJobDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(RecurringListJobDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRecurringListJobDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRecurringListJobDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfRecurringListJobDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRecurringListJobDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRecurringListJobDto {
    totalCount: number | undefined;
    items: RecurringListJobDto[] | undefined;
}

export enum ColumnType {
    IntType = <any>"intType", 
    StringType = <any>"stringType", 
    ListType = <any>"listType", 
    DateType = <any>"dateType", 
    Link = <any>"link", 
}

export class RecurringListJobDto implements IRecurringListJobDto {
    recurringJobId: string | undefined;
    cron: string | undefined;
    timeZoneId: string | undefined;
    queue: string | undefined;
    name: string | undefined;
    jobName: string | undefined;
    enable: boolean | undefined;
    createdAt: moment.Moment | undefined;
    nextExecution: moment.Moment | undefined;
    lastJobId: string | undefined;
    lastJobState: string | undefined;
    lastExecution: moment.Moment | undefined;

    constructor(data?: IRecurringListJobDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.recurringJobId = data["recurringJobId"];
            this.cron = data["cron"];
            this.timeZoneId = data["timeZoneId"];
            this.queue = data["queue"];
            this.name = data["name"];
            this.jobName = data["jobName"];
            this.enable = data["enable"];
            this.createdAt = data["createdAt"] ? moment(data["createdAt"].toString()) : <any>undefined;
            this.nextExecution = data["nextExecution"] ? moment(data["nextExecution"].toString()) : <any>undefined;
            this.lastJobId = data["lastJobId"];
            this.lastJobState = data["lastJobState"];
            this.lastExecution = data["lastExecution"] ? moment(data["lastExecution"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecurringListJobDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecurringListJobDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recurringJobId"] = this.recurringJobId;
        data["cron"] = this.cron;
        data["timeZoneId"] = this.timeZoneId;
        data["queue"] = this.queue;
        data["name"] = this.name;
        data["jobName"] = this.jobName;
        data["enable"] = this.enable;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["nextExecution"] = this.nextExecution ? this.nextExecution.toISOString() : <any>undefined;
        data["lastJobId"] = this.lastJobId;
        data["lastJobState"] = this.lastJobState;
        data["lastExecution"] = this.lastExecution ? this.lastExecution.toISOString() : <any>undefined;
        return data; 
    }

    clone(): RecurringListJobDto {
        const json = this.toJSON();
        let result = new RecurringListJobDto();
        result.init(json);
        return result;
    }
}

export interface IRecurringListJobDto {
    recurringJobId: string | undefined;
    cron: string | undefined;
    timeZoneId: string | undefined;
    queue: string | undefined;
    name: string | undefined;
    jobName: string | undefined;
    enable: boolean | undefined;
    createdAt: moment.Moment | undefined;
    nextExecution: moment.Moment | undefined;
    lastJobId: string | undefined;
    lastJobState: string | undefined;
    lastExecution: moment.Moment | undefined;
}

export enum SearchTimeType {
    Day = <any>"day", 
    Week = <any>"week", 
    All = <any>"all", 
}

export class DashboardIndexDetailDto implements IDashboardIndexDetailDto {
    dashboardDataDtos: DashboardDataDto[] | undefined;

    constructor(data?: IDashboardIndexDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["dashboardDataDtos"] && data["dashboardDataDtos"].constructor === Array) {
                this.dashboardDataDtos = [] as any;
                for (let item of data["dashboardDataDtos"])
                    this.dashboardDataDtos.push(DashboardDataDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DashboardIndexDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardIndexDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.dashboardDataDtos && this.dashboardDataDtos.constructor === Array) {
            data["dashboardDataDtos"] = [];
            for (let item of this.dashboardDataDtos)
                data["dashboardDataDtos"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DashboardIndexDetailDto {
        const json = this.toJSON();
        let result = new DashboardIndexDetailDto();
        result.init(json);
        return result;
    }
}

export interface IDashboardIndexDetailDto {
    dashboardDataDtos: DashboardDataDto[] | undefined;
}

export class DashboardDataDto implements IDashboardDataDto {
    key: moment.Moment | undefined;
    value: string | undefined;
    type: string | undefined;

    constructor(data?: IDashboardDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"] ? moment(data["key"].toString()) : <any>undefined;
            this.value = data["value"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): DashboardDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key ? this.key.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["type"] = this.type;
        return data; 
    }

    clone(): DashboardDataDto {
        const json = this.toJSON();
        let result = new DashboardDataDto();
        result.init(json);
        return result;
    }
}

export interface IDashboardDataDto {
    key: moment.Moment | undefined;
    value: string | undefined;
    type: string | undefined;
}

export class StatisticsInfoDto implements IStatisticsInfoDto {
    servers: number | undefined;
    recurring: number | undefined;
    enqueued: number | undefined;
    queues: number | undefined;
    scheduled: number | undefined;
    processing: number | undefined;
    succeeded: number | undefined;
    failed: number | undefined;
    deleted: number | undefined;
    retries: number | undefined;
    waiting: number | undefined;
    dateValue: string | undefined;

    constructor(data?: IStatisticsInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.servers = data["servers"];
            this.recurring = data["recurring"];
            this.enqueued = data["enqueued"];
            this.queues = data["queues"];
            this.scheduled = data["scheduled"];
            this.processing = data["processing"];
            this.succeeded = data["succeeded"];
            this.failed = data["failed"];
            this.deleted = data["deleted"];
            this.retries = data["retries"];
            this.waiting = data["waiting"];
            this.dateValue = data["dateValue"];
        }
    }

    static fromJS(data: any): StatisticsInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticsInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["servers"] = this.servers;
        data["recurring"] = this.recurring;
        data["enqueued"] = this.enqueued;
        data["queues"] = this.queues;
        data["scheduled"] = this.scheduled;
        data["processing"] = this.processing;
        data["succeeded"] = this.succeeded;
        data["failed"] = this.failed;
        data["deleted"] = this.deleted;
        data["retries"] = this.retries;
        data["waiting"] = this.waiting;
        data["dateValue"] = this.dateValue;
        return data; 
    }

    clone(): StatisticsInfoDto {
        const json = this.toJSON();
        let result = new StatisticsInfoDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticsInfoDto {
    servers: number | undefined;
    recurring: number | undefined;
    enqueued: number | undefined;
    queues: number | undefined;
    scheduled: number | undefined;
    processing: number | undefined;
    succeeded: number | undefined;
    failed: number | undefined;
    deleted: number | undefined;
    retries: number | undefined;
    waiting: number | undefined;
    dateValue: string | undefined;
}

export class HangfireJobDetailDto implements IHangfireJobDetailDto {
    createdAt: moment.Moment | undefined;
    properties: { [key: string] : string; } | undefined;
    history: StateHistoryDto[] | undefined;
    expireAt: moment.Moment | undefined;
    jobName: string | undefined;
    namespace: string | undefined;
    className: string | undefined;
    methodName: string | undefined;

    constructor(data?: IHangfireJobDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createdAt = data["createdAt"] ? moment(data["createdAt"].toString()) : <any>undefined;
            if (data["properties"]) {
                this.properties = {} as any;
                for (let key in data["properties"]) {
                    if (data["properties"].hasOwnProperty(key))
                        this.properties[key] = data["properties"][key];
                }
            }
            if (data["history"] && data["history"].constructor === Array) {
                this.history = [] as any;
                for (let item of data["history"])
                    this.history.push(StateHistoryDto.fromJS(item));
            }
            this.expireAt = data["expireAt"] ? moment(data["expireAt"].toString()) : <any>undefined;
            this.jobName = data["jobName"];
            this.namespace = data["namespace"];
            this.className = data["className"];
            this.methodName = data["methodName"];
        }
    }

    static fromJS(data: any): HangfireJobDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new HangfireJobDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        if (this.history && this.history.constructor === Array) {
            data["history"] = [];
            for (let item of this.history)
                data["history"].push(item.toJSON());
        }
        data["expireAt"] = this.expireAt ? this.expireAt.toISOString() : <any>undefined;
        data["jobName"] = this.jobName;
        data["namespace"] = this.namespace;
        data["className"] = this.className;
        data["methodName"] = this.methodName;
        return data; 
    }

    clone(): HangfireJobDetailDto {
        const json = this.toJSON();
        let result = new HangfireJobDetailDto();
        result.init(json);
        return result;
    }
}

export interface IHangfireJobDetailDto {
    createdAt: moment.Moment | undefined;
    properties: { [key: string] : string; } | undefined;
    history: StateHistoryDto[] | undefined;
    expireAt: moment.Moment | undefined;
    jobName: string | undefined;
    namespace: string | undefined;
    className: string | undefined;
    methodName: string | undefined;
}

export class StateHistoryDto implements IStateHistoryDto {
    stateName: string | undefined;
    reason: string | undefined;
    createdAt: moment.Moment | undefined;
    data: { [key: string] : string; } | undefined;

    constructor(data?: IStateHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.stateName = data["stateName"];
            this.reason = data["reason"];
            this.createdAt = data["createdAt"] ? moment(data["createdAt"].toString()) : <any>undefined;
            if (data["data"]) {
                this.data = {} as any;
                for (let key in data["data"]) {
                    if (data["data"].hasOwnProperty(key))
                        this.data[key] = data["data"][key];
                }
            }
        }
    }

    static fromJS(data: any): StateHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new StateHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stateName"] = this.stateName;
        data["reason"] = this.reason;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    data["data"][key] = this.data[key];
            }
        }
        return data; 
    }

    clone(): StateHistoryDto {
        const json = this.toJSON();
        let result = new StateHistoryDto();
        result.init(json);
        return result;
    }
}

export interface IStateHistoryDto {
    stateName: string | undefined;
    reason: string | undefined;
    createdAt: moment.Moment | undefined;
    data: { [key: string] : string; } | undefined;
}

export class RetriesResultList implements IRetriesResultList {
    columnHeaders: ColumnHeader[] | undefined;
    retriesJobListDtos: PagedResultDtoOfRetriesJobListDto | undefined;

    constructor(data?: IRetriesResultList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["columnHeaders"] && data["columnHeaders"].constructor === Array) {
                this.columnHeaders = [] as any;
                for (let item of data["columnHeaders"])
                    this.columnHeaders.push(ColumnHeader.fromJS(item));
            }
            this.retriesJobListDtos = data["retriesJobListDtos"] ? PagedResultDtoOfRetriesJobListDto.fromJS(data["retriesJobListDtos"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RetriesResultList {
        data = typeof data === 'object' ? data : {};
        let result = new RetriesResultList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.columnHeaders && this.columnHeaders.constructor === Array) {
            data["columnHeaders"] = [];
            for (let item of this.columnHeaders)
                data["columnHeaders"].push(item.toJSON());
        }
        data["retriesJobListDtos"] = this.retriesJobListDtos ? this.retriesJobListDtos.toJSON() : <any>undefined;
        return data; 
    }

    clone(): RetriesResultList {
        const json = this.toJSON();
        let result = new RetriesResultList();
        result.init(json);
        return result;
    }
}

export interface IRetriesResultList {
    columnHeaders: ColumnHeader[] | undefined;
    retriesJobListDtos: PagedResultDtoOfRetriesJobListDto | undefined;
}

export class PagedResultDtoOfRetriesJobListDto implements IPagedResultDtoOfRetriesJobListDto {
    totalCount: number | undefined;
    items: RetriesJobListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRetriesJobListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(RetriesJobListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRetriesJobListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRetriesJobListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfRetriesJobListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRetriesJobListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRetriesJobListDto {
    totalCount: number | undefined;
    items: RetriesJobListDto[] | undefined;
}

export class RetriesJobListDto implements IRetriesJobListDto {
    jobId: string | undefined;
    state: string | undefined;
    jobName: string | undefined;
    reason: string | undefined;
    retryTime: moment.Moment | undefined;
    createdTime: moment.Moment | undefined;

    constructor(data?: IRetriesJobListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.jobId = data["jobId"];
            this.state = data["state"];
            this.jobName = data["jobName"];
            this.reason = data["reason"];
            this.retryTime = data["retryTime"] ? moment(data["retryTime"].toString()) : <any>undefined;
            this.createdTime = data["createdTime"] ? moment(data["createdTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RetriesJobListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetriesJobListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["state"] = this.state;
        data["jobName"] = this.jobName;
        data["reason"] = this.reason;
        data["retryTime"] = this.retryTime ? this.retryTime.toISOString() : <any>undefined;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): RetriesJobListDto {
        const json = this.toJSON();
        let result = new RetriesJobListDto();
        result.init(json);
        return result;
    }
}

export interface IRetriesJobListDto {
    jobId: string | undefined;
    state: string | undefined;
    jobName: string | undefined;
    reason: string | undefined;
    retryTime: moment.Moment | undefined;
    createdTime: moment.Moment | undefined;
}

export class ServerResultList implements IServerResultList {
    columnHeaders: ColumnHeader[] | undefined;
    hangfireServerListDtos: HangfireServerListDto[] | undefined;

    constructor(data?: IServerResultList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["columnHeaders"] && data["columnHeaders"].constructor === Array) {
                this.columnHeaders = [] as any;
                for (let item of data["columnHeaders"])
                    this.columnHeaders.push(ColumnHeader.fromJS(item));
            }
            if (data["hangfireServerListDtos"] && data["hangfireServerListDtos"].constructor === Array) {
                this.hangfireServerListDtos = [] as any;
                for (let item of data["hangfireServerListDtos"])
                    this.hangfireServerListDtos.push(HangfireServerListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServerResultList {
        data = typeof data === 'object' ? data : {};
        let result = new ServerResultList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.columnHeaders && this.columnHeaders.constructor === Array) {
            data["columnHeaders"] = [];
            for (let item of this.columnHeaders)
                data["columnHeaders"].push(item.toJSON());
        }
        if (this.hangfireServerListDtos && this.hangfireServerListDtos.constructor === Array) {
            data["hangfireServerListDtos"] = [];
            for (let item of this.hangfireServerListDtos)
                data["hangfireServerListDtos"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ServerResultList {
        const json = this.toJSON();
        let result = new ServerResultList();
        result.init(json);
        return result;
    }
}

export interface IServerResultList {
    columnHeaders: ColumnHeader[] | undefined;
    hangfireServerListDtos: HangfireServerListDto[] | undefined;
}

export class HangfireServerListDto implements IHangfireServerListDto {
    name: string | undefined;
    workersCount: number | undefined;
    startedAt: moment.Moment | undefined;
    queues: string[] | undefined;
    heartbeat: moment.Moment | undefined;

    constructor(data?: IHangfireServerListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.workersCount = data["workersCount"];
            this.startedAt = data["startedAt"] ? moment(data["startedAt"].toString()) : <any>undefined;
            if (data["queues"] && data["queues"].constructor === Array) {
                this.queues = [] as any;
                for (let item of data["queues"])
                    this.queues.push(item);
            }
            this.heartbeat = data["heartbeat"] ? moment(data["heartbeat"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): HangfireServerListDto {
        data = typeof data === 'object' ? data : {};
        let result = new HangfireServerListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["workersCount"] = this.workersCount;
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : <any>undefined;
        if (this.queues && this.queues.constructor === Array) {
            data["queues"] = [];
            for (let item of this.queues)
                data["queues"].push(item);
        }
        data["heartbeat"] = this.heartbeat ? this.heartbeat.toISOString() : <any>undefined;
        return data; 
    }

    clone(): HangfireServerListDto {
        const json = this.toJSON();
        let result = new HangfireServerListDto();
        result.init(json);
        return result;
    }
}

export interface IHangfireServerListDto {
    name: string | undefined;
    workersCount: number | undefined;
    startedAt: moment.Moment | undefined;
    queues: string[] | undefined;
    heartbeat: moment.Moment | undefined;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id: string | undefined;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDtoOfString {
        const json = this.toJSON();
        let result = new EntityDtoOfString();
        result.init(json);
        return result;
    }
}

export interface IEntityDtoOfString {
    id: string | undefined;
}

export class ListResultDtoOfHostCacheDto implements IListResultDtoOfHostCacheDto {
    items: HostCacheDto[] | undefined;

    constructor(data?: IListResultDtoOfHostCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(HostCacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfHostCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfHostCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfHostCacheDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfHostCacheDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfHostCacheDto {
    items: HostCacheDto[] | undefined;
}

export class HostCacheDto implements IHostCacheDto {
    name: string | undefined;

    constructor(data?: IHostCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): HostCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): HostCacheDto {
        const json = this.toJSON();
        let result = new HostCacheDto();
        result.init(json);
        return result;
    }
}

export interface IHostCacheDto {
    name: string | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    /** 基本设置 */
    general: GeneralSettingsEditDto;
    /** 用户管理设置 */
    userManagement: HostUserManagementSettingsEditDto;
    /** 邮箱设置 */
    email: EmailSettingsEditDto;
    /** 租户设置 */
    tenantManagement: TenantManagementSettingsEditDto;
    /** 安全设置 */
    security: SecuritySettingsEditDto;
    /** 发票管理 */
    billing: HostBillingSettingsEditDto | undefined;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? HostBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        return data; 
    }

    clone(): HostSettingsEditDto {
        const json = this.toJSON();
        let result = new HostSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IHostSettingsEditDto {
    /** 基本设置 */
    general: GeneralSettingsEditDto;
    /** 用户管理设置 */
    userManagement: HostUserManagementSettingsEditDto;
    /** 邮箱设置 */
    email: EmailSettingsEditDto;
    /** 租户设置 */
    tenantManagement: TenantManagementSettingsEditDto;
    /** 安全设置 */
    security: SecuritySettingsEditDto;
    /** 发票管理 */
    billing: HostBillingSettingsEditDto | undefined;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    /** 时区 */
    timezone: string | undefined;
    /** 这个字段只用于比较用户的时区与默认时区 */
    timezoneForComparison: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timezone = data["timezone"];
            this.timezoneForComparison = data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data; 
    }

    clone(): GeneralSettingsEditDto {
        const json = this.toJSON();
        let result = new GeneralSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IGeneralSettingsEditDto {
    /** 时区 */
    timezone: string | undefined;
    /** 这个字段只用于比较用户的时区与默认时区 */
    timezoneForComparison: string | undefined;
}

/** 网站全局管理设置 */
export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    /** 是否必须验证邮箱才能登陆 */
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    /** 是否启用短信验证 */
    smsVerificationEnabled: boolean | undefined;
    /** 是否启用Cookie内容 */
    isCookieConsentEnabled: boolean | undefined;
    /** 宿主用户登陆使用验证码 */
    useCaptchaOnUserLogin: boolean | undefined;
    /** 宿主用户登陆验证码类型 */
    captchaOnUserLoginType: ValidateCodeType | undefined;
    /** 宿主用户登陆验证码长度 */
    captchaOnUserLoginLength: number | undefined;
    isQuickThemeSelectEnabled: boolean | undefined;
    externalLoginProviders: string[] | undefined;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = data["smsVerificationEnabled"];
            this.isCookieConsentEnabled = data["isCookieConsentEnabled"];
            this.useCaptchaOnUserLogin = data["useCaptchaOnUserLogin"];
            this.captchaOnUserLoginType = data["captchaOnUserLoginType"];
            this.captchaOnUserLoginLength = data["captchaOnUserLoginLength"];
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
            if (data["externalLoginProviders"] && data["externalLoginProviders"].constructor === Array) {
                this.externalLoginProviders = [] as any;
                for (let item of data["externalLoginProviders"])
                    this.externalLoginProviders.push(item);
            }
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["useCaptchaOnUserLogin"] = this.useCaptchaOnUserLogin;
        data["captchaOnUserLoginType"] = this.captchaOnUserLoginType;
        data["captchaOnUserLoginLength"] = this.captchaOnUserLoginLength;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        if (this.externalLoginProviders && this.externalLoginProviders.constructor === Array) {
            data["externalLoginProviders"] = [];
            for (let item of this.externalLoginProviders)
                data["externalLoginProviders"].push(item);
        }
        return data; 
    }

    clone(): HostUserManagementSettingsEditDto {
        const json = this.toJSON();
        let result = new HostUserManagementSettingsEditDto();
        result.init(json);
        return result;
    }
}

/** 网站全局管理设置 */
export interface IHostUserManagementSettingsEditDto {
    /** 是否必须验证邮箱才能登陆 */
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    /** 是否启用短信验证 */
    smsVerificationEnabled: boolean | undefined;
    /** 是否启用Cookie内容 */
    isCookieConsentEnabled: boolean | undefined;
    /** 宿主用户登陆使用验证码 */
    useCaptchaOnUserLogin: boolean | undefined;
    /** 宿主用户登陆验证码类型 */
    captchaOnUserLoginType: ValidateCodeType | undefined;
    /** 宿主用户登陆验证码长度 */
    captchaOnUserLoginLength: number | undefined;
    isQuickThemeSelectEnabled: boolean | undefined;
    externalLoginProviders: string[] | undefined;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    /** 默认发件人邮箱地址 */
    defaultFromAddress: string | undefined;
    /** 邮箱显示名称 */
    defaultFromDisplayName: string | undefined;
    /** 发件人邮箱SMTP服务器Host */
    smtpHost: string | undefined;
    /** 发件人邮箱SMTP服务器端口 */
    smtpPort: number | undefined;
    /** 发件人校验名称 */
    smtpUserName: string | undefined;
    /** 发件人校验密码 */
    smtpPassword: string | undefined;
    /** 发件人 */
    smtpDomain: string | undefined;
    /** 使用ssl */
    smtpEnableSsl: boolean | undefined;
    /** 使用默认凭据 */
    smtpUseDefaultCredentials: boolean | undefined;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }

    clone(): EmailSettingsEditDto {
        const json = this.toJSON();
        let result = new EmailSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IEmailSettingsEditDto {
    /** 默认发件人邮箱地址 */
    defaultFromAddress: string | undefined;
    /** 邮箱显示名称 */
    defaultFromDisplayName: string | undefined;
    /** 发件人邮箱SMTP服务器Host */
    smtpHost: string | undefined;
    /** 发件人邮箱SMTP服务器端口 */
    smtpPort: number | undefined;
    /** 发件人校验名称 */
    smtpUserName: string | undefined;
    /** 发件人校验密码 */
    smtpPassword: string | undefined;
    /** 发件人 */
    smtpDomain: string | undefined;
    /** 使用ssl */
    smtpEnableSsl: boolean | undefined;
    /** 使用默认凭据 */
    smtpUseDefaultCredentials: boolean | undefined;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    /** 允许注册 */
    allowSelfRegistration: boolean | undefined;
    /** 注册租户默认激活 */
    isNewRegisteredTenantActiveByDefault: boolean | undefined;
    /** 宿主租户注册使用验证码 */
    useCaptchaOnTenantRegistration: boolean | undefined;
    /** 宿主租户注册验证码类型 */
    captchaOnTenantRegistrationType: ValidateCodeType | undefined;
    /** 宿主租户注册验证码长度 */
    captchaOnTenantRegistrationLength: number | undefined;
    /** 默认版本id */
    defaultEditionId: number | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnTenantRegistration = data["useCaptchaOnTenantRegistration"];
            this.captchaOnTenantRegistrationType = data["captchaOnTenantRegistrationType"];
            this.captchaOnTenantRegistrationLength = data["captchaOnTenantRegistrationLength"];
            this.defaultEditionId = data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnTenantRegistration"] = this.useCaptchaOnTenantRegistration;
        data["captchaOnTenantRegistrationType"] = this.captchaOnTenantRegistrationType;
        data["captchaOnTenantRegistrationLength"] = this.captchaOnTenantRegistrationLength;
        data["defaultEditionId"] = this.defaultEditionId;
        return data; 
    }

    clone(): TenantManagementSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantManagementSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantManagementSettingsEditDto {
    /** 允许注册 */
    allowSelfRegistration: boolean | undefined;
    /** 注册租户默认激活 */
    isNewRegisteredTenantActiveByDefault: boolean | undefined;
    /** 宿主租户注册使用验证码 */
    useCaptchaOnTenantRegistration: boolean | undefined;
    /** 宿主租户注册验证码类型 */
    captchaOnTenantRegistrationType: ValidateCodeType | undefined;
    /** 宿主租户注册验证码长度 */
    captchaOnTenantRegistrationLength: number | undefined;
    /** 默认版本id */
    defaultEditionId: number | undefined;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    /** 使用默认密码校验设置 */
    useDefaultPasswordComplexitySettings: boolean | undefined;
    /** 密码校验规则 */
    passwordComplexity: PasswordComplexitySetting | undefined;
    /** 默认密码校验规则 */
    defaultPasswordComplexity: PasswordComplexitySetting | undefined;
    /** 用户锁定设置 */
    userLockOut: UserLockOutSettingsEditDto | undefined;
    /** 双重校验登陆设置 */
    twoFactorLogin: TwoFactorLoginSettingsEditDto | undefined;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useDefaultPasswordComplexitySettings = data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data; 
    }

    clone(): SecuritySettingsEditDto {
        const json = this.toJSON();
        let result = new SecuritySettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ISecuritySettingsEditDto {
    /** 使用默认密码校验设置 */
    useDefaultPasswordComplexitySettings: boolean | undefined;
    /** 密码校验规则 */
    passwordComplexity: PasswordComplexitySetting | undefined;
    /** 默认密码校验规则 */
    defaultPasswordComplexity: PasswordComplexitySetting | undefined;
    /** 用户锁定设置 */
    userLockOut: UserLockOutSettingsEditDto | undefined;
    /** 双重校验登陆设置 */
    twoFactorLogin: TwoFactorLoginSettingsEditDto | undefined;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data; 
    }

    clone(): HostBillingSettingsEditDto {
        const json = this.toJSON();
        let result = new HostBillingSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
}

export enum ValidateCodeType {
    Number = <any>"Number", 
    English = <any>"English", 
    NumberAndLetter = <any>"NumberAndLetter", 
    Hanzi = <any>"Hanzi", 
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit: boolean | undefined;
    requireLowercase: boolean | undefined;
    requireNonAlphanumeric: boolean | undefined;
    requireUppercase: boolean | undefined;
    requiredLength: number | undefined;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requireDigit = data["requireDigit"];
            this.requireLowercase = data["requireLowercase"];
            this.requireNonAlphanumeric = data["requireNonAlphanumeric"];
            this.requireUppercase = data["requireUppercase"];
            this.requiredLength = data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data; 
    }

    clone(): PasswordComplexitySetting {
        const json = this.toJSON();
        let result = new PasswordComplexitySetting();
        result.init(json);
        return result;
    }
}

export interface IPasswordComplexitySetting {
    requireDigit: boolean | undefined;
    requireLowercase: boolean | undefined;
    requireNonAlphanumeric: boolean | undefined;
    requireUppercase: boolean | undefined;
    requiredLength: number | undefined;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    /** 是否启用 */
    isEnabled: boolean | undefined;
    /** 登陆校验错误锁定账户最大次数 */
    maxFailedAccessAttemptsBeforeLockout: number | undefined;
    /** 默认锁定时间 */
    defaultAccountLockoutSeconds: number | undefined;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data; 
    }

    clone(): UserLockOutSettingsEditDto {
        const json = this.toJSON();
        let result = new UserLockOutSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IUserLockOutSettingsEditDto {
    /** 是否启用 */
    isEnabled: boolean | undefined;
    /** 登陆校验错误锁定账户最大次数 */
    maxFailedAccessAttemptsBeforeLockout: number | undefined;
    /** 默认锁定时间 */
    defaultAccountLockoutSeconds: number | undefined;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean | undefined;
    /** 是否启用 */
    isEnabled: boolean | undefined;
    /** 邮箱启用 */
    isEmailProviderEnabled: boolean | undefined;
    /** 短信启用 */
    isSmsProviderEnabled: boolean | undefined;
    /** 浏览器‘记住我’启用 */
    isRememberBrowserEnabled: boolean | undefined;
    /** google校验启用 */
    isGoogleAuthenticatorEnabled: boolean | undefined;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabledForApplication = data["isEnabledForApplication"];
            this.isEnabled = data["isEnabled"];
            this.isEmailProviderEnabled = data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }

    clone(): TwoFactorLoginSettingsEditDto {
        const json = this.toJSON();
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean | undefined;
    /** 是否启用 */
    isEnabled: boolean | undefined;
    /** 邮箱启用 */
    isEmailProviderEnabled: boolean | undefined;
    /** 短信启用 */
    isSmsProviderEnabled: boolean | undefined;
    /** 浏览器‘记住我’启用 */
    isRememberBrowserEnabled: boolean | undefined;
    /** google校验启用 */
    isGoogleAuthenticatorEnabled: boolean | undefined;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    /** 邮箱地址 */
    emailAddress: string;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone(): SendTestEmailInput {
        const json = this.toJSON();
        let result = new SendTestEmailInput();
        result.init(json);
        return result;
    }
}

export interface ISendTestEmailInput {
    /** 邮箱地址 */
    emailAddress: string;
}

export class ImportUserDto implements IImportUserDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    password: string | undefined;
    /** comma separated list */
    assignedRoleNames: string[] | undefined;
    /** Can be set when reading data from excel or when importing user */
    exception: string | undefined;

    constructor(data?: IImportUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.password = data["password"];
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [] as any;
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames.push(item);
            }
            this.exception = data["exception"];
        }
    }

    static fromJS(data: any): ImportUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["exception"] = this.exception;
        return data; 
    }

    clone(): ImportUserDto {
        const json = this.toJSON();
        let result = new ImportUserDto();
        result.init(json);
        return result;
    }
}

export interface IImportUserDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    password: string | undefined;
    /** comma separated list */
    assignedRoleNames: string[] | undefined;
    /** Can be set when reading data from excel or when importing user */
    exception: string | undefined;
}

/** json项 */
export class JsonCell implements IJsonCell {
    /** 字段名称 */
    path: string | undefined;
    /** 值 */
    value: string | undefined;

    constructor(data?: IJsonCell) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.path = data["path"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): JsonCell {
        data = typeof data === 'object' ? data : {};
        let result = new JsonCell();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["value"] = this.value;
        return data; 
    }

    clone(): JsonCell {
        const json = this.toJSON();
        let result = new JsonCell();
        result.init(json);
        return result;
    }
}

/** json项 */
export interface IJsonCell {
    /** 字段名称 */
    path: string | undefined;
    /** 值 */
    value: string | undefined;
}

/** 枚举项 */
export class EnumCell implements IEnumCell {
    /** 对应的枚举类型 */
    enumName: any | undefined;
    /** 中文 */
    zhName: string | undefined;

    constructor(data?: IEnumCell) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.enumName = data["enumName"];
            this.zhName = data["zhName"];
        }
    }

    static fromJS(data: any): EnumCell {
        data = typeof data === 'object' ? data : {};
        let result = new EnumCell();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enumName"] = this.enumName;
        data["zhName"] = this.zhName;
        return data; 
    }

    clone(): EnumCell {
        const json = this.toJSON();
        let result = new EnumCell();
        result.init(json);
        return result;
    }
}

/** 枚举项 */
export interface IEnumCell {
    /** 对应的枚举类型 */
    enumName: any | undefined;
    /** 中文 */
    zhName: string | undefined;
}

/** 通用分页查询条件 */
export class GetCommonInput implements IGetCommonInput {
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetCommonInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.filterText = data["filterText"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetCommonInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCommonInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["filterText"] = this.filterText;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetCommonInput {
        const json = this.toJSON();
        let result = new GetCommonInput();
        result.init(json);
        return result;
    }
}

/** 通用分页查询条件 */
export interface IGetCommonInput {
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfJsonCell implements IPagedResultDtoOfJsonCell {
    totalCount: number | undefined;
    items: JsonCell[] | undefined;

    constructor(data?: IPagedResultDtoOfJsonCell) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(JsonCell.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfJsonCell {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfJsonCell();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfJsonCell {
        const json = this.toJSON();
        let result = new PagedResultDtoOfJsonCell();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfJsonCell {
    totalCount: number | undefined;
    items: JsonCell[] | undefined;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language: LanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new LanguageEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? LanguageEditDto.fromJS(data["language"]) : new LanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateLanguageInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateLanguageInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: LanguageEditDto;
}

export class LanguageEditDto implements ILanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean | undefined;

    constructor(data?: ILanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): LanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }

    clone(): LanguageEditDto {
        const json = this.toJSON();
        let result = new LanguageEditDto();
        result.init(json);
        return result;
    }
}

export interface ILanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean | undefined;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    /** 编辑的语言信息 */
    language: LanguageEditDto | undefined;
    /** 所有的语言名称 */
    languageNames: ComboboxItemDto[] | undefined;
    /** 所有的国旗 */
    flags: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? LanguageEditDto.fromJS(data["language"]) : <any>undefined;
            if (data["languageNames"] && data["languageNames"].constructor === Array) {
                this.languageNames = [] as any;
                for (let item of data["languageNames"])
                    this.languageNames.push(ComboboxItemDto.fromJS(item));
            }
            if (data["flags"] && data["flags"].constructor === Array) {
                this.flags = [] as any;
                for (let item of data["flags"])
                    this.flags.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (this.languageNames && this.languageNames.constructor === Array) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (this.flags && this.flags.constructor === Array) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetLanguageForEditOutput {
        const json = this.toJSON();
        let result = new GetLanguageForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLanguageForEditOutput {
    /** 编辑的语言信息 */
    language: LanguageEditDto | undefined;
    /** 所有的语言名称 */
    languageNames: ComboboxItemDto[] | undefined;
    /** 所有的国旗 */
    flags: ComboboxItemDto[] | undefined;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }

    clone(): ComboboxItemDto {
        const json = this.toJSON();
        let result = new ComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    /** 默认语言名称 */
    defaultLanguageName: string | undefined;
    items: LanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultLanguageName = data["defaultLanguageName"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(LanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetLanguagesOutput {
        const json = this.toJSON();
        let result = new GetLanguagesOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLanguagesOutput {
    /** 默认语言名称 */
    defaultLanguageName: string | undefined;
    items: LanguageListDto[] | undefined;
}

export class LanguageListDto implements ILanguageListDto {
    tenantId: number | undefined;
    /** 名称 */
    name: string | undefined;
    /** 显示名称 */
    displayName: string | undefined;
    /** 图标 */
    icon: string | undefined;
    isDisabled: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: ILanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.icon = data["icon"];
            this.isDisabled = data["isDisabled"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LanguageListDto {
        const json = this.toJSON();
        let result = new LanguageListDto();
        result.init(json);
        return result;
    }
}

export interface ILanguageListDto {
    tenantId: number | undefined;
    /** 名称 */
    name: string | undefined;
    /** 显示名称 */
    displayName: string | undefined;
    /** 图标 */
    icon: string | undefined;
    isDisabled: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount: number | undefined;
    items: LanguageTextListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfLanguageTextListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number | undefined;
    items: LanguageTextListDto[] | undefined;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    /** 键 */
    key: string | undefined;
    /** 原始值 */
    baseValue: string | undefined;
    /** 目标值 */
    targetValue: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.baseValue = data["baseValue"];
            this.targetValue = data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data; 
    }

    clone(): LanguageTextListDto {
        const json = this.toJSON();
        let result = new LanguageTextListDto();
        result.init(json);
        return result;
    }
}

export interface ILanguageTextListDto {
    /** 键 */
    key: string | undefined;
    /** 原始值 */
    baseValue: string | undefined;
    /** 目标值 */
    targetValue: string | undefined;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): SetDefaultLanguageInput {
        const json = this.toJSON();
        let result = new SetDefaultLanguageInput();
        result.init(json);
        return result;
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

/** 更新语言输入信息 */
export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    /** 键 */
    key: string;
    /** 值 */
    value: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
            this.sourceName = data["sourceName"];
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }

    clone(): UpdateLanguageTextInput {
        const json = this.toJSON();
        let result = new UpdateLanguageTextInput();
        result.init(json);
        return result;
    }
}

/** 更新语言输入信息 */
export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    /** 键 */
    key: string;
    /** 值 */
    value: string;
}

export class CreateOrUpdateMenuInput implements ICreateOrUpdateMenuInput {
    menu: MenuEditDto;

    constructor(data?: ICreateOrUpdateMenuInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.menu = new MenuEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.menu = data["menu"] ? MenuEditDto.fromJS(data["menu"]) : new MenuEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateMenuInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateMenuInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateMenuInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateMenuInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateMenuInput {
    menu: MenuEditDto;
}

export class MenuEditDto implements IMenuEditDto {
    /** Id */
    id: string | undefined;
    /** ParentId */
    parentId: string | undefined;
    /** MenuName */
    menuName: string;
    /** MenuCode */
    menuCode: string;
    /** NavigateUrl */
    navigateUrl: string;
    /** Sort */
    sort: number | undefined;
    /** Level */
    level: number | undefined;
    /** IocName */
    iocName: string;
    /** IocClassName */
    iocClassName: string;
    /** IsEnabled */
    isEnabled: boolean | undefined;

    constructor(data?: IMenuEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.parentId = data["parentId"];
            this.menuName = data["menuName"];
            this.menuCode = data["menuCode"];
            this.navigateUrl = data["navigateUrl"];
            this.sort = data["sort"];
            this.level = data["level"];
            this.iocName = data["iocName"];
            this.iocClassName = data["iocClassName"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): MenuEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["menuName"] = this.menuName;
        data["menuCode"] = this.menuCode;
        data["navigateUrl"] = this.navigateUrl;
        data["sort"] = this.sort;
        data["level"] = this.level;
        data["iocName"] = this.iocName;
        data["iocClassName"] = this.iocClassName;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }

    clone(): MenuEditDto {
        const json = this.toJSON();
        let result = new MenuEditDto();
        result.init(json);
        return result;
    }
}

export interface IMenuEditDto {
    /** Id */
    id: string | undefined;
    /** ParentId */
    parentId: string | undefined;
    /** MenuName */
    menuName: string;
    /** MenuCode */
    menuCode: string;
    /** NavigateUrl */
    navigateUrl: string;
    /** Sort */
    sort: number | undefined;
    /** Level */
    level: number | undefined;
    /** IocName */
    iocName: string;
    /** IocClassName */
    iocClassName: string;
    /** IsEnabled */
    isEnabled: boolean | undefined;
}

export class MenuListDto implements IMenuListDto {
    /** ParentId */
    parentId: string | undefined;
    /** Parent */
    parent: Menu | undefined;
    /** MenuName */
    menuName: string;
    /** MenuCode */
    menuCode: string;
    /** NavigateUrl */
    navigateUrl: string;
    /** Sort */
    sort: number | undefined;
    /** Level */
    level: number | undefined;
    /** IocName */
    iocName: string;
    /** IocClassName */
    iocClassName: string;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IMenuListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? Menu.fromJS(data["parent"]) : <any>undefined;
            this.menuName = data["menuName"];
            this.menuCode = data["menuCode"];
            this.navigateUrl = data["navigateUrl"];
            this.sort = data["sort"];
            this.level = data["level"];
            this.iocName = data["iocName"];
            this.iocClassName = data["iocClassName"];
            this.isEnabled = data["isEnabled"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MenuListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["menuName"] = this.menuName;
        data["menuCode"] = this.menuCode;
        data["navigateUrl"] = this.navigateUrl;
        data["sort"] = this.sort;
        data["level"] = this.level;
        data["iocName"] = this.iocName;
        data["iocClassName"] = this.iocClassName;
        data["isEnabled"] = this.isEnabled;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MenuListDto {
        const json = this.toJSON();
        let result = new MenuListDto();
        result.init(json);
        return result;
    }
}

export interface IMenuListDto {
    /** ParentId */
    parentId: string | undefined;
    /** Parent */
    parent: Menu | undefined;
    /** MenuName */
    menuName: string;
    /** MenuCode */
    menuCode: string;
    /** NavigateUrl */
    navigateUrl: string;
    /** Sort */
    sort: number | undefined;
    /** Level */
    level: number | undefined;
    /** IocName */
    iocName: string;
    /** IocClassName */
    iocClassName: string;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class Menu implements IMenu {
    parentId: string | undefined;
    parent: Menu | undefined;
    menuName: string;
    menuCode: string;
    navigateUrl: string;
    sort: number | undefined;
    level: number | undefined;
    iocName: string;
    iocClassName: string;
    isEnabled: boolean | undefined;
    powers: Power[] | undefined;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IMenu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? Menu.fromJS(data["parent"]) : <any>undefined;
            this.menuName = data["menuName"];
            this.menuCode = data["menuCode"];
            this.navigateUrl = data["navigateUrl"];
            this.sort = data["sort"];
            this.level = data["level"];
            this.iocName = data["iocName"];
            this.iocClassName = data["iocClassName"];
            this.isEnabled = data["isEnabled"];
            if (data["powers"] && data["powers"].constructor === Array) {
                this.powers = [] as any;
                for (let item of data["powers"])
                    this.powers.push(Power.fromJS(item));
            }
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Menu {
        data = typeof data === 'object' ? data : {};
        let result = new Menu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["menuName"] = this.menuName;
        data["menuCode"] = this.menuCode;
        data["navigateUrl"] = this.navigateUrl;
        data["sort"] = this.sort;
        data["level"] = this.level;
        data["iocName"] = this.iocName;
        data["iocClassName"] = this.iocClassName;
        data["isEnabled"] = this.isEnabled;
        if (this.powers && this.powers.constructor === Array) {
            data["powers"] = [];
            for (let item of this.powers)
                data["powers"].push(item.toJSON());
        }
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Menu {
        const json = this.toJSON();
        let result = new Menu();
        result.init(json);
        return result;
    }
}

export interface IMenu {
    parentId: string | undefined;
    parent: Menu | undefined;
    menuName: string;
    menuCode: string;
    navigateUrl: string;
    sort: number | undefined;
    level: number | undefined;
    iocName: string;
    iocClassName: string;
    isEnabled: boolean | undefined;
    powers: Power[] | undefined;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class Power implements IPower {
    menuId: string | undefined;
    menu: Menu | undefined;
    menuPath: string | undefined;
    powerCode: string;
    powerName: string;
    method: string | undefined;
    params: string | undefined;
    groupName: string | undefined;
    sort: number | undefined;
    iocName: string | undefined;
    iocClassName: string | undefined;
    category: PowerTypeEnum | undefined;
    isEnabled: boolean | undefined;
    powerRoles: PowerRole[] | undefined;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IPower) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.menuId = data["menuId"];
            this.menu = data["menu"] ? Menu.fromJS(data["menu"]) : <any>undefined;
            this.menuPath = data["menuPath"];
            this.powerCode = data["powerCode"];
            this.powerName = data["powerName"];
            this.method = data["method"];
            this.params = data["params"];
            this.groupName = data["groupName"];
            this.sort = data["sort"];
            this.iocName = data["iocName"];
            this.iocClassName = data["iocClassName"];
            this.category = data["category"];
            this.isEnabled = data["isEnabled"];
            if (data["powerRoles"] && data["powerRoles"].constructor === Array) {
                this.powerRoles = [] as any;
                for (let item of data["powerRoles"])
                    this.powerRoles.push(PowerRole.fromJS(item));
            }
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Power {
        data = typeof data === 'object' ? data : {};
        let result = new Power();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuId"] = this.menuId;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["menuPath"] = this.menuPath;
        data["powerCode"] = this.powerCode;
        data["powerName"] = this.powerName;
        data["method"] = this.method;
        data["params"] = this.params;
        data["groupName"] = this.groupName;
        data["sort"] = this.sort;
        data["iocName"] = this.iocName;
        data["iocClassName"] = this.iocClassName;
        data["category"] = this.category;
        data["isEnabled"] = this.isEnabled;
        if (this.powerRoles && this.powerRoles.constructor === Array) {
            data["powerRoles"] = [];
            for (let item of this.powerRoles)
                data["powerRoles"].push(item.toJSON());
        }
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Power {
        const json = this.toJSON();
        let result = new Power();
        result.init(json);
        return result;
    }
}

export interface IPower {
    menuId: string | undefined;
    menu: Menu | undefined;
    menuPath: string | undefined;
    powerCode: string;
    powerName: string;
    method: string | undefined;
    params: string | undefined;
    groupName: string | undefined;
    sort: number | undefined;
    iocName: string | undefined;
    iocClassName: string | undefined;
    category: PowerTypeEnum | undefined;
    isEnabled: boolean | undefined;
    powerRoles: PowerRole[] | undefined;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export enum PowerTypeEnum {
    OPERATE = <any>"OPERATE", 
    Data = <any>"Data", 
    MENU = <any>"MENU", 
}

export class PowerRole implements IPowerRole {
    roleId: number | undefined;
    role: Role | undefined;
    powerId: string | undefined;
    power: Power | undefined;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IPowerRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.role = data["role"] ? Role.fromJS(data["role"]) : <any>undefined;
            this.powerId = data["powerId"];
            this.power = data["power"] ? Power.fromJS(data["power"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PowerRole {
        data = typeof data === 'object' ? data : {};
        let result = new PowerRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["powerId"] = this.powerId;
        data["power"] = this.power ? this.power.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PowerRole {
        const json = this.toJSON();
        let result = new PowerRole();
        result.init(json);
        return result;
    }
}

export interface IPowerRole {
    roleId: number | undefined;
    role: Role | undefined;
    powerId: string | undefined;
    power: Power | undefined;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class Role implements IRole {
    description: string | undefined;
    normalizedName: string;
    claims: RoleClaim[] | undefined;
    concurrencyStamp: string | undefined;
    deleterUser: User | undefined;
    creatorUser: User | undefined;
    lastModifierUser: User | undefined;
    tenantId: number | undefined;
    name: string;
    displayName: string;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    permissions: RolePermissionSetting[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.normalizedName = data["normalizedName"];
            if (data["claims"] && data["claims"].constructor === Array) {
                this.claims = [] as any;
                for (let item of data["claims"])
                    this.claims.push(RoleClaim.fromJS(item));
            }
            this.concurrencyStamp = data["concurrencyStamp"];
            this.deleterUser = data["deleterUser"] ? User.fromJS(data["deleterUser"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = data["lastModifierUser"] ? User.fromJS(data["lastModifierUser"]) : <any>undefined;
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions.push(RolePermissionSetting.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["normalizedName"] = this.normalizedName;
        if (this.claims && this.claims.constructor === Array) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Role {
        const json = this.toJSON();
        let result = new Role();
        result.init(json);
        return result;
    }
}

export interface IRole {
    description: string | undefined;
    normalizedName: string;
    claims: RoleClaim[] | undefined;
    concurrencyStamp: string | undefined;
    deleterUser: User | undefined;
    creatorUser: User | undefined;
    lastModifierUser: User | undefined;
    tenantId: number | undefined;
    name: string;
    displayName: string;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    permissions: RolePermissionSetting[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class RoleClaim implements IRoleClaim {
    tenantId: number | undefined;
    roleId: number | undefined;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IRoleClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.roleId = data["roleId"];
            this.claimType = data["claimType"];
            this.claimValue = data["claimValue"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleClaim {
        data = typeof data === 'object' ? data : {};
        let result = new RoleClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["roleId"] = this.roleId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleClaim {
        const json = this.toJSON();
        let result = new RoleClaim();
        result.init(json);
        return result;
    }
}

export interface IRoleClaim {
    tenantId: number | undefined;
    roleId: number | undefined;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class RolePermissionSetting implements IRolePermissionSetting {
    roleId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IRolePermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.isGranted = data["isGranted"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RolePermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): RolePermissionSetting {
        const json = this.toJSON();
        let result = new RolePermissionSetting();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionSetting {
    roleId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class GetMenuForEditOutput implements IGetMenuForEditOutput {
    menu: MenuEditDto | undefined;

    constructor(data?: IGetMenuForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.menu = data["menu"] ? MenuEditDto.fromJS(data["menu"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMenuForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMenuForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetMenuForEditOutput {
        const json = this.toJSON();
        let result = new GetMenuForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMenuForEditOutput {
    menu: MenuEditDto | undefined;
}

export class MenuDropDownDto implements IMenuDropDownDto {
    /** key */
    key: string;
    /** title */
    title: string;
    /** 子菜单列表 */
    children: MenuDropDownDto[] | undefined;
    /** isLeaf */
    isLeaf: boolean;

    constructor(data?: IMenuDropDownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.title = data["title"];
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [] as any;
                for (let item of data["children"])
                    this.children.push(MenuDropDownDto.fromJS(item));
            }
            this.isLeaf = data["isLeaf"];
        }
    }

    static fromJS(data: any): MenuDropDownDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuDropDownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["title"] = this.title;
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["isLeaf"] = this.isLeaf;
        return data; 
    }

    clone(): MenuDropDownDto {
        const json = this.toJSON();
        let result = new MenuDropDownDto();
        result.init(json);
        return result;
    }
}

export interface IMenuDropDownDto {
    /** key */
    key: string;
    /** title */
    title: string;
    /** 子菜单列表 */
    children: MenuDropDownDto[] | undefined;
    /** isLeaf */
    isLeaf: boolean;
}

export class MenuTreeDto implements IMenuTreeDto {
    /** id */
    id: string;
    /** text */
    text: string;
    /** i18n */
    i18n: string;
    /** link */
    link: string;
    /** icon */
    icon: string;
    /** acl */
    acl: string;
    /** 子菜单列表 */
    childrens: MenuTreeDto[] | undefined;
    /** 是否显示所有操作 */
    isAllOperation: boolean | undefined;
    /** 可用操作名称列表 */
    operationNames: string[] | undefined;

    constructor(data?: IMenuTreeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.text = data["text"];
            this.i18n = data["i18n"];
            this.link = data["link"];
            this.icon = data["icon"];
            this.acl = data["acl"];
            if (data["childrens"] && data["childrens"].constructor === Array) {
                this.childrens = [] as any;
                for (let item of data["childrens"])
                    this.childrens.push(MenuTreeDto.fromJS(item));
            }
            this.isAllOperation = data["isAllOperation"];
            if (data["operationNames"] && data["operationNames"].constructor === Array) {
                this.operationNames = [] as any;
                for (let item of data["operationNames"])
                    this.operationNames.push(item);
            }
        }
    }

    static fromJS(data: any): MenuTreeDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuTreeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["i18n"] = this.i18n;
        data["link"] = this.link;
        data["icon"] = this.icon;
        data["acl"] = this.acl;
        if (this.childrens && this.childrens.constructor === Array) {
            data["childrens"] = [];
            for (let item of this.childrens)
                data["childrens"].push(item.toJSON());
        }
        data["isAllOperation"] = this.isAllOperation;
        if (this.operationNames && this.operationNames.constructor === Array) {
            data["operationNames"] = [];
            for (let item of this.operationNames)
                data["operationNames"].push(item);
        }
        return data; 
    }

    clone(): MenuTreeDto {
        const json = this.toJSON();
        let result = new MenuTreeDto();
        result.init(json);
        return result;
    }
}

export interface IMenuTreeDto {
    /** id */
    id: string;
    /** text */
    text: string;
    /** i18n */
    i18n: string;
    /** link */
    link: string;
    /** icon */
    icon: string;
    /** acl */
    acl: string;
    /** 子菜单列表 */
    childrens: MenuTreeDto[] | undefined;
    /** 是否显示所有操作 */
    isAllOperation: boolean | undefined;
    /** 可用操作名称列表 */
    operationNames: string[] | undefined;
}

export class GetMenusInput implements IGetMenusInput {
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetMenusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetMenusInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMenusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetMenusInput {
        const json = this.toJSON();
        let result = new GetMenusInput();
        result.init(json);
        return result;
    }
}

export interface IGetMenusInput {
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfMenuListDto implements IPagedResultDtoOfMenuListDto {
    totalCount: number | undefined;
    items: MenuListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMenuListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(MenuListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMenuListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMenuListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfMenuListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfMenuListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfMenuListDto {
    totalCount: number | undefined;
    items: MenuListDto[] | undefined;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [] as any;
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetNotificationSettingsOutput {
        const json = this.toJSON();
        let result = new GetNotificationSettingsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean | undefined;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }

    clone(): NotificationSubscriptionWithDisplayNameDto {
        const json = this.toJSON();
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(json);
        return result;
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean | undefined;
}

export enum UserNotificationState {
    Unread = <any>"Unread", 
    Read = <any>"Read", 
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    /** 未阅读消息数量 */
    unreadCount: number | undefined;
    totalCount: number | undefined;
    items: UserNotification[] | undefined;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unreadCount = data["unreadCount"];
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(UserNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetNotificationsOutput {
        const json = this.toJSON();
        let result = new GetNotificationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetNotificationsOutput {
    /** 未阅读消息数量 */
    unreadCount: number | undefined;
    totalCount: number | undefined;
    items: UserNotification[] | undefined;
}

export class UserNotification implements IUserNotification {
    tenantId: number | undefined;
    userId: number | undefined;
    state: UserNotificationState | undefined;
    notification: TenantNotification | undefined;
    id: string | undefined;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.state = data["state"];
            this.notification = data["notification"] ? TenantNotification.fromJS(data["notification"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserNotification {
        const json = this.toJSON();
        let result = new UserNotification();
        result.init(json);
        return result;
    }
}

export interface IUserNotification {
    tenantId: number | undefined;
    userId: number | undefined;
    state: UserNotificationState | undefined;
    notification: TenantNotification | undefined;
    id: string | undefined;
}

export class TenantNotification implements ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData | undefined;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: NotificationSeverity | undefined;
    creationTime: moment.Moment | undefined;
    id: string | undefined;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.notificationName = data["notificationName"];
            this.data = data["data"] ? NotificationData.fromJS(data["data"]) : <any>undefined;
            this.entityType = data["entityType"];
            this.entityTypeName = data["entityTypeName"];
            this.entityId = data["entityId"];
            this.severity = data["severity"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantNotification {
        const json = this.toJSON();
        let result = new TenantNotification();
        result.init(json);
        return result;
    }
}

export interface ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData | undefined;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: NotificationSeverity | undefined;
    creationTime: moment.Moment | undefined;
    id: string | undefined;
}

export class NotificationData implements INotificationData {
    readonly type: string | undefined;
    properties: { [key: string] : any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).type = data["type"];
            if (data["properties"]) {
                this.properties = {} as any;
                for (let key in data["properties"]) {
                    if (data["properties"].hasOwnProperty(key))
                        this.properties[key] = data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        return data; 
    }

    clone(): NotificationData {
        const json = this.toJSON();
        let result = new NotificationData();
        result.init(json);
        return result;
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string] : any; } | undefined;
}

export enum NotificationSeverity {
    Info = <any>"Info", 
    Success = <any>"Success", 
    Warn = <any>"Warn", 
    Error = <any>"Error", 
    Fatal = <any>"Fatal", 
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id: string | undefined;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDtoOfGuid {
        const json = this.toJSON();
        let result = new EntityDtoOfGuid();
        result.init(json);
        return result;
    }
}

export interface IEntityDtoOfGuid {
    id: string | undefined;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [] as any;
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UpdateNotificationSettingsInput {
        const json = this.toJSON();
        let result = new UpdateNotificationSettingsInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionDto[] | undefined;
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean | undefined;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }

    clone(): NotificationSubscriptionDto {
        const json = this.toJSON();
        let result = new NotificationSubscriptionDto();
        result.init(json);
        return result;
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean | undefined;
}

export class RolesToOrganizationUnitInput implements IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number | undefined;

    constructor(data?: IRolesToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["roleIds"] && data["roleIds"].constructor === Array) {
                this.roleIds = [] as any;
                for (let item of data["roleIds"])
                    this.roleIds.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RolesToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RolesToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.roleIds && this.roleIds.constructor === Array) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }

    clone(): RolesToOrganizationUnitInput {
        const json = this.toJSON();
        let result = new RolesToOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number | undefined;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number | undefined;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["userIds"] && data["userIds"].constructor === Array) {
                this.userIds = [] as any;
                for (let item of data["userIds"])
                    this.userIds.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.userIds && this.userIds.constructor === Array) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }

    clone(): UsersToOrganizationUnitInput {
        const json = this.toJSON();
        let result = new UsersToOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): CreateOrganizationUnitInput {
        const json = this.toJSON();
        let result = new CreateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
}

/** 组织机构列表Dto */
export class OrganizationUnitListDto implements IOrganizationUnitListDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number | undefined;
    roleCount: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IOrganizationUnitListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.memberCount = data["memberCount"];
            this.roleCount = data["roleCount"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): OrganizationUnitListDto {
        const json = this.toJSON();
        let result = new OrganizationUnitListDto();
        result.init(json);
        return result;
    }
}

/** 组织机构列表Dto */
export interface IOrganizationUnitListDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number | undefined;
    roleCount: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class FindUsersInput implements IFindUsersInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filterText: string | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filterText = data["filterText"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filterText"] = this.filterText;
        return data; 
    }

    clone(): FindUsersInput {
        const json = this.toJSON();
        let result = new FindUsersInput();
        result.init(json);
        return result;
    }
}

export interface IFindUsersInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filterText: string | undefined;
}

export class ListResultDtoOfOrganizationUnitListDto implements IListResultDtoOfOrganizationUnitListDto {
    items: OrganizationUnitListDto[] | undefined;

    constructor(data?: IListResultDtoOfOrganizationUnitListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(OrganizationUnitListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOrganizationUnitListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOrganizationUnitListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfOrganizationUnitListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfOrganizationUnitListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfOrganizationUnitListDto {
    items: OrganizationUnitListDto[] | undefined;
}

export class PagedResultDtoOfOrganizationUnitRoleListDto implements IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount: number | undefined;
    items: OrganizationUnitRoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(OrganizationUnitRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfOrganizationUnitRoleListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount: number | undefined;
    items: OrganizationUnitRoleListDto[] | undefined;
}

export class OrganizationUnitRoleListDto implements IOrganizationUnitRoleListDto {
    displayName: string | undefined;
    name: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: IOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.name = data["name"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): OrganizationUnitRoleListDto {
        const json = this.toJSON();
        let result = new OrganizationUnitRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitRoleListDto {
    displayName: string | undefined;
    name: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number | undefined;
    items: OrganizationUnitUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfOrganizationUnitUserListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number | undefined;
    items: OrganizationUnitUserListDto[] | undefined;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    userName: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): OrganizationUnitUserListDto {
        const json = this.toJSON();
        let result = new OrganizationUnitUserListDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitUserListDto {
    userName: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;
}

export class UserToOrganizationUnitInput implements IUserToOrganizationUnitInput {
    userId: number | undefined;
    organizationUnitId: number | undefined;

    constructor(data?: IUserToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UserToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UserToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }

    clone(): UserToOrganizationUnitInput {
        const json = this.toJSON();
        let result = new UserToOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUserToOrganizationUnitInput {
    userId: number | undefined;
    organizationUnitId: number | undefined;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id: number | undefined;
    newParentId: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newParentId = data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data; 
    }

    clone(): MoveOrganizationUnitInput {
        const json = this.toJSON();
        let result = new MoveOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IMoveOrganizationUnitInput {
    id: number | undefined;
    newParentId: number | undefined;
}

export class RoleToOrganizationUnitInput implements IRoleToOrganizationUnitInput {
    roleId: number | undefined;
    organizationUnitId: number | undefined;

    constructor(data?: IRoleToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RoleToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RoleToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }

    clone(): RoleToOrganizationUnitInput {
        const json = this.toJSON();
        let result = new RoleToOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IRoleToOrganizationUnitInput {
    roleId: number | undefined;
    organizationUnitId: number | undefined;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id: number | undefined;
    displayName: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): UpdateOrganizationUnitInput {
        const json = this.toJSON();
        let result = new UpdateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number | undefined;
    displayName: string;
}

export class CreateOrUpdatePayMethodInput implements ICreateOrUpdatePayMethodInput {
    payMethod: PayMethodEditDto;

    constructor(data?: ICreateOrUpdatePayMethodInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.payMethod = new PayMethodEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.payMethod = data["payMethod"] ? PayMethodEditDto.fromJS(data["payMethod"]) : new PayMethodEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdatePayMethodInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdatePayMethodInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdatePayMethodInput {
        const json = this.toJSON();
        let result = new CreateOrUpdatePayMethodInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdatePayMethodInput {
    payMethod: PayMethodEditDto;
}

export class PayMethodEditDto implements IPayMethodEditDto {
    /** Id */
    id: string | undefined;
    /** PayName */
    payName: string;
    /** PayCode */
    payCode: string;
    /** Sort */
    sort: number;
    /** IsEnabled */
    isEnabled: boolean;

    constructor(data?: IPayMethodEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.payName = data["payName"];
            this.payCode = data["payCode"];
            this.sort = data["sort"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): PayMethodEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayMethodEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["payName"] = this.payName;
        data["payCode"] = this.payCode;
        data["sort"] = this.sort;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }

    clone(): PayMethodEditDto {
        const json = this.toJSON();
        let result = new PayMethodEditDto();
        result.init(json);
        return result;
    }
}

export interface IPayMethodEditDto {
    /** Id */
    id: string | undefined;
    /** PayName */
    payName: string;
    /** PayCode */
    payCode: string;
    /** Sort */
    sort: number;
    /** IsEnabled */
    isEnabled: boolean;
}

export class PayMethodListDto implements IPayMethodListDto {
    /** PayName */
    payName: string;
    /** PayCode */
    payCode: string;
    /** Sort */
    sort: number;
    /** IsEnabled */
    isEnabled: boolean;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IPayMethodListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.payName = data["payName"];
            this.payCode = data["payCode"];
            this.sort = data["sort"];
            this.isEnabled = data["isEnabled"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PayMethodListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayMethodListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["payName"] = this.payName;
        data["payCode"] = this.payCode;
        data["sort"] = this.sort;
        data["isEnabled"] = this.isEnabled;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PayMethodListDto {
        const json = this.toJSON();
        let result = new PayMethodListDto();
        result.init(json);
        return result;
    }
}

export interface IPayMethodListDto {
    /** PayName */
    payName: string;
    /** PayCode */
    payCode: string;
    /** Sort */
    sort: number;
    /** IsEnabled */
    isEnabled: boolean;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetPayMethodForEditOutput implements IGetPayMethodForEditOutput {
    payMethod: PayMethodEditDto | undefined;

    constructor(data?: IGetPayMethodForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.payMethod = data["payMethod"] ? PayMethodEditDto.fromJS(data["payMethod"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPayMethodForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPayMethodForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetPayMethodForEditOutput {
        const json = this.toJSON();
        let result = new GetPayMethodForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetPayMethodForEditOutput {
    payMethod: PayMethodEditDto | undefined;
}

export class PagedResultDtoOfPayMethodListDto implements IPagedResultDtoOfPayMethodListDto {
    totalCount: number | undefined;
    items: PayMethodListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPayMethodListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(PayMethodListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPayMethodListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPayMethodListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfPayMethodListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfPayMethodListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfPayMethodListDto {
    totalCount: number | undefined;
    items: PayMethodListDto[] | undefined;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfFlatPermissionWithLevelDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level: number | undefined;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.level = data["level"];
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }

    clone(): FlatPermissionWithLevelDto {
        const json = this.toJSON();
        let result = new FlatPermissionWithLevelDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number | undefined;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
}

export class ListResultDtoOfTreePermissionDto implements IListResultDtoOfTreePermissionDto {
    items: TreePermissionDto[] | undefined;

    constructor(data?: IListResultDtoOfTreePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TreePermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfTreePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfTreePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfTreePermissionDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfTreePermissionDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfTreePermissionDto {
    items: TreePermissionDto[] | undefined;
}

export class TreePermissionDto implements ITreePermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    children: TreePermissionDto[] | undefined;
    checked: boolean | undefined;

    constructor(data?: ITreePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [] as any;
                for (let item of data["children"])
                    this.children.push(TreePermissionDto.fromJS(item));
            }
            this.checked = data["checked"];
        }
    }

    static fromJS(data: any): TreePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["checked"] = this.checked;
        return data; 
    }

    clone(): TreePermissionDto {
        const json = this.toJSON();
        let result = new TreePermissionDto();
        result.init(json);
        return result;
    }
}

export interface ITreePermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    children: TreePermissionDto[] | undefined;
    checked: boolean | undefined;
}

export class CreateOrUpdatePowerInput implements ICreateOrUpdatePowerInput {
    power: PowerEditDto;

    constructor(data?: ICreateOrUpdatePowerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.power = new PowerEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.power = data["power"] ? PowerEditDto.fromJS(data["power"]) : new PowerEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdatePowerInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdatePowerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["power"] = this.power ? this.power.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdatePowerInput {
        const json = this.toJSON();
        let result = new CreateOrUpdatePowerInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdatePowerInput {
    power: PowerEditDto;
}

export class PowerEditDto implements IPowerEditDto {
    /** Id */
    id: string | undefined;
    /** MenuId */
    menuId: string | undefined;
    /** MenuPath */
    menuPath: string | undefined;
    /** PowerCode */
    powerCode: string;
    /** PowerName */
    powerName: string;
    /** Method */
    method: string | undefined;
    /** Params */
    params: string | undefined;
    /** GroupName */
    groupName: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** IocName */
    iocName: string | undefined;
    /** IocClassName */
    iocClassName: string | undefined;
    /** Category */
    category: PowerTypeEnum | undefined;
    /** IsEnabled */
    isEnabled: boolean | undefined;

    constructor(data?: IPowerEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.menuId = data["menuId"];
            this.menuPath = data["menuPath"];
            this.powerCode = data["powerCode"];
            this.powerName = data["powerName"];
            this.method = data["method"];
            this.params = data["params"];
            this.groupName = data["groupName"];
            this.sort = data["sort"];
            this.iocName = data["iocName"];
            this.iocClassName = data["iocClassName"];
            this.category = data["category"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): PowerEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new PowerEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["menuId"] = this.menuId;
        data["menuPath"] = this.menuPath;
        data["powerCode"] = this.powerCode;
        data["powerName"] = this.powerName;
        data["method"] = this.method;
        data["params"] = this.params;
        data["groupName"] = this.groupName;
        data["sort"] = this.sort;
        data["iocName"] = this.iocName;
        data["iocClassName"] = this.iocClassName;
        data["category"] = this.category;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }

    clone(): PowerEditDto {
        const json = this.toJSON();
        let result = new PowerEditDto();
        result.init(json);
        return result;
    }
}

export interface IPowerEditDto {
    /** Id */
    id: string | undefined;
    /** MenuId */
    menuId: string | undefined;
    /** MenuPath */
    menuPath: string | undefined;
    /** PowerCode */
    powerCode: string;
    /** PowerName */
    powerName: string;
    /** Method */
    method: string | undefined;
    /** Params */
    params: string | undefined;
    /** GroupName */
    groupName: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** IocName */
    iocName: string | undefined;
    /** IocClassName */
    iocClassName: string | undefined;
    /** Category */
    category: PowerTypeEnum | undefined;
    /** IsEnabled */
    isEnabled: boolean | undefined;
}

export class PowerListDto implements IPowerListDto {
    /** MenuId */
    menuId: string | undefined;
    /** Menu */
    menu: Menu | undefined;
    /** MenuPath */
    menuPath: string | undefined;
    /** PowerCode */
    powerCode: string;
    /** PowerName */
    powerName: string;
    /** Method */
    method: string | undefined;
    /** Params */
    params: string | undefined;
    /** GroupName */
    groupName: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** IocName */
    iocName: string | undefined;
    /** IocClassName */
    iocClassName: string | undefined;
    /** Category */
    category: PowerTypeEnum | undefined;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    /** 是否使用 */
    isCheck: boolean | undefined;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IPowerListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.menuId = data["menuId"];
            this.menu = data["menu"] ? Menu.fromJS(data["menu"]) : <any>undefined;
            this.menuPath = data["menuPath"];
            this.powerCode = data["powerCode"];
            this.powerName = data["powerName"];
            this.method = data["method"];
            this.params = data["params"];
            this.groupName = data["groupName"];
            this.sort = data["sort"];
            this.iocName = data["iocName"];
            this.iocClassName = data["iocClassName"];
            this.category = data["category"];
            this.isEnabled = data["isEnabled"];
            this.isCheck = data["isCheck"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PowerListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PowerListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuId"] = this.menuId;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["menuPath"] = this.menuPath;
        data["powerCode"] = this.powerCode;
        data["powerName"] = this.powerName;
        data["method"] = this.method;
        data["params"] = this.params;
        data["groupName"] = this.groupName;
        data["sort"] = this.sort;
        data["iocName"] = this.iocName;
        data["iocClassName"] = this.iocClassName;
        data["category"] = this.category;
        data["isEnabled"] = this.isEnabled;
        data["isCheck"] = this.isCheck;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PowerListDto {
        const json = this.toJSON();
        let result = new PowerListDto();
        result.init(json);
        return result;
    }
}

export interface IPowerListDto {
    /** MenuId */
    menuId: string | undefined;
    /** Menu */
    menu: Menu | undefined;
    /** MenuPath */
    menuPath: string | undefined;
    /** PowerCode */
    powerCode: string;
    /** PowerName */
    powerName: string;
    /** Method */
    method: string | undefined;
    /** Params */
    params: string | undefined;
    /** GroupName */
    groupName: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** IocName */
    iocName: string | undefined;
    /** IocClassName */
    iocClassName: string | undefined;
    /** Category */
    category: PowerTypeEnum | undefined;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    /** 是否使用 */
    isCheck: boolean | undefined;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetPowerForEditOutput implements IGetPowerForEditOutput {
    power: PowerEditDto | undefined;

    constructor(data?: IGetPowerForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.power = data["power"] ? PowerEditDto.fromJS(data["power"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPowerForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPowerForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["power"] = this.power ? this.power.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetPowerForEditOutput {
        const json = this.toJSON();
        let result = new GetPowerForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetPowerForEditOutput {
    power: PowerEditDto | undefined;
}

export class PagedResultDtoOfPowerListDto implements IPagedResultDtoOfPowerListDto {
    totalCount: number | undefined;
    items: PowerListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPowerListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(PowerListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPowerListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPowerListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfPowerListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfPowerListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfPowerListDto {
    totalCount: number | undefined;
    items: PowerListDto[] | undefined;
}

export class GetTicketPower implements IGetTicketPower {
    getTicketTypeName: string | undefined;
    getTicketTypeId: string | undefined;

    constructor(data?: IGetTicketPower) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.getTicketTypeName = data["getTicketTypeName"];
            this.getTicketTypeId = data["getTicketTypeId"];
        }
    }

    static fromJS(data: any): GetTicketPower {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketPower();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["getTicketTypeName"] = this.getTicketTypeName;
        data["getTicketTypeId"] = this.getTicketTypeId;
        return data; 
    }

    clone(): GetTicketPower {
        const json = this.toJSON();
        let result = new GetTicketPower();
        result.init(json);
        return result;
    }
}

export interface IGetTicketPower {
    getTicketTypeName: string | undefined;
    getTicketTypeId: string | undefined;
}

export class CreateOrUpdatePowerRoleInput implements ICreateOrUpdatePowerRoleInput {
    powerRole: PowerRoleEditDto;

    constructor(data?: ICreateOrUpdatePowerRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.powerRole = new PowerRoleEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.powerRole = data["powerRole"] ? PowerRoleEditDto.fromJS(data["powerRole"]) : new PowerRoleEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdatePowerRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdatePowerRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["powerRole"] = this.powerRole ? this.powerRole.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdatePowerRoleInput {
        const json = this.toJSON();
        let result = new CreateOrUpdatePowerRoleInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdatePowerRoleInput {
    powerRole: PowerRoleEditDto;
}

export class PowerRoleEditDto implements IPowerRoleEditDto {
    /** Id */
    id: string | undefined;
    /** RoleId */
    roleId: number | undefined;
    /** PowerId */
    powerId: string | undefined;

    constructor(data?: IPowerRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.roleId = data["roleId"];
            this.powerId = data["powerId"];
        }
    }

    static fromJS(data: any): PowerRoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new PowerRoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleId"] = this.roleId;
        data["powerId"] = this.powerId;
        return data; 
    }

    clone(): PowerRoleEditDto {
        const json = this.toJSON();
        let result = new PowerRoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IPowerRoleEditDto {
    /** Id */
    id: string | undefined;
    /** RoleId */
    roleId: number | undefined;
    /** PowerId */
    powerId: string | undefined;
}

export class PowerRoleListDto implements IPowerRoleListDto {
    /** RoleId */
    roleId: number | undefined;
    /** Role */
    role: Role | undefined;
    /** PowerId */
    powerId: string | undefined;
    /** Power */
    power: Power | undefined;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IPowerRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.role = data["role"] ? Role.fromJS(data["role"]) : <any>undefined;
            this.powerId = data["powerId"];
            this.power = data["power"] ? Power.fromJS(data["power"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PowerRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PowerRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["powerId"] = this.powerId;
        data["power"] = this.power ? this.power.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PowerRoleListDto {
        const json = this.toJSON();
        let result = new PowerRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IPowerRoleListDto {
    /** RoleId */
    roleId: number | undefined;
    /** Role */
    role: Role | undefined;
    /** PowerId */
    powerId: string | undefined;
    /** Power */
    power: Power | undefined;
    creatorUser: User | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetPowerRoleForEditOutput implements IGetPowerRoleForEditOutput {
    powerRole: PowerRoleEditDto | undefined;

    constructor(data?: IGetPowerRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.powerRole = data["powerRole"] ? PowerRoleEditDto.fromJS(data["powerRole"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPowerRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPowerRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["powerRole"] = this.powerRole ? this.powerRole.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetPowerRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetPowerRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetPowerRoleForEditOutput {
    powerRole: PowerRoleEditDto | undefined;
}

export class PagedResultDtoOfPowerRoleListDto implements IPagedResultDtoOfPowerRoleListDto {
    totalCount: number | undefined;
    items: PowerRoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPowerRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(PowerRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPowerRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPowerRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfPowerRoleListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfPowerRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfPowerRoleListDto {
    totalCount: number | undefined;
    items: PowerRoleListDto[] | undefined;
}

export class CreateOrUpdatePriceAuditInput implements ICreateOrUpdatePriceAuditInput {
    priceAudit: PriceAuditEditDto;

    constructor(data?: ICreateOrUpdatePriceAuditInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.priceAudit = new PriceAuditEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.priceAudit = data["priceAudit"] ? PriceAuditEditDto.fromJS(data["priceAudit"]) : new PriceAuditEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdatePriceAuditInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdatePriceAuditInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priceAudit"] = this.priceAudit ? this.priceAudit.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdatePriceAuditInput {
        const json = this.toJSON();
        let result = new CreateOrUpdatePriceAuditInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdatePriceAuditInput {
    priceAudit: PriceAuditEditDto;
}

export class PriceAuditEditDto implements IPriceAuditEditDto {
    /** Id */
    id: string | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** OrgTicketPriceId */
    orgTicketPriceId: string | undefined;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    /** Price */
    price: number | undefined;
    /** Discount */
    discount: number | undefined;
    /** 退款折扣 */
    rDiscount: number | undefined;
    /** UpperTime */
    upperTime: moment.Moment | undefined;
    /** LowerTime */
    lowerTime: moment.Moment | undefined;
    /** AuditStatus */
    auditStatus: AuditStatusEnum | undefined;
    /** 价格名称 */
    ticketName: string | undefined;
    upperTimeStr: string | undefined;
    lowerTimeStr: string | undefined;
    /** 仓位 */
    warePosition: WareHousePosition | undefined;

    constructor(data?: IPriceAuditEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ticketId = data["ticketId"];
            this.orgTicketPriceId = data["orgTicketPriceId"];
            this.isEnabled = data["isEnabled"];
            this.price = data["price"];
            this.discount = data["discount"];
            this.rDiscount = data["rDiscount"];
            this.upperTime = data["upperTime"] ? moment(data["upperTime"].toString()) : <any>undefined;
            this.lowerTime = data["lowerTime"] ? moment(data["lowerTime"].toString()) : <any>undefined;
            this.auditStatus = data["auditStatus"];
            this.ticketName = data["ticketName"];
            this.upperTimeStr = data["upperTimeStr"];
            this.lowerTimeStr = data["lowerTimeStr"];
            this.warePosition = data["warePosition"];
        }
    }

    static fromJS(data: any): PriceAuditEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriceAuditEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketId"] = this.ticketId;
        data["orgTicketPriceId"] = this.orgTicketPriceId;
        data["isEnabled"] = this.isEnabled;
        data["price"] = this.price;
        data["discount"] = this.discount;
        data["rDiscount"] = this.rDiscount;
        data["upperTime"] = this.upperTime ? this.upperTime.toISOString() : <any>undefined;
        data["lowerTime"] = this.lowerTime ? this.lowerTime.toISOString() : <any>undefined;
        data["auditStatus"] = this.auditStatus;
        data["ticketName"] = this.ticketName;
        data["upperTimeStr"] = this.upperTimeStr;
        data["lowerTimeStr"] = this.lowerTimeStr;
        data["warePosition"] = this.warePosition;
        return data; 
    }

    clone(): PriceAuditEditDto {
        const json = this.toJSON();
        let result = new PriceAuditEditDto();
        result.init(json);
        return result;
    }
}

export interface IPriceAuditEditDto {
    /** Id */
    id: string | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** OrgTicketPriceId */
    orgTicketPriceId: string | undefined;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    /** Price */
    price: number | undefined;
    /** Discount */
    discount: number | undefined;
    /** 退款折扣 */
    rDiscount: number | undefined;
    /** UpperTime */
    upperTime: moment.Moment | undefined;
    /** LowerTime */
    lowerTime: moment.Moment | undefined;
    /** AuditStatus */
    auditStatus: AuditStatusEnum | undefined;
    /** 价格名称 */
    ticketName: string | undefined;
    upperTimeStr: string | undefined;
    lowerTimeStr: string | undefined;
    /** 仓位 */
    warePosition: WareHousePosition | undefined;
}

export class PriceAuditListDto implements IPriceAuditListDto {
    /** BranchId */
    branchId: string | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** Ticket */
    ticket: Ticket | undefined;
    /** OrgTicketPriceId */
    orgTicketPriceId: string | undefined;
    /** OrgTicketPrice */
    orgTicketPrice: TicketPrice | undefined;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    /** Price */
    price: number | undefined;
    /** Discount */
    discount: number | undefined;
    /** 退款折扣 */
    rDiscount: number | undefined;
    /** UpperTime */
    upperTime: moment.Moment | undefined;
    /** LowerTime */
    lowerTime: moment.Moment | undefined;
    /** AuditStatus */
    auditStatus: AuditStatusEnum | undefined;
    /** 价格名称 */
    ticketName: string | undefined;
    readonly upperTimeStr: string | undefined;
    readonly lowerTimeStr: string | undefined;
    readonly creationTimeStr: string | undefined;
    /** 仓位 */
    warePosition: WareHousePosition | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IPriceAuditListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketId = data["ticketId"];
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.orgTicketPriceId = data["orgTicketPriceId"];
            this.orgTicketPrice = data["orgTicketPrice"] ? TicketPrice.fromJS(data["orgTicketPrice"]) : <any>undefined;
            this.isEnabled = data["isEnabled"];
            this.price = data["price"];
            this.discount = data["discount"];
            this.rDiscount = data["rDiscount"];
            this.upperTime = data["upperTime"] ? moment(data["upperTime"].toString()) : <any>undefined;
            this.lowerTime = data["lowerTime"] ? moment(data["lowerTime"].toString()) : <any>undefined;
            this.auditStatus = data["auditStatus"];
            this.ticketName = data["ticketName"];
            (<any>this).upperTimeStr = data["upperTimeStr"];
            (<any>this).lowerTimeStr = data["lowerTimeStr"];
            (<any>this).creationTimeStr = data["creationTimeStr"];
            this.warePosition = data["warePosition"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PriceAuditListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriceAuditListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketId"] = this.ticketId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["orgTicketPriceId"] = this.orgTicketPriceId;
        data["orgTicketPrice"] = this.orgTicketPrice ? this.orgTicketPrice.toJSON() : <any>undefined;
        data["isEnabled"] = this.isEnabled;
        data["price"] = this.price;
        data["discount"] = this.discount;
        data["rDiscount"] = this.rDiscount;
        data["upperTime"] = this.upperTime ? this.upperTime.toISOString() : <any>undefined;
        data["lowerTime"] = this.lowerTime ? this.lowerTime.toISOString() : <any>undefined;
        data["auditStatus"] = this.auditStatus;
        data["ticketName"] = this.ticketName;
        data["upperTimeStr"] = this.upperTimeStr;
        data["lowerTimeStr"] = this.lowerTimeStr;
        data["creationTimeStr"] = this.creationTimeStr;
        data["warePosition"] = this.warePosition;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PriceAuditListDto {
        const json = this.toJSON();
        let result = new PriceAuditListDto();
        result.init(json);
        return result;
    }
}

export interface IPriceAuditListDto {
    /** BranchId */
    branchId: string | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** Ticket */
    ticket: Ticket | undefined;
    /** OrgTicketPriceId */
    orgTicketPriceId: string | undefined;
    /** OrgTicketPrice */
    orgTicketPrice: TicketPrice | undefined;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    /** Price */
    price: number | undefined;
    /** Discount */
    discount: number | undefined;
    /** 退款折扣 */
    rDiscount: number | undefined;
    /** UpperTime */
    upperTime: moment.Moment | undefined;
    /** LowerTime */
    lowerTime: moment.Moment | undefined;
    /** AuditStatus */
    auditStatus: AuditStatusEnum | undefined;
    /** 价格名称 */
    ticketName: string | undefined;
    upperTimeStr: string | undefined;
    lowerTimeStr: string | undefined;
    creationTimeStr: string | undefined;
    /** 仓位 */
    warePosition: WareHousePosition | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetPriceAuditForEditOutput implements IGetPriceAuditForEditOutput {
    priceAudit: PriceAuditEditDto | undefined;

    constructor(data?: IGetPriceAuditForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.priceAudit = data["priceAudit"] ? PriceAuditEditDto.fromJS(data["priceAudit"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPriceAuditForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPriceAuditForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priceAudit"] = this.priceAudit ? this.priceAudit.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetPriceAuditForEditOutput {
        const json = this.toJSON();
        let result = new GetPriceAuditForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetPriceAuditForEditOutput {
    priceAudit: PriceAuditEditDto | undefined;
}

export class GetPriceAuditsInput implements IGetPriceAuditsInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetPriceAuditsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetPriceAuditsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPriceAuditsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetPriceAuditsInput {
        const json = this.toJSON();
        let result = new GetPriceAuditsInput();
        result.init(json);
        return result;
    }
}

export interface IGetPriceAuditsInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfPriceAuditListDto implements IPagedResultDtoOfPriceAuditListDto {
    totalCount: number | undefined;
    items: PriceAuditListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPriceAuditListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(PriceAuditListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPriceAuditListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPriceAuditListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfPriceAuditListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfPriceAuditListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfPriceAuditListDto {
    totalCount: number | undefined;
    items: PriceAuditListDto[] | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangePasswordInput {
        const json = this.toJSON();
        let result = new ChangePasswordInput();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    userName: string;
    fullName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    /** 时区 */
    timezone: string | undefined;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.fullName = data["fullName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.timezone = data["timezone"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        return data; 
    }

    clone(): CurrentUserProfileEditDto {
        const json = this.toJSON();
        let result = new CurrentUserProfileEditDto();
        result.init(json);
        return result;
    }
}

export interface ICurrentUserProfileEditDto {
    userName: string;
    fullName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    /** 时区 */
    timezone: string | undefined;
}

/** 用户头像输出 */
export class GetProfilePictureOutputDto implements IGetProfilePictureOutputDto {
    profilePicture: string | undefined;

    constructor(data?: IGetProfilePictureOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePicture = data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data; 
    }

    clone(): GetProfilePictureOutputDto {
        const json = this.toJSON();
        let result = new GetProfilePictureOutputDto();
        result.init(json);
        return result;
    }
}

/** 用户头像输出 */
export interface IGetProfilePictureOutputDto {
    profilePicture: string | undefined;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    fileToken: string;
    x: number | undefined;
    y: number | undefined;
    width: number | undefined;
    height: number | undefined;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileToken = data["fileToken"];
            this.x = data["x"];
            this.y = data["y"];
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileToken"] = this.fileToken;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }

    clone(): UpdateProfilePictureInput {
        const json = this.toJSON();
        let result = new UpdateProfilePictureInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateProfilePictureInput {
    fileToken: string;
    x: number | undefined;
    y: number | undefined;
    width: number | undefined;
    height: number | undefined;
}

export class CreateOrUpdateRechargeRecordInput implements ICreateOrUpdateRechargeRecordInput {
    rechargeRecord: RechargeRecordEditDto;

    constructor(data?: ICreateOrUpdateRechargeRecordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.rechargeRecord = new RechargeRecordEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.rechargeRecord = data["rechargeRecord"] ? RechargeRecordEditDto.fromJS(data["rechargeRecord"]) : new RechargeRecordEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateRechargeRecordInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRechargeRecordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rechargeRecord"] = this.rechargeRecord ? this.rechargeRecord.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateRechargeRecordInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateRechargeRecordInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateRechargeRecordInput {
    rechargeRecord: RechargeRecordEditDto;
}

export class RechargeRecordEditDto implements IRechargeRecordEditDto {
    /** Id */
    id: string | undefined;
    /** TravelAgencyId */
    travelAgencyId: string;
    /** Amount */
    amount: number | undefined;
    /** RechargeStatus */
    rechargeStatus: RechargeStatusEnum;
    /** PayMethodId */
    payMethodId: string;

    constructor(data?: IRechargeRecordEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.travelAgencyId = data["travelAgencyId"];
            this.amount = data["amount"];
            this.rechargeStatus = data["rechargeStatus"];
            this.payMethodId = data["payMethodId"];
        }
    }

    static fromJS(data: any): RechargeRecordEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RechargeRecordEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["travelAgencyId"] = this.travelAgencyId;
        data["amount"] = this.amount;
        data["rechargeStatus"] = this.rechargeStatus;
        data["payMethodId"] = this.payMethodId;
        return data; 
    }

    clone(): RechargeRecordEditDto {
        const json = this.toJSON();
        let result = new RechargeRecordEditDto();
        result.init(json);
        return result;
    }
}

export interface IRechargeRecordEditDto {
    /** Id */
    id: string | undefined;
    /** TravelAgencyId */
    travelAgencyId: string;
    /** Amount */
    amount: number | undefined;
    /** RechargeStatus */
    rechargeStatus: RechargeStatusEnum;
    /** PayMethodId */
    payMethodId: string;
}

export enum RechargeStatusEnum {
    Wait = <any>"Wait", 
    Complete = <any>"Complete", 
    Cancel = <any>"Cancel", 
}

export class RechargeRecordListDto implements IRechargeRecordListDto {
    /** BranchId */
    branchId: string | undefined;
    /** TravelAgencyId */
    travelAgencyId: string;
    /** TravelAgency */
    travelAgency: TravelAgency | undefined;
    /** Amount */
    amount: number | undefined;
    /** RechargeStatus */
    rechargeStatus: RechargeStatusEnum;
    /** PayMethodId */
    payMethodId: string;
    /** PayMethod */
    payMethod: PayMethod | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IRechargeRecordListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.travelAgencyId = data["travelAgencyId"];
            this.travelAgency = data["travelAgency"] ? TravelAgency.fromJS(data["travelAgency"]) : <any>undefined;
            this.amount = data["amount"];
            this.rechargeStatus = data["rechargeStatus"];
            this.payMethodId = data["payMethodId"];
            this.payMethod = data["payMethod"] ? PayMethod.fromJS(data["payMethod"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RechargeRecordListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RechargeRecordListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["travelAgencyId"] = this.travelAgencyId;
        data["travelAgency"] = this.travelAgency ? this.travelAgency.toJSON() : <any>undefined;
        data["amount"] = this.amount;
        data["rechargeStatus"] = this.rechargeStatus;
        data["payMethodId"] = this.payMethodId;
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): RechargeRecordListDto {
        const json = this.toJSON();
        let result = new RechargeRecordListDto();
        result.init(json);
        return result;
    }
}

export interface IRechargeRecordListDto {
    /** BranchId */
    branchId: string | undefined;
    /** TravelAgencyId */
    travelAgencyId: string;
    /** TravelAgency */
    travelAgency: TravelAgency | undefined;
    /** Amount */
    amount: number | undefined;
    /** RechargeStatus */
    rechargeStatus: RechargeStatusEnum;
    /** PayMethodId */
    payMethodId: string;
    /** PayMethod */
    payMethod: PayMethod | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetRechargeRecordForEditOutput implements IGetRechargeRecordForEditOutput {
    rechargeRecord: RechargeRecordEditDto | undefined;

    constructor(data?: IGetRechargeRecordForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rechargeRecord = data["rechargeRecord"] ? RechargeRecordEditDto.fromJS(data["rechargeRecord"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRechargeRecordForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRechargeRecordForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rechargeRecord"] = this.rechargeRecord ? this.rechargeRecord.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetRechargeRecordForEditOutput {
        const json = this.toJSON();
        let result = new GetRechargeRecordForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRechargeRecordForEditOutput {
    rechargeRecord: RechargeRecordEditDto | undefined;
}

export class PagedResultDtoOfRechargeRecordListDto implements IPagedResultDtoOfRechargeRecordListDto {
    totalCount: number | undefined;
    items: RechargeRecordListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRechargeRecordListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(RechargeRecordListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRechargeRecordListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRechargeRecordListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfRechargeRecordListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRechargeRecordListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRechargeRecordListDto {
    totalCount: number | undefined;
    items: RechargeRecordListDto[] | undefined;
}

export class GetRechargeRecordsInput implements IGetRechargeRecordsInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetRechargeRecordsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetRechargeRecordsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRechargeRecordsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetRechargeRecordsInput {
        const json = this.toJSON();
        let result = new GetRechargeRecordsInput();
        result.init(json);
        return result;
    }
}

export interface IGetRechargeRecordsInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
    /** 票价Id列表 */
    ticketPriceIds: string[] | undefined;

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : new RoleEditDto();
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
            if (data["ticketPriceIds"] && data["ticketPriceIds"].constructor === Array) {
                this.ticketPriceIds = [] as any;
                for (let item of data["ticketPriceIds"])
                    this.ticketPriceIds.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        if (this.ticketPriceIds && this.ticketPriceIds.constructor === Array) {
            data["ticketPriceIds"] = [];
            for (let item of this.ticketPriceIds)
                data["ticketPriceIds"].push(item);
        }
        return data; 
    }

    clone(): CreateOrUpdateRoleInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateRoleInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
    /** 票价Id列表 */
    ticketPriceIds: string[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean | undefined;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean | undefined;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfRoleListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
    /** 票价Id列表 */
    ticketPriceIds: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
            if (data["ticketPriceIds"] && data["ticketPriceIds"].constructor === Array) {
                this.ticketPriceIds = [] as any;
                for (let item of data["ticketPriceIds"])
                    this.ticketPriceIds.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        if (this.ticketPriceIds && this.ticketPriceIds.constructor === Array) {
            data["ticketPriceIds"] = [];
            for (let item of this.ticketPriceIds)
                data["ticketPriceIds"].push(item);
        }
        return data; 
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
    /** 票价Id列表 */
    ticketPriceIds: string[] | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
}

export class PagedResultDtoOfRoleListDto implements IPagedResultDtoOfRoleListDto {
    totalCount: number | undefined;
    items: RoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfRoleListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRoleListDto {
    totalCount: number | undefined;
    items: RoleListDto[] | undefined;
}

export class UpdateRolePermissionsInput implements IUpdateRolePermissionsInput {
    roleId: number | undefined;
    grantedPermissionNames: string[];

    constructor(data?: IUpdateRolePermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateRolePermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRolePermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): UpdateRolePermissionsInput {
        const json = this.toJSON();
        let result = new UpdateRolePermissionsInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateRolePermissionsInput {
    roleId: number | undefined;
    grantedPermissionNames: string[];
}

export class CreateOrUpdateRouteInput implements ICreateOrUpdateRouteInput {
    route: RouteEditDto;

    constructor(data?: ICreateOrUpdateRouteInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.route = new RouteEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.route = data["route"] ? RouteEditDto.fromJS(data["route"]) : new RouteEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateRouteInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRouteInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["route"] = this.route ? this.route.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateRouteInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateRouteInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateRouteInput {
    route: RouteEditDto;
}

export class RouteEditDto implements IRouteEditDto {
    /** Id */
    id: string | undefined;
    /** 航线名称 */
    routeName: string;
    /** LineCode */
    lineCode: number;
    /** LineInfo */
    lineInfo: string;
    /** LineImage */
    lineImage: string;
    /** StartPosition */
    startPosition: string;
    /** EndPosition */
    endPosition: string;
    /** AuditStatus */
    auditStatus: AuditStatusEnum | undefined;
    /** 上船码头 */
    startWharfId: string | undefined;
    /** 上船码头 */
    endWharfId: string | undefined;

    constructor(data?: IRouteEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.routeName = data["routeName"];
            this.lineCode = data["lineCode"];
            this.lineInfo = data["lineInfo"];
            this.lineImage = data["lineImage"];
            this.startPosition = data["startPosition"];
            this.endPosition = data["endPosition"];
            this.auditStatus = data["auditStatus"];
            this.startWharfId = data["startWharfId"];
            this.endWharfId = data["endWharfId"];
        }
    }

    static fromJS(data: any): RouteEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RouteEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["routeName"] = this.routeName;
        data["lineCode"] = this.lineCode;
        data["lineInfo"] = this.lineInfo;
        data["lineImage"] = this.lineImage;
        data["startPosition"] = this.startPosition;
        data["endPosition"] = this.endPosition;
        data["auditStatus"] = this.auditStatus;
        data["startWharfId"] = this.startWharfId;
        data["endWharfId"] = this.endWharfId;
        return data; 
    }

    clone(): RouteEditDto {
        const json = this.toJSON();
        let result = new RouteEditDto();
        result.init(json);
        return result;
    }
}

export interface IRouteEditDto {
    /** Id */
    id: string | undefined;
    /** 航线名称 */
    routeName: string;
    /** LineCode */
    lineCode: number;
    /** LineInfo */
    lineInfo: string;
    /** LineImage */
    lineImage: string;
    /** StartPosition */
    startPosition: string;
    /** EndPosition */
    endPosition: string;
    /** AuditStatus */
    auditStatus: AuditStatusEnum | undefined;
    /** 上船码头 */
    startWharfId: string | undefined;
    /** 上船码头 */
    endWharfId: string | undefined;
}

export class RouteListDto implements IRouteListDto {
    /** BranchId */
    branchId: string | undefined;
    /** 航线名称 */
    routeName: string;
    /** LineCode */
    lineCode: number;
    /** LineInfo */
    lineInfo: string;
    /** LineImage */
    lineImage: string;
    /** StartPosition */
    startPosition: string;
    /** EndPosition */
    endPosition: string;
    /** AuditStatus */
    auditStatus: AuditStatusEnum | undefined;
    /** 上船码头 */
    startWharfId: string | undefined;
    startWharf: Wharf | undefined;
    /** 上船码头 */
    endWharfId: string | undefined;
    endWharf: Wharf | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IRouteListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.routeName = data["routeName"];
            this.lineCode = data["lineCode"];
            this.lineInfo = data["lineInfo"];
            this.lineImage = data["lineImage"];
            this.startPosition = data["startPosition"];
            this.endPosition = data["endPosition"];
            this.auditStatus = data["auditStatus"];
            this.startWharfId = data["startWharfId"];
            this.startWharf = data["startWharf"] ? Wharf.fromJS(data["startWharf"]) : <any>undefined;
            this.endWharfId = data["endWharfId"];
            this.endWharf = data["endWharf"] ? Wharf.fromJS(data["endWharf"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RouteListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RouteListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["routeName"] = this.routeName;
        data["lineCode"] = this.lineCode;
        data["lineInfo"] = this.lineInfo;
        data["lineImage"] = this.lineImage;
        data["startPosition"] = this.startPosition;
        data["endPosition"] = this.endPosition;
        data["auditStatus"] = this.auditStatus;
        data["startWharfId"] = this.startWharfId;
        data["startWharf"] = this.startWharf ? this.startWharf.toJSON() : <any>undefined;
        data["endWharfId"] = this.endWharfId;
        data["endWharf"] = this.endWharf ? this.endWharf.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): RouteListDto {
        const json = this.toJSON();
        let result = new RouteListDto();
        result.init(json);
        return result;
    }
}

export interface IRouteListDto {
    /** BranchId */
    branchId: string | undefined;
    /** 航线名称 */
    routeName: string;
    /** LineCode */
    lineCode: number;
    /** LineInfo */
    lineInfo: string;
    /** LineImage */
    lineImage: string;
    /** StartPosition */
    startPosition: string;
    /** EndPosition */
    endPosition: string;
    /** AuditStatus */
    auditStatus: AuditStatusEnum | undefined;
    /** 上船码头 */
    startWharfId: string | undefined;
    startWharf: Wharf | undefined;
    /** 上船码头 */
    endWharfId: string | undefined;
    endWharf: Wharf | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetRouteForEditOutput implements IGetRouteForEditOutput {
    route: RouteEditDto | undefined;

    constructor(data?: IGetRouteForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.route = data["route"] ? RouteEditDto.fromJS(data["route"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRouteForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRouteForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["route"] = this.route ? this.route.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetRouteForEditOutput {
        const json = this.toJSON();
        let result = new GetRouteForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRouteForEditOutput {
    route: RouteEditDto | undefined;
}

export class GetRoutesInput implements IGetRoutesInput {
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetRoutesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetRoutesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoutesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetRoutesInput {
        const json = this.toJSON();
        let result = new GetRoutesInput();
        result.init(json);
        return result;
    }
}

export interface IGetRoutesInput {
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfRouteListDto implements IPagedResultDtoOfRouteListDto {
    totalCount: number | undefined;
    items: RouteListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRouteListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(RouteListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRouteListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRouteListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfRouteListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRouteListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRouteListDto {
    totalCount: number | undefined;
    items: RouteListDto[] | undefined;
}

export class CreateOrUpdateScenicSpotInput implements ICreateOrUpdateScenicSpotInput {
    scenicSpot: ScenicSpotEditDto;

    constructor(data?: ICreateOrUpdateScenicSpotInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.scenicSpot = new ScenicSpotEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.scenicSpot = data["scenicSpot"] ? ScenicSpotEditDto.fromJS(data["scenicSpot"]) : new ScenicSpotEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateScenicSpotInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateScenicSpotInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scenicSpot"] = this.scenicSpot ? this.scenicSpot.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateScenicSpotInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateScenicSpotInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateScenicSpotInput {
    scenicSpot: ScenicSpotEditDto;
}

export class ScenicSpotEditDto implements IScenicSpotEditDto {
    /** Id */
    id: string | undefined;
    /** ScenicSpotName */
    scenicSpotName: string;
    /** ParentId */
    parentId: string | undefined;
    /** ScenicSpotInfo */
    scenicSpotInfo: string;

    constructor(data?: IScenicSpotEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.scenicSpotName = data["scenicSpotName"];
            this.parentId = data["parentId"];
            this.scenicSpotInfo = data["scenicSpotInfo"];
        }
    }

    static fromJS(data: any): ScenicSpotEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScenicSpotEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["scenicSpotName"] = this.scenicSpotName;
        data["parentId"] = this.parentId;
        data["scenicSpotInfo"] = this.scenicSpotInfo;
        return data; 
    }

    clone(): ScenicSpotEditDto {
        const json = this.toJSON();
        let result = new ScenicSpotEditDto();
        result.init(json);
        return result;
    }
}

export interface IScenicSpotEditDto {
    /** Id */
    id: string | undefined;
    /** ScenicSpotName */
    scenicSpotName: string;
    /** ParentId */
    parentId: string | undefined;
    /** ScenicSpotInfo */
    scenicSpotInfo: string;
}

export class ScenicSpotListDto implements IScenicSpotListDto {
    /** BranchId */
    branchId: string | undefined;
    /** ScenicSpotName */
    scenicSpotName: string;
    /** ParentId */
    parentId: string | undefined;
    /** Parent */
    parent: ScenicSpot | undefined;
    /** ScenicSpotInfo */
    scenicSpotInfo: string;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IScenicSpotListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.scenicSpotName = data["scenicSpotName"];
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? ScenicSpot.fromJS(data["parent"]) : <any>undefined;
            this.scenicSpotInfo = data["scenicSpotInfo"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ScenicSpotListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScenicSpotListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["scenicSpotName"] = this.scenicSpotName;
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["scenicSpotInfo"] = this.scenicSpotInfo;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ScenicSpotListDto {
        const json = this.toJSON();
        let result = new ScenicSpotListDto();
        result.init(json);
        return result;
    }
}

export interface IScenicSpotListDto {
    /** BranchId */
    branchId: string | undefined;
    /** ScenicSpotName */
    scenicSpotName: string;
    /** ParentId */
    parentId: string | undefined;
    /** Parent */
    parent: ScenicSpot | undefined;
    /** ScenicSpotInfo */
    scenicSpotInfo: string;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ScenicSpot implements IScenicSpot {
    branchId: string | undefined;
    scenicSpotName: string;
    parentId: string | undefined;
    parent: ScenicSpot | undefined;
    scenicSpotInfo: string;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IScenicSpot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.scenicSpotName = data["scenicSpotName"];
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? ScenicSpot.fromJS(data["parent"]) : <any>undefined;
            this.scenicSpotInfo = data["scenicSpotInfo"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ScenicSpot {
        data = typeof data === 'object' ? data : {};
        let result = new ScenicSpot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["scenicSpotName"] = this.scenicSpotName;
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["scenicSpotInfo"] = this.scenicSpotInfo;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ScenicSpot {
        const json = this.toJSON();
        let result = new ScenicSpot();
        result.init(json);
        return result;
    }
}

export interface IScenicSpot {
    branchId: string | undefined;
    scenicSpotName: string;
    parentId: string | undefined;
    parent: ScenicSpot | undefined;
    scenicSpotInfo: string;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetScenicSpotForEditOutput implements IGetScenicSpotForEditOutput {
    scenicSpot: ScenicSpotEditDto | undefined;

    constructor(data?: IGetScenicSpotForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scenicSpot = data["scenicSpot"] ? ScenicSpotEditDto.fromJS(data["scenicSpot"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetScenicSpotForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetScenicSpotForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scenicSpot"] = this.scenicSpot ? this.scenicSpot.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetScenicSpotForEditOutput {
        const json = this.toJSON();
        let result = new GetScenicSpotForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetScenicSpotForEditOutput {
    scenicSpot: ScenicSpotEditDto | undefined;
}

export class PagedResultDtoOfScenicSpotListDto implements IPagedResultDtoOfScenicSpotListDto {
    totalCount: number | undefined;
    items: ScenicSpotListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfScenicSpotListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ScenicSpotListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfScenicSpotListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfScenicSpotListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfScenicSpotListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfScenicSpotListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfScenicSpotListDto {
    totalCount: number | undefined;
    items: ScenicSpotListDto[] | undefined;
}

export class CreateOrUpdateScheduleInput implements ICreateOrUpdateScheduleInput {
    schedule: ScheduleEditDto;
    /** 批量增加开始日期 */
    beginDateStr: string | undefined;
    /** 批量增加结束日期 */
    endDateStr: string | undefined;

    constructor(data?: ICreateOrUpdateScheduleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.schedule = new ScheduleEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.schedule = data["schedule"] ? ScheduleEditDto.fromJS(data["schedule"]) : new ScheduleEditDto();
            this.beginDateStr = data["beginDateStr"];
            this.endDateStr = data["endDateStr"];
        }
    }

    static fromJS(data: any): CreateOrUpdateScheduleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateScheduleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["beginDateStr"] = this.beginDateStr;
        data["endDateStr"] = this.endDateStr;
        return data; 
    }

    clone(): CreateOrUpdateScheduleInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateScheduleInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateScheduleInput {
    schedule: ScheduleEditDto;
    /** 批量增加开始日期 */
    beginDateStr: string | undefined;
    /** 批量增加结束日期 */
    endDateStr: string | undefined;
}

export class ScheduleEditDto implements IScheduleEditDto {
    /** ScheduleCode */
    scheduleCode: string | undefined;
    /** Id */
    id: string | undefined;
    /** SaleDate */
    saleDate: moment.Moment | undefined;
    /** StartTime */
    startTime: moment.Moment;
    /** EndTime */
    endTime: moment.Moment | undefined;
    /** SeatQuantity */
    seatQuantity: number | undefined;
    /** SurplusQuantity */
    surplusQuantity: number | undefined;
    /** ScheduleStatus */
    scheduleStatus: ScheduleStatusEnum | undefined;
    /** AuditStatus */
    auditStatus: AuditStatusEnum | undefined;
    /** RouteId */
    routeId: string | undefined;
    /** BoatId */
    boatId: string | undefined;
    /** CheckStartTime */
    checkStartTime: moment.Moment | undefined;
    /** CheckEndTime */
    checkEndTime: moment.Moment | undefined;
    /** 预留数 */
    reserveQuantity: number | undefined;
    /** Route */
    route: Route | undefined;
    /** Boat */
    boat: Boat | undefined;
    /** 票价ID列表 */
    ticketIds: string[] | undefined;
    saleDateStr: string | undefined;
    startTimeStr: string | undefined;
    endTimeStr: string | undefined;
    checkStartTimeStr: string | undefined;
    checkEndTimeStr: string | undefined;
    /** 标准仓数量 */
    standardNum: number | undefined;
    /** 标准仓剩余数 */
    standardSurplusNum: number | undefined;
    /** 标准仓预留数 */
    standardReserveNum: number | undefined;
    /** VIP仓数量 */
    vipNum: number | undefined;
    /** VIP仓剩余数 */
    vipSurplusNum: number | undefined;
    /** VIP仓预留数 */
    vipReserveNum: number | undefined;
    /** 包间数量 */
    compartmentNum: number | undefined;
    /** 包间剩余数量 */
    compartmentSurplusNum: number | undefined;
    /** 包间预留数 */
    compartmentReserveNum: number | undefined;
    /** 航班销售状态 */
    scheduleSaleStatus: ScheduleEnum | undefined;
    /** 预留票数备注 */
    remark: string | undefined;

    constructor(data?: IScheduleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scheduleCode = data["scheduleCode"];
            this.id = data["id"];
            this.saleDate = data["saleDate"] ? moment(data["saleDate"].toString()) : <any>undefined;
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.seatQuantity = data["seatQuantity"];
            this.surplusQuantity = data["surplusQuantity"];
            this.scheduleStatus = data["scheduleStatus"];
            this.auditStatus = data["auditStatus"];
            this.routeId = data["routeId"];
            this.boatId = data["boatId"];
            this.checkStartTime = data["checkStartTime"] ? moment(data["checkStartTime"].toString()) : <any>undefined;
            this.checkEndTime = data["checkEndTime"] ? moment(data["checkEndTime"].toString()) : <any>undefined;
            this.reserveQuantity = data["reserveQuantity"];
            this.route = data["route"] ? Route.fromJS(data["route"]) : <any>undefined;
            this.boat = data["boat"] ? Boat.fromJS(data["boat"]) : <any>undefined;
            if (data["ticketIds"] && data["ticketIds"].constructor === Array) {
                this.ticketIds = [] as any;
                for (let item of data["ticketIds"])
                    this.ticketIds.push(item);
            }
            this.saleDateStr = data["saleDateStr"];
            this.startTimeStr = data["startTimeStr"];
            this.endTimeStr = data["endTimeStr"];
            this.checkStartTimeStr = data["checkStartTimeStr"];
            this.checkEndTimeStr = data["checkEndTimeStr"];
            this.standardNum = data["standardNum"];
            this.standardSurplusNum = data["standardSurplusNum"];
            this.standardReserveNum = data["standardReserveNum"];
            this.vipNum = data["vipNum"];
            this.vipSurplusNum = data["vipSurplusNum"];
            this.vipReserveNum = data["vipReserveNum"];
            this.compartmentNum = data["compartmentNum"];
            this.compartmentSurplusNum = data["compartmentSurplusNum"];
            this.compartmentReserveNum = data["compartmentReserveNum"];
            this.scheduleSaleStatus = data["scheduleSaleStatus"];
            this.remark = data["remark"];
        }
    }

    static fromJS(data: any): ScheduleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheduleCode"] = this.scheduleCode;
        data["id"] = this.id;
        data["saleDate"] = this.saleDate ? this.saleDate.toISOString() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["seatQuantity"] = this.seatQuantity;
        data["surplusQuantity"] = this.surplusQuantity;
        data["scheduleStatus"] = this.scheduleStatus;
        data["auditStatus"] = this.auditStatus;
        data["routeId"] = this.routeId;
        data["boatId"] = this.boatId;
        data["checkStartTime"] = this.checkStartTime ? this.checkStartTime.toISOString() : <any>undefined;
        data["checkEndTime"] = this.checkEndTime ? this.checkEndTime.toISOString() : <any>undefined;
        data["reserveQuantity"] = this.reserveQuantity;
        data["route"] = this.route ? this.route.toJSON() : <any>undefined;
        data["boat"] = this.boat ? this.boat.toJSON() : <any>undefined;
        if (this.ticketIds && this.ticketIds.constructor === Array) {
            data["ticketIds"] = [];
            for (let item of this.ticketIds)
                data["ticketIds"].push(item);
        }
        data["saleDateStr"] = this.saleDateStr;
        data["startTimeStr"] = this.startTimeStr;
        data["endTimeStr"] = this.endTimeStr;
        data["checkStartTimeStr"] = this.checkStartTimeStr;
        data["checkEndTimeStr"] = this.checkEndTimeStr;
        data["standardNum"] = this.standardNum;
        data["standardSurplusNum"] = this.standardSurplusNum;
        data["standardReserveNum"] = this.standardReserveNum;
        data["vipNum"] = this.vipNum;
        data["vipSurplusNum"] = this.vipSurplusNum;
        data["vipReserveNum"] = this.vipReserveNum;
        data["compartmentNum"] = this.compartmentNum;
        data["compartmentSurplusNum"] = this.compartmentSurplusNum;
        data["compartmentReserveNum"] = this.compartmentReserveNum;
        data["scheduleSaleStatus"] = this.scheduleSaleStatus;
        data["remark"] = this.remark;
        return data; 
    }

    clone(): ScheduleEditDto {
        const json = this.toJSON();
        let result = new ScheduleEditDto();
        result.init(json);
        return result;
    }
}

export interface IScheduleEditDto {
    /** ScheduleCode */
    scheduleCode: string | undefined;
    /** Id */
    id: string | undefined;
    /** SaleDate */
    saleDate: moment.Moment | undefined;
    /** StartTime */
    startTime: moment.Moment;
    /** EndTime */
    endTime: moment.Moment | undefined;
    /** SeatQuantity */
    seatQuantity: number | undefined;
    /** SurplusQuantity */
    surplusQuantity: number | undefined;
    /** ScheduleStatus */
    scheduleStatus: ScheduleStatusEnum | undefined;
    /** AuditStatus */
    auditStatus: AuditStatusEnum | undefined;
    /** RouteId */
    routeId: string | undefined;
    /** BoatId */
    boatId: string | undefined;
    /** CheckStartTime */
    checkStartTime: moment.Moment | undefined;
    /** CheckEndTime */
    checkEndTime: moment.Moment | undefined;
    /** 预留数 */
    reserveQuantity: number | undefined;
    /** Route */
    route: Route | undefined;
    /** Boat */
    boat: Boat | undefined;
    /** 票价ID列表 */
    ticketIds: string[] | undefined;
    saleDateStr: string | undefined;
    startTimeStr: string | undefined;
    endTimeStr: string | undefined;
    checkStartTimeStr: string | undefined;
    checkEndTimeStr: string | undefined;
    /** 标准仓数量 */
    standardNum: number | undefined;
    /** 标准仓剩余数 */
    standardSurplusNum: number | undefined;
    /** 标准仓预留数 */
    standardReserveNum: number | undefined;
    /** VIP仓数量 */
    vipNum: number | undefined;
    /** VIP仓剩余数 */
    vipSurplusNum: number | undefined;
    /** VIP仓预留数 */
    vipReserveNum: number | undefined;
    /** 包间数量 */
    compartmentNum: number | undefined;
    /** 包间剩余数量 */
    compartmentSurplusNum: number | undefined;
    /** 包间预留数 */
    compartmentReserveNum: number | undefined;
    /** 航班销售状态 */
    scheduleSaleStatus: ScheduleEnum | undefined;
    /** 预留票数备注 */
    remark: string | undefined;
}

export class ScheduleListDto implements IScheduleListDto {
    /** BranchId */
    branchId: string | undefined;
    /** ScheduleCode */
    scheduleCode: string | undefined;
    /** SaleDate */
    saleDate: moment.Moment | undefined;
    /** StartTime */
    startTime: moment.Moment;
    /** EndTime */
    endTime: moment.Moment;
    /** SeatQuantity */
    seatQuantity: number;
    /** SurplusQuantity */
    surplusQuantity: number;
    /** ScheduleStatus */
    scheduleStatus: ScheduleStatusEnum | undefined;
    /** AuditStatus */
    auditStatus: AuditStatusEnum | undefined;
    /** 预留数 */
    reserveQuantity: number | undefined;
    /** Route */
    route: Route | undefined;
    /** Boat */
    boat: Boat | undefined;
    /** RouteId */
    routeId: string;
    /** BoatId */
    boatId: string;
    /** CheckStartTime */
    checkStartTime: moment.Moment | undefined;
    /** CheckEndTime */
    checkEndTime: moment.Moment | undefined;
    /** 销售类型 */
    ticketNames: string | undefined;
    /** 票价ID列表 */
    ticketIds: string[] | undefined;
    /** 票价ID列表 */
    ticketPrices: TicketPriceListDto[] | undefined;
    readonly saleDateStr: string | undefined;
    readonly startTimeStr: string | undefined;
    readonly endTimeStr: string | undefined;
    readonly checkStartTimeStr: string | undefined;
    readonly checkEndTimeStr: string | undefined;
    readonly creationTimeStr: string | undefined;
    /** 标准仓数量 */
    standardNum: number | undefined;
    /** 标准仓剩余数 */
    standardSurplusNum: number | undefined;
    /** 标准仓预留数 */
    standardReserveNum: number | undefined;
    /** VIP仓数量 */
    vipNum: number | undefined;
    /** VIP仓剩余数 */
    vipSurplusNum: number | undefined;
    /** VIP仓预留数 */
    vipReserveNum: number | undefined;
    /** 包间数量 */
    compartmentNum: number | undefined;
    /** 包间剩余数量 */
    compartmentSurplusNum: number | undefined;
    /** 包间预留数 */
    compartmentReserveNum: number | undefined;
    /** 航班销售状态 */
    scheduleSaleStatus: ScheduleEnum | undefined;
    /** 预留票数备注 */
    remark: string | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IScheduleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.scheduleCode = data["scheduleCode"];
            this.saleDate = data["saleDate"] ? moment(data["saleDate"].toString()) : <any>undefined;
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.seatQuantity = data["seatQuantity"];
            this.surplusQuantity = data["surplusQuantity"];
            this.scheduleStatus = data["scheduleStatus"];
            this.auditStatus = data["auditStatus"];
            this.reserveQuantity = data["reserveQuantity"];
            this.route = data["route"] ? Route.fromJS(data["route"]) : <any>undefined;
            this.boat = data["boat"] ? Boat.fromJS(data["boat"]) : <any>undefined;
            this.routeId = data["routeId"];
            this.boatId = data["boatId"];
            this.checkStartTime = data["checkStartTime"] ? moment(data["checkStartTime"].toString()) : <any>undefined;
            this.checkEndTime = data["checkEndTime"] ? moment(data["checkEndTime"].toString()) : <any>undefined;
            this.ticketNames = data["ticketNames"];
            if (data["ticketIds"] && data["ticketIds"].constructor === Array) {
                this.ticketIds = [] as any;
                for (let item of data["ticketIds"])
                    this.ticketIds.push(item);
            }
            if (data["ticketPrices"] && data["ticketPrices"].constructor === Array) {
                this.ticketPrices = [] as any;
                for (let item of data["ticketPrices"])
                    this.ticketPrices.push(TicketPriceListDto.fromJS(item));
            }
            (<any>this).saleDateStr = data["saleDateStr"];
            (<any>this).startTimeStr = data["startTimeStr"];
            (<any>this).endTimeStr = data["endTimeStr"];
            (<any>this).checkStartTimeStr = data["checkStartTimeStr"];
            (<any>this).checkEndTimeStr = data["checkEndTimeStr"];
            (<any>this).creationTimeStr = data["creationTimeStr"];
            this.standardNum = data["standardNum"];
            this.standardSurplusNum = data["standardSurplusNum"];
            this.standardReserveNum = data["standardReserveNum"];
            this.vipNum = data["vipNum"];
            this.vipSurplusNum = data["vipSurplusNum"];
            this.vipReserveNum = data["vipReserveNum"];
            this.compartmentNum = data["compartmentNum"];
            this.compartmentSurplusNum = data["compartmentSurplusNum"];
            this.compartmentReserveNum = data["compartmentReserveNum"];
            this.scheduleSaleStatus = data["scheduleSaleStatus"];
            this.remark = data["remark"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ScheduleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["scheduleCode"] = this.scheduleCode;
        data["saleDate"] = this.saleDate ? this.saleDate.toISOString() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["seatQuantity"] = this.seatQuantity;
        data["surplusQuantity"] = this.surplusQuantity;
        data["scheduleStatus"] = this.scheduleStatus;
        data["auditStatus"] = this.auditStatus;
        data["reserveQuantity"] = this.reserveQuantity;
        data["route"] = this.route ? this.route.toJSON() : <any>undefined;
        data["boat"] = this.boat ? this.boat.toJSON() : <any>undefined;
        data["routeId"] = this.routeId;
        data["boatId"] = this.boatId;
        data["checkStartTime"] = this.checkStartTime ? this.checkStartTime.toISOString() : <any>undefined;
        data["checkEndTime"] = this.checkEndTime ? this.checkEndTime.toISOString() : <any>undefined;
        data["ticketNames"] = this.ticketNames;
        if (this.ticketIds && this.ticketIds.constructor === Array) {
            data["ticketIds"] = [];
            for (let item of this.ticketIds)
                data["ticketIds"].push(item);
        }
        if (this.ticketPrices && this.ticketPrices.constructor === Array) {
            data["ticketPrices"] = [];
            for (let item of this.ticketPrices)
                data["ticketPrices"].push(item.toJSON());
        }
        data["saleDateStr"] = this.saleDateStr;
        data["startTimeStr"] = this.startTimeStr;
        data["endTimeStr"] = this.endTimeStr;
        data["checkStartTimeStr"] = this.checkStartTimeStr;
        data["checkEndTimeStr"] = this.checkEndTimeStr;
        data["creationTimeStr"] = this.creationTimeStr;
        data["standardNum"] = this.standardNum;
        data["standardSurplusNum"] = this.standardSurplusNum;
        data["standardReserveNum"] = this.standardReserveNum;
        data["vipNum"] = this.vipNum;
        data["vipSurplusNum"] = this.vipSurplusNum;
        data["vipReserveNum"] = this.vipReserveNum;
        data["compartmentNum"] = this.compartmentNum;
        data["compartmentSurplusNum"] = this.compartmentSurplusNum;
        data["compartmentReserveNum"] = this.compartmentReserveNum;
        data["scheduleSaleStatus"] = this.scheduleSaleStatus;
        data["remark"] = this.remark;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ScheduleListDto {
        const json = this.toJSON();
        let result = new ScheduleListDto();
        result.init(json);
        return result;
    }
}

export interface IScheduleListDto {
    /** BranchId */
    branchId: string | undefined;
    /** ScheduleCode */
    scheduleCode: string | undefined;
    /** SaleDate */
    saleDate: moment.Moment | undefined;
    /** StartTime */
    startTime: moment.Moment;
    /** EndTime */
    endTime: moment.Moment;
    /** SeatQuantity */
    seatQuantity: number;
    /** SurplusQuantity */
    surplusQuantity: number;
    /** ScheduleStatus */
    scheduleStatus: ScheduleStatusEnum | undefined;
    /** AuditStatus */
    auditStatus: AuditStatusEnum | undefined;
    /** 预留数 */
    reserveQuantity: number | undefined;
    /** Route */
    route: Route | undefined;
    /** Boat */
    boat: Boat | undefined;
    /** RouteId */
    routeId: string;
    /** BoatId */
    boatId: string;
    /** CheckStartTime */
    checkStartTime: moment.Moment | undefined;
    /** CheckEndTime */
    checkEndTime: moment.Moment | undefined;
    /** 销售类型 */
    ticketNames: string | undefined;
    /** 票价ID列表 */
    ticketIds: string[] | undefined;
    /** 票价ID列表 */
    ticketPrices: TicketPriceListDto[] | undefined;
    saleDateStr: string | undefined;
    startTimeStr: string | undefined;
    endTimeStr: string | undefined;
    checkStartTimeStr: string | undefined;
    checkEndTimeStr: string | undefined;
    creationTimeStr: string | undefined;
    /** 标准仓数量 */
    standardNum: number | undefined;
    /** 标准仓剩余数 */
    standardSurplusNum: number | undefined;
    /** 标准仓预留数 */
    standardReserveNum: number | undefined;
    /** VIP仓数量 */
    vipNum: number | undefined;
    /** VIP仓剩余数 */
    vipSurplusNum: number | undefined;
    /** VIP仓预留数 */
    vipReserveNum: number | undefined;
    /** 包间数量 */
    compartmentNum: number | undefined;
    /** 包间剩余数量 */
    compartmentSurplusNum: number | undefined;
    /** 包间预留数 */
    compartmentReserveNum: number | undefined;
    /** 航班销售状态 */
    scheduleSaleStatus: ScheduleEnum | undefined;
    /** 预留票数备注 */
    remark: string | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class TicketPriceListDto implements ITicketPriceListDto {
    /** BranchId */
    branchId: string | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** Ticket */
    ticket: Ticket | undefined;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    /** Sort */
    sort: number | undefined;
    /** Price */
    price: number | undefined;
    /** Discount */
    discount: number | undefined;
    /** UpperTime */
    upperTime: moment.Moment | undefined;
    /** 退款折扣 */
    rDiscount: number | undefined;
    /** LowerTime */
    lowerTime: moment.Moment | undefined;
    /** Position */
    position: PositionEnum | undefined;
    /** 价格名称 */
    ticketName: string | undefined;
    /** 票型介绍 */
    ticketIntroduce: TicketIntroduce | undefined;
    readonly upperTimeStr: string | undefined;
    readonly lowerTimeStr: string | undefined;
    readonly creationTimeStr: string | undefined;
    /** 仓位 */
    warePosition: WareHousePosition | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ITicketPriceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketId = data["ticketId"];
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.isEnabled = data["isEnabled"];
            this.sort = data["sort"];
            this.price = data["price"];
            this.discount = data["discount"];
            this.upperTime = data["upperTime"] ? moment(data["upperTime"].toString()) : <any>undefined;
            this.rDiscount = data["rDiscount"];
            this.lowerTime = data["lowerTime"] ? moment(data["lowerTime"].toString()) : <any>undefined;
            this.position = data["position"];
            this.ticketName = data["ticketName"];
            this.ticketIntroduce = data["ticketIntroduce"] ? TicketIntroduce.fromJS(data["ticketIntroduce"]) : <any>undefined;
            (<any>this).upperTimeStr = data["upperTimeStr"];
            (<any>this).lowerTimeStr = data["lowerTimeStr"];
            (<any>this).creationTimeStr = data["creationTimeStr"];
            this.warePosition = data["warePosition"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketPriceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketPriceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketId"] = this.ticketId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["isEnabled"] = this.isEnabled;
        data["sort"] = this.sort;
        data["price"] = this.price;
        data["discount"] = this.discount;
        data["upperTime"] = this.upperTime ? this.upperTime.toISOString() : <any>undefined;
        data["rDiscount"] = this.rDiscount;
        data["lowerTime"] = this.lowerTime ? this.lowerTime.toISOString() : <any>undefined;
        data["position"] = this.position;
        data["ticketName"] = this.ticketName;
        data["ticketIntroduce"] = this.ticketIntroduce ? this.ticketIntroduce.toJSON() : <any>undefined;
        data["upperTimeStr"] = this.upperTimeStr;
        data["lowerTimeStr"] = this.lowerTimeStr;
        data["creationTimeStr"] = this.creationTimeStr;
        data["warePosition"] = this.warePosition;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketPriceListDto {
        const json = this.toJSON();
        let result = new TicketPriceListDto();
        result.init(json);
        return result;
    }
}

export interface ITicketPriceListDto {
    /** BranchId */
    branchId: string | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** Ticket */
    ticket: Ticket | undefined;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    /** Sort */
    sort: number | undefined;
    /** Price */
    price: number | undefined;
    /** Discount */
    discount: number | undefined;
    /** UpperTime */
    upperTime: moment.Moment | undefined;
    /** 退款折扣 */
    rDiscount: number | undefined;
    /** LowerTime */
    lowerTime: moment.Moment | undefined;
    /** Position */
    position: PositionEnum | undefined;
    /** 价格名称 */
    ticketName: string | undefined;
    /** 票型介绍 */
    ticketIntroduce: TicketIntroduce | undefined;
    upperTimeStr: string | undefined;
    lowerTimeStr: string | undefined;
    creationTimeStr: string | undefined;
    /** 仓位 */
    warePosition: WareHousePosition | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class TicketIntroduce implements ITicketIntroduce {
    branchId: string | undefined;
    ticketId: string | undefined;
    ticket: Ticket | undefined;
    scenicSpotId: string | undefined;
    scenicSpot: ScenicSpot | undefined;
    tradeName: string | undefined;
    tradeInfo: string | undefined;
    address: string | undefined;
    coverMap: string | undefined;
    abstract: string | undefined;
    notice: string | undefined;
    refundRule: string | undefined;
    isOnLine: boolean | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ITicketIntroduce) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketId = data["ticketId"];
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.scenicSpotId = data["scenicSpotId"];
            this.scenicSpot = data["scenicSpot"] ? ScenicSpot.fromJS(data["scenicSpot"]) : <any>undefined;
            this.tradeName = data["tradeName"];
            this.tradeInfo = data["tradeInfo"];
            this.address = data["address"];
            this.coverMap = data["coverMap"];
            this.abstract = data["abstract"];
            this.notice = data["notice"];
            this.refundRule = data["refundRule"];
            this.isOnLine = data["isOnLine"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketIntroduce {
        data = typeof data === 'object' ? data : {};
        let result = new TicketIntroduce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketId"] = this.ticketId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["scenicSpotId"] = this.scenicSpotId;
        data["scenicSpot"] = this.scenicSpot ? this.scenicSpot.toJSON() : <any>undefined;
        data["tradeName"] = this.tradeName;
        data["tradeInfo"] = this.tradeInfo;
        data["address"] = this.address;
        data["coverMap"] = this.coverMap;
        data["abstract"] = this.abstract;
        data["notice"] = this.notice;
        data["refundRule"] = this.refundRule;
        data["isOnLine"] = this.isOnLine;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketIntroduce {
        const json = this.toJSON();
        let result = new TicketIntroduce();
        result.init(json);
        return result;
    }
}

export interface ITicketIntroduce {
    branchId: string | undefined;
    ticketId: string | undefined;
    ticket: Ticket | undefined;
    scenicSpotId: string | undefined;
    scenicSpot: ScenicSpot | undefined;
    tradeName: string | undefined;
    tradeInfo: string | undefined;
    address: string | undefined;
    coverMap: string | undefined;
    abstract: string | undefined;
    notice: string | undefined;
    refundRule: string | undefined;
    isOnLine: boolean | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetScheduleForEditOutput implements IGetScheduleForEditOutput {
    schedule: ScheduleEditDto | undefined;

    constructor(data?: IGetScheduleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.schedule = data["schedule"] ? ScheduleEditDto.fromJS(data["schedule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetScheduleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetScheduleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetScheduleForEditOutput {
        const json = this.toJSON();
        let result = new GetScheduleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetScheduleForEditOutput {
    schedule: ScheduleEditDto | undefined;
}

export class GetSchedulesInput implements IGetSchedulesInput {
    queryData: QueryData[] | undefined;
    /** 票价是否启用,可以不传表示全查询 */
    isEnabled: boolean | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetSchedulesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.isEnabled = data["isEnabled"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetSchedulesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSchedulesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["isEnabled"] = this.isEnabled;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetSchedulesInput {
        const json = this.toJSON();
        let result = new GetSchedulesInput();
        result.init(json);
        return result;
    }
}

export interface IGetSchedulesInput {
    queryData: QueryData[] | undefined;
    /** 票价是否启用,可以不传表示全查询 */
    isEnabled: boolean | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfScheduleListDto implements IPagedResultDtoOfScheduleListDto {
    totalCount: number | undefined;
    items: ScheduleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfScheduleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ScheduleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfScheduleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfScheduleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfScheduleListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfScheduleListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfScheduleListDto {
    totalCount: number | undefined;
    items: ScheduleListDto[] | undefined;
}

export class ScheduleTipDto implements IScheduleTipDto {
    startSoonTips: string | undefined;
    needShow: boolean | undefined;

    constructor(data?: IScheduleTipDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startSoonTips = data["startSoonTips"];
            this.needShow = data["needShow"];
        }
    }

    static fromJS(data: any): ScheduleTipDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleTipDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startSoonTips"] = this.startSoonTips;
        data["needShow"] = this.needShow;
        return data; 
    }

    clone(): ScheduleTipDto {
        const json = this.toJSON();
        let result = new ScheduleTipDto();
        result.init(json);
        return result;
    }
}

export interface IScheduleTipDto {
    startSoonTips: string | undefined;
    needShow: boolean | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
    application: ApplicationInfoDto | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
    application: ApplicationInfoDto | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number | undefined;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    edition: EditionInfoDto | undefined;
    creationTime: moment.Moment | undefined;
    creationTimeString: string | undefined;
    id: number | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.logoId = data["logoId"];
            this.edition = data["edition"] ? EditionInfoDto.fromJS(data["edition"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creationTimeString = data["creationTimeString"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["logoId"] = this.logoId;
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creationTimeString"] = this.creationTimeString;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    edition: EditionInfoDto | undefined;
    creationTime: moment.Moment | undefined;
    creationTimeString: string | undefined;
    id: number | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    features: { [key: string] : boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {} as any;
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    features: { [key: string] : boolean; } | undefined;
}

export class EditionInfoDto implements IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean | undefined;
    isFree: boolean | undefined;
    id: number | undefined;

    constructor(data?: IEditionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.trialDayCount = data["trialDayCount"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.isHighestEdition = data["isHighestEdition"];
            this.isFree = data["isFree"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["trialDayCount"] = this.trialDayCount;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["isHighestEdition"] = this.isHighestEdition;
        data["isFree"] = this.isFree;
        data["id"] = this.id;
        return data; 
    }

    clone(): EditionInfoDto {
        const json = this.toJSON();
        let result = new EditionInfoDto();
        result.init(json);
        return result;
    }
}

export interface IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean | undefined;
    isFree: boolean | undefined;
    id: number | undefined;
}

export class AbpUserConfigurationDto implements IAbpUserConfigurationDto {
    multiTenancy: AbpMultiTenancyConfigDto | undefined;
    session: AbpUserSessionConfigDto | undefined;
    localization: AbpUserLocalizationConfigDto | undefined;
    features: AbpUserFeatureConfigDto | undefined;
    auth: AbpUserAuthConfigDto | undefined;
    nav: AbpUserNavConfigDto | undefined;
    setting: AbpUserSettingConfigDto | undefined;
    clock: AbpUserClockConfigDto | undefined;
    timing: AbpUserTimingConfigDto | undefined;
    security: AbpUserSecurityConfigDto | undefined;
    custom: { [key: string] : any; } | undefined;

    constructor(data?: IAbpUserConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.multiTenancy = data["multiTenancy"] ? AbpMultiTenancyConfigDto.fromJS(data["multiTenancy"]) : <any>undefined;
            this.session = data["session"] ? AbpUserSessionConfigDto.fromJS(data["session"]) : <any>undefined;
            this.localization = data["localization"] ? AbpUserLocalizationConfigDto.fromJS(data["localization"]) : <any>undefined;
            this.features = data["features"] ? AbpUserFeatureConfigDto.fromJS(data["features"]) : <any>undefined;
            this.auth = data["auth"] ? AbpUserAuthConfigDto.fromJS(data["auth"]) : <any>undefined;
            this.nav = data["nav"] ? AbpUserNavConfigDto.fromJS(data["nav"]) : <any>undefined;
            this.setting = data["setting"] ? AbpUserSettingConfigDto.fromJS(data["setting"]) : <any>undefined;
            this.clock = data["clock"] ? AbpUserClockConfigDto.fromJS(data["clock"]) : <any>undefined;
            this.timing = data["timing"] ? AbpUserTimingConfigDto.fromJS(data["timing"]) : <any>undefined;
            this.security = data["security"] ? AbpUserSecurityConfigDto.fromJS(data["security"]) : <any>undefined;
            if (data["custom"]) {
                this.custom = {} as any;
                for (let key in data["custom"]) {
                    if (data["custom"].hasOwnProperty(key))
                        this.custom[key] = data["custom"][key];
                }
            }
        }
    }

    static fromJS(data: any): AbpUserConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["multiTenancy"] = this.multiTenancy ? this.multiTenancy.toJSON() : <any>undefined;
        data["session"] = this.session ? this.session.toJSON() : <any>undefined;
        data["localization"] = this.localization ? this.localization.toJSON() : <any>undefined;
        data["features"] = this.features ? this.features.toJSON() : <any>undefined;
        data["auth"] = this.auth ? this.auth.toJSON() : <any>undefined;
        data["nav"] = this.nav ? this.nav.toJSON() : <any>undefined;
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        data["clock"] = this.clock ? this.clock.toJSON() : <any>undefined;
        data["timing"] = this.timing ? this.timing.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        if (this.custom) {
            data["custom"] = {};
            for (let key in this.custom) {
                if (this.custom.hasOwnProperty(key))
                    data["custom"][key] = this.custom[key];
            }
        }
        return data; 
    }

    clone(): AbpUserConfigurationDto {
        const json = this.toJSON();
        let result = new AbpUserConfigurationDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserConfigurationDto {
    multiTenancy: AbpMultiTenancyConfigDto | undefined;
    session: AbpUserSessionConfigDto | undefined;
    localization: AbpUserLocalizationConfigDto | undefined;
    features: AbpUserFeatureConfigDto | undefined;
    auth: AbpUserAuthConfigDto | undefined;
    nav: AbpUserNavConfigDto | undefined;
    setting: AbpUserSettingConfigDto | undefined;
    clock: AbpUserClockConfigDto | undefined;
    timing: AbpUserTimingConfigDto | undefined;
    security: AbpUserSecurityConfigDto | undefined;
    custom: { [key: string] : any; } | undefined;
}

export class AbpMultiTenancyConfigDto implements IAbpMultiTenancyConfigDto {
    isEnabled: boolean | undefined;
    ignoreFeatureCheckForHostUsers: boolean | undefined;
    readonly sides: AbpMultiTenancySidesConfigDto | undefined;

    constructor(data?: IAbpMultiTenancyConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.ignoreFeatureCheckForHostUsers = data["ignoreFeatureCheckForHostUsers"];
            (<any>this).sides = data["sides"] ? AbpMultiTenancySidesConfigDto.fromJS(data["sides"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AbpMultiTenancyConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpMultiTenancyConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["ignoreFeatureCheckForHostUsers"] = this.ignoreFeatureCheckForHostUsers;
        data["sides"] = this.sides ? this.sides.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AbpMultiTenancyConfigDto {
        const json = this.toJSON();
        let result = new AbpMultiTenancyConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpMultiTenancyConfigDto {
    isEnabled: boolean | undefined;
    ignoreFeatureCheckForHostUsers: boolean | undefined;
    sides: AbpMultiTenancySidesConfigDto | undefined;
}

export class AbpUserSessionConfigDto implements IAbpUserSessionConfigDto {
    userId: number | undefined;
    tenantId: number | undefined;
    impersonatorUserId: number | undefined;
    impersonatorTenantId: number | undefined;
    multiTenancySide: MultiTenancySides | undefined;

    constructor(data?: IAbpUserSessionConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.multiTenancySide = data["multiTenancySide"];
        }
    }

    static fromJS(data: any): AbpUserSessionConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserSessionConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["multiTenancySide"] = this.multiTenancySide;
        return data; 
    }

    clone(): AbpUserSessionConfigDto {
        const json = this.toJSON();
        let result = new AbpUserSessionConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserSessionConfigDto {
    userId: number | undefined;
    tenantId: number | undefined;
    impersonatorUserId: number | undefined;
    impersonatorTenantId: number | undefined;
    multiTenancySide: MultiTenancySides | undefined;
}

export class AbpUserLocalizationConfigDto implements IAbpUserLocalizationConfigDto {
    currentCulture: AbpUserCurrentCultureConfigDto | undefined;
    languages: LanguageInfo[] | undefined;
    currentLanguage: LanguageInfo | undefined;
    sources: AbpLocalizationSourceDto[] | undefined;
    values: { [key: string] : { [key: string] : string; }; } | undefined;

    constructor(data?: IAbpUserLocalizationConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentCulture = data["currentCulture"] ? AbpUserCurrentCultureConfigDto.fromJS(data["currentCulture"]) : <any>undefined;
            if (data["languages"] && data["languages"].constructor === Array) {
                this.languages = [] as any;
                for (let item of data["languages"])
                    this.languages.push(LanguageInfo.fromJS(item));
            }
            this.currentLanguage = data["currentLanguage"] ? LanguageInfo.fromJS(data["currentLanguage"]) : <any>undefined;
            if (data["sources"] && data["sources"].constructor === Array) {
                this.sources = [] as any;
                for (let item of data["sources"])
                    this.sources.push(AbpLocalizationSourceDto.fromJS(item));
            }
            if (data["values"]) {
                this.values = {} as any;
                for (let key in data["values"]) {
                    if (data["values"].hasOwnProperty(key))
                        this.values[key] = data["values"][key] !== undefined ? data["values"][key] : {};
                }
            }
        }
    }

    static fromJS(data: any): AbpUserLocalizationConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserLocalizationConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentCulture"] = this.currentCulture ? this.currentCulture.toJSON() : <any>undefined;
        if (this.languages && this.languages.constructor === Array) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        data["currentLanguage"] = this.currentLanguage ? this.currentLanguage.toJSON() : <any>undefined;
        if (this.sources && this.sources.constructor === Array) {
            data["sources"] = [];
            for (let item of this.sources)
                data["sources"].push(item.toJSON());
        }
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    data["values"][key] = this.values[key];
            }
        }
        return data; 
    }

    clone(): AbpUserLocalizationConfigDto {
        const json = this.toJSON();
        let result = new AbpUserLocalizationConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserLocalizationConfigDto {
    currentCulture: AbpUserCurrentCultureConfigDto | undefined;
    languages: LanguageInfo[] | undefined;
    currentLanguage: LanguageInfo | undefined;
    sources: AbpLocalizationSourceDto[] | undefined;
    values: { [key: string] : { [key: string] : string; }; } | undefined;
}

export class AbpUserFeatureConfigDto implements IAbpUserFeatureConfigDto {
    allFeatures: { [key: string] : AbpStringValueDto; } | undefined;

    constructor(data?: IAbpUserFeatureConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["allFeatures"]) {
                this.allFeatures = {} as any;
                for (let key in data["allFeatures"]) {
                    if (data["allFeatures"].hasOwnProperty(key))
                        this.allFeatures[key] = data["allFeatures"][key] ? AbpStringValueDto.fromJS(data["allFeatures"][key]) : new AbpStringValueDto();
                }
            }
        }
    }

    static fromJS(data: any): AbpUserFeatureConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserFeatureConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.allFeatures) {
            data["allFeatures"] = {};
            for (let key in this.allFeatures) {
                if (this.allFeatures.hasOwnProperty(key))
                    data["allFeatures"][key] = this.allFeatures[key] ? this.allFeatures[key].toJSON() : <any>undefined;
            }
        }
        return data; 
    }

    clone(): AbpUserFeatureConfigDto {
        const json = this.toJSON();
        let result = new AbpUserFeatureConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserFeatureConfigDto {
    allFeatures: { [key: string] : AbpStringValueDto; } | undefined;
}

export class AbpUserAuthConfigDto implements IAbpUserAuthConfigDto {
    allPermissions: { [key: string] : string; } | undefined;
    grantedPermissions: { [key: string] : string; } | undefined;

    constructor(data?: IAbpUserAuthConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["allPermissions"]) {
                this.allPermissions = {} as any;
                for (let key in data["allPermissions"]) {
                    if (data["allPermissions"].hasOwnProperty(key))
                        this.allPermissions[key] = data["allPermissions"][key];
                }
            }
            if (data["grantedPermissions"]) {
                this.grantedPermissions = {} as any;
                for (let key in data["grantedPermissions"]) {
                    if (data["grantedPermissions"].hasOwnProperty(key))
                        this.grantedPermissions[key] = data["grantedPermissions"][key];
                }
            }
        }
    }

    static fromJS(data: any): AbpUserAuthConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserAuthConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.allPermissions) {
            data["allPermissions"] = {};
            for (let key in this.allPermissions) {
                if (this.allPermissions.hasOwnProperty(key))
                    data["allPermissions"][key] = this.allPermissions[key];
            }
        }
        if (this.grantedPermissions) {
            data["grantedPermissions"] = {};
            for (let key in this.grantedPermissions) {
                if (this.grantedPermissions.hasOwnProperty(key))
                    data["grantedPermissions"][key] = this.grantedPermissions[key];
            }
        }
        return data; 
    }

    clone(): AbpUserAuthConfigDto {
        const json = this.toJSON();
        let result = new AbpUserAuthConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserAuthConfigDto {
    allPermissions: { [key: string] : string; } | undefined;
    grantedPermissions: { [key: string] : string; } | undefined;
}

export class AbpUserNavConfigDto implements IAbpUserNavConfigDto {
    menus: { [key: string] : UserMenu; } | undefined;

    constructor(data?: IAbpUserNavConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["menus"]) {
                this.menus = {} as any;
                for (let key in data["menus"]) {
                    if (data["menus"].hasOwnProperty(key))
                        this.menus[key] = data["menus"][key] ? UserMenu.fromJS(data["menus"][key]) : new UserMenu();
                }
            }
        }
    }

    static fromJS(data: any): AbpUserNavConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserNavConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.menus) {
            data["menus"] = {};
            for (let key in this.menus) {
                if (this.menus.hasOwnProperty(key))
                    data["menus"][key] = this.menus[key] ? this.menus[key].toJSON() : <any>undefined;
            }
        }
        return data; 
    }

    clone(): AbpUserNavConfigDto {
        const json = this.toJSON();
        let result = new AbpUserNavConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserNavConfigDto {
    menus: { [key: string] : UserMenu; } | undefined;
}

export class AbpUserSettingConfigDto implements IAbpUserSettingConfigDto {
    values: { [key: string] : string; } | undefined;

    constructor(data?: IAbpUserSettingConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["values"]) {
                this.values = {} as any;
                for (let key in data["values"]) {
                    if (data["values"].hasOwnProperty(key))
                        this.values[key] = data["values"][key];
                }
            }
        }
    }

    static fromJS(data: any): AbpUserSettingConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserSettingConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    data["values"][key] = this.values[key];
            }
        }
        return data; 
    }

    clone(): AbpUserSettingConfigDto {
        const json = this.toJSON();
        let result = new AbpUserSettingConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserSettingConfigDto {
    values: { [key: string] : string; } | undefined;
}

export class AbpUserClockConfigDto implements IAbpUserClockConfigDto {
    provider: string | undefined;

    constructor(data?: IAbpUserClockConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.provider = data["provider"];
        }
    }

    static fromJS(data: any): AbpUserClockConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserClockConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provider"] = this.provider;
        return data; 
    }

    clone(): AbpUserClockConfigDto {
        const json = this.toJSON();
        let result = new AbpUserClockConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserClockConfigDto {
    provider: string | undefined;
}

export class AbpUserTimingConfigDto implements IAbpUserTimingConfigDto {
    timeZoneInfo: AbpUserTimeZoneConfigDto | undefined;

    constructor(data?: IAbpUserTimingConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timeZoneInfo = data["timeZoneInfo"] ? AbpUserTimeZoneConfigDto.fromJS(data["timeZoneInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AbpUserTimingConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserTimingConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneInfo"] = this.timeZoneInfo ? this.timeZoneInfo.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AbpUserTimingConfigDto {
        const json = this.toJSON();
        let result = new AbpUserTimingConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserTimingConfigDto {
    timeZoneInfo: AbpUserTimeZoneConfigDto | undefined;
}

export class AbpUserSecurityConfigDto implements IAbpUserSecurityConfigDto {
    antiForgery: AbpUserAntiForgeryConfigDto | undefined;

    constructor(data?: IAbpUserSecurityConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.antiForgery = data["antiForgery"] ? AbpUserAntiForgeryConfigDto.fromJS(data["antiForgery"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AbpUserSecurityConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserSecurityConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["antiForgery"] = this.antiForgery ? this.antiForgery.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AbpUserSecurityConfigDto {
        const json = this.toJSON();
        let result = new AbpUserSecurityConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserSecurityConfigDto {
    antiForgery: AbpUserAntiForgeryConfigDto | undefined;
}

export class AbpMultiTenancySidesConfigDto implements IAbpMultiTenancySidesConfigDto {
    readonly host: MultiTenancySides | undefined;
    readonly tenant: MultiTenancySides | undefined;

    constructor(data?: IAbpMultiTenancySidesConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).host = data["host"];
            (<any>this).tenant = data["tenant"];
        }
    }

    static fromJS(data: any): AbpMultiTenancySidesConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpMultiTenancySidesConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["host"] = this.host;
        data["tenant"] = this.tenant;
        return data; 
    }

    clone(): AbpMultiTenancySidesConfigDto {
        const json = this.toJSON();
        let result = new AbpMultiTenancySidesConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpMultiTenancySidesConfigDto {
    host: MultiTenancySides | undefined;
    tenant: MultiTenancySides | undefined;
}

export enum MultiTenancySides {
    Tenant = <any>"Tenant", 
    Host = <any>"Host", 
}

export class AbpUserCurrentCultureConfigDto implements IAbpUserCurrentCultureConfigDto {
    name: string | undefined;
    displayName: string | undefined;

    constructor(data?: IAbpUserCurrentCultureConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AbpUserCurrentCultureConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserCurrentCultureConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): AbpUserCurrentCultureConfigDto {
        const json = this.toJSON();
        let result = new AbpUserCurrentCultureConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserCurrentCultureConfigDto {
    name: string | undefined;
    displayName: string | undefined;
}

export class LanguageInfo implements ILanguageInfo {
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDefault: boolean | undefined;
    isDisabled: boolean | undefined;
    readonly isRightToLeft: boolean | undefined;

    constructor(data?: ILanguageInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.icon = data["icon"];
            this.isDefault = data["isDefault"];
            this.isDisabled = data["isDisabled"];
            (<any>this).isRightToLeft = data["isRightToLeft"];
        }
    }

    static fromJS(data: any): LanguageInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDefault"] = this.isDefault;
        data["isDisabled"] = this.isDisabled;
        data["isRightToLeft"] = this.isRightToLeft;
        return data; 
    }

    clone(): LanguageInfo {
        const json = this.toJSON();
        let result = new LanguageInfo();
        result.init(json);
        return result;
    }
}

export interface ILanguageInfo {
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDefault: boolean | undefined;
    isDisabled: boolean | undefined;
    isRightToLeft: boolean | undefined;
}

export class AbpLocalizationSourceDto implements IAbpLocalizationSourceDto {
    name: string | undefined;
    type: string | undefined;

    constructor(data?: IAbpLocalizationSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): AbpLocalizationSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpLocalizationSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        return data; 
    }

    clone(): AbpLocalizationSourceDto {
        const json = this.toJSON();
        let result = new AbpLocalizationSourceDto();
        result.init(json);
        return result;
    }
}

export interface IAbpLocalizationSourceDto {
    name: string | undefined;
    type: string | undefined;
}

export class AbpStringValueDto implements IAbpStringValueDto {
    value: string | undefined;

    constructor(data?: IAbpStringValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
        }
    }

    static fromJS(data: any): AbpStringValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpStringValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data; 
    }

    clone(): AbpStringValueDto {
        const json = this.toJSON();
        let result = new AbpStringValueDto();
        result.init(json);
        return result;
    }
}

export interface IAbpStringValueDto {
    value: string | undefined;
}

export class UserMenu implements IUserMenu {
    name: string | undefined;
    displayName: string | undefined;
    customData: any | undefined;
    items: UserMenuItem[] | undefined;

    constructor(data?: IUserMenu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.customData = data["customData"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(UserMenuItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserMenu {
        data = typeof data === 'object' ? data : {};
        let result = new UserMenu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["customData"] = this.customData;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserMenu {
        const json = this.toJSON();
        let result = new UserMenu();
        result.init(json);
        return result;
    }
}

export interface IUserMenu {
    name: string | undefined;
    displayName: string | undefined;
    customData: any | undefined;
    items: UserMenuItem[] | undefined;
}

export class AbpUserTimeZoneConfigDto implements IAbpUserTimeZoneConfigDto {
    windows: AbpUserWindowsTimeZoneConfigDto | undefined;
    iana: AbpUserIanaTimeZoneConfigDto | undefined;

    constructor(data?: IAbpUserTimeZoneConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.windows = data["windows"] ? AbpUserWindowsTimeZoneConfigDto.fromJS(data["windows"]) : <any>undefined;
            this.iana = data["iana"] ? AbpUserIanaTimeZoneConfigDto.fromJS(data["iana"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AbpUserTimeZoneConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserTimeZoneConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["windows"] = this.windows ? this.windows.toJSON() : <any>undefined;
        data["iana"] = this.iana ? this.iana.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AbpUserTimeZoneConfigDto {
        const json = this.toJSON();
        let result = new AbpUserTimeZoneConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserTimeZoneConfigDto {
    windows: AbpUserWindowsTimeZoneConfigDto | undefined;
    iana: AbpUserIanaTimeZoneConfigDto | undefined;
}

export class AbpUserAntiForgeryConfigDto implements IAbpUserAntiForgeryConfigDto {
    tokenCookieName: string | undefined;
    tokenHeaderName: string | undefined;

    constructor(data?: IAbpUserAntiForgeryConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tokenCookieName = data["tokenCookieName"];
            this.tokenHeaderName = data["tokenHeaderName"];
        }
    }

    static fromJS(data: any): AbpUserAntiForgeryConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserAntiForgeryConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tokenCookieName"] = this.tokenCookieName;
        data["tokenHeaderName"] = this.tokenHeaderName;
        return data; 
    }

    clone(): AbpUserAntiForgeryConfigDto {
        const json = this.toJSON();
        let result = new AbpUserAntiForgeryConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserAntiForgeryConfigDto {
    tokenCookieName: string | undefined;
    tokenHeaderName: string | undefined;
}

export class UserMenuItem implements IUserMenuItem {
    name: string | undefined;
    icon: string | undefined;
    displayName: string | undefined;
    order: number | undefined;
    url: string | undefined;
    customData: any | undefined;
    target: string | undefined;
    isEnabled: boolean | undefined;
    isVisible: boolean | undefined;
    items: UserMenuItem[] | undefined;

    constructor(data?: IUserMenuItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.icon = data["icon"];
            this.displayName = data["displayName"];
            this.order = data["order"];
            this.url = data["url"];
            this.customData = data["customData"];
            this.target = data["target"];
            this.isEnabled = data["isEnabled"];
            this.isVisible = data["isVisible"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(UserMenuItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserMenuItem {
        data = typeof data === 'object' ? data : {};
        let result = new UserMenuItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["displayName"] = this.displayName;
        data["order"] = this.order;
        data["url"] = this.url;
        data["customData"] = this.customData;
        data["target"] = this.target;
        data["isEnabled"] = this.isEnabled;
        data["isVisible"] = this.isVisible;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserMenuItem {
        const json = this.toJSON();
        let result = new UserMenuItem();
        result.init(json);
        return result;
    }
}

export interface IUserMenuItem {
    name: string | undefined;
    icon: string | undefined;
    displayName: string | undefined;
    order: number | undefined;
    url: string | undefined;
    customData: any | undefined;
    target: string | undefined;
    isEnabled: boolean | undefined;
    isVisible: boolean | undefined;
    items: UserMenuItem[] | undefined;
}

export class AbpUserWindowsTimeZoneConfigDto implements IAbpUserWindowsTimeZoneConfigDto {
    timeZoneId: string | undefined;
    baseUtcOffsetInMilliseconds: number | undefined;
    currentUtcOffsetInMilliseconds: number | undefined;
    isDaylightSavingTimeNow: boolean | undefined;

    constructor(data?: IAbpUserWindowsTimeZoneConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timeZoneId = data["timeZoneId"];
            this.baseUtcOffsetInMilliseconds = data["baseUtcOffsetInMilliseconds"];
            this.currentUtcOffsetInMilliseconds = data["currentUtcOffsetInMilliseconds"];
            this.isDaylightSavingTimeNow = data["isDaylightSavingTimeNow"];
        }
    }

    static fromJS(data: any): AbpUserWindowsTimeZoneConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserWindowsTimeZoneConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneId"] = this.timeZoneId;
        data["baseUtcOffsetInMilliseconds"] = this.baseUtcOffsetInMilliseconds;
        data["currentUtcOffsetInMilliseconds"] = this.currentUtcOffsetInMilliseconds;
        data["isDaylightSavingTimeNow"] = this.isDaylightSavingTimeNow;
        return data; 
    }

    clone(): AbpUserWindowsTimeZoneConfigDto {
        const json = this.toJSON();
        let result = new AbpUserWindowsTimeZoneConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserWindowsTimeZoneConfigDto {
    timeZoneId: string | undefined;
    baseUtcOffsetInMilliseconds: number | undefined;
    currentUtcOffsetInMilliseconds: number | undefined;
    isDaylightSavingTimeNow: boolean | undefined;
}

export class AbpUserIanaTimeZoneConfigDto implements IAbpUserIanaTimeZoneConfigDto {
    timeZoneId: string | undefined;

    constructor(data?: IAbpUserIanaTimeZoneConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timeZoneId = data["timeZoneId"];
        }
    }

    static fromJS(data: any): AbpUserIanaTimeZoneConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserIanaTimeZoneConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneId"] = this.timeZoneId;
        return data; 
    }

    clone(): AbpUserIanaTimeZoneConfigDto {
        const json = this.toJSON();
        let result = new AbpUserIanaTimeZoneConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserIanaTimeZoneConfigDto {
    timeZoneId: string | undefined;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.signInToken = data["signInToken"];
            this.encodedUserId = data["encodedUserId"];
            this.encodedTenantId = data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data; 
    }

    clone(): UpdateUserSignInTokenOutput {
        const json = this.toJSON();
        let result = new UpdateUserSignInTokenOutput();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

export class CreateOrUpdateSourceInput implements ICreateOrUpdateSourceInput {
    source: SourceEditDto;

    constructor(data?: ICreateOrUpdateSourceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.source = new SourceEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.source = data["source"] ? SourceEditDto.fromJS(data["source"]) : new SourceEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateSourceInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateSourceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateSourceInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateSourceInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateSourceInput {
    source: SourceEditDto;
}

export class SourceEditDto implements ISourceEditDto {
    /** Id */
    id: string | undefined;
    /** SourceName */
    sourceName: string;
    /** SourceCode */
    sourceCode: string;
    /** Discount */
    discount: number | undefined;

    constructor(data?: ISourceEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.sourceName = data["sourceName"];
            this.sourceCode = data["sourceCode"];
            this.discount = data["discount"];
        }
    }

    static fromJS(data: any): SourceEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SourceEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sourceName"] = this.sourceName;
        data["sourceCode"] = this.sourceCode;
        data["discount"] = this.discount;
        return data; 
    }

    clone(): SourceEditDto {
        const json = this.toJSON();
        let result = new SourceEditDto();
        result.init(json);
        return result;
    }
}

export interface ISourceEditDto {
    /** Id */
    id: string | undefined;
    /** SourceName */
    sourceName: string;
    /** SourceCode */
    sourceCode: string;
    /** Discount */
    discount: number | undefined;
}

export class SourceListDto implements ISourceListDto {
    /** BranchId */
    branchId: string | undefined;
    /** SourceName */
    sourceName: string;
    /** SourceCode */
    sourceCode: string;
    /** Discount */
    discount: number | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ISourceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.sourceName = data["sourceName"];
            this.sourceCode = data["sourceCode"];
            this.discount = data["discount"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SourceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SourceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["sourceName"] = this.sourceName;
        data["sourceCode"] = this.sourceCode;
        data["discount"] = this.discount;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): SourceListDto {
        const json = this.toJSON();
        let result = new SourceListDto();
        result.init(json);
        return result;
    }
}

export interface ISourceListDto {
    /** BranchId */
    branchId: string | undefined;
    /** SourceName */
    sourceName: string;
    /** SourceCode */
    sourceCode: string;
    /** Discount */
    discount: number | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetSourceForEditOutput implements IGetSourceForEditOutput {
    source: SourceEditDto | undefined;

    constructor(data?: IGetSourceForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.source = data["source"] ? SourceEditDto.fromJS(data["source"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSourceForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSourceForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetSourceForEditOutput {
        const json = this.toJSON();
        let result = new GetSourceForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetSourceForEditOutput {
    source: SourceEditDto | undefined;
}

export class PagedResultDtoOfSourceListDto implements IPagedResultDtoOfSourceListDto {
    totalCount: number | undefined;
    items: SourceListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSourceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(SourceListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSourceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSourceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfSourceListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfSourceListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfSourceListDto {
    totalCount: number | undefined;
    items: SourceListDto[] | undefined;
}

export class EntityDto implements IEntityDto {
    id: number | undefined;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDto {
        const json = this.toJSON();
        let result = new EntityDto();
        result.init(json);
        return result;
    }
}

export interface IEntityDto {
    id: number | undefined;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    sendActivationEmail: boolean | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.connectionString = data["connectionString"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndUtc = data["subscriptionEndUtc"] ? moment(data["subscriptionEndUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndUtc"] = this.subscriptionEndUtc ? this.subscriptionEndUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data; 
    }

    clone(): CreateTenantInput {
        const json = this.toJSON();
        let result = new CreateTenantInput();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    sendActivationEmail: boolean | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.connectionString = data["connectionString"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndUtc = data["subscriptionEndUtc"] ? moment(data["subscriptionEndUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndUtc"] = this.subscriptionEndUtc ? this.subscriptionEndUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantEditDto {
        const json = this.toJSON();
        let result = new TenantEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount: number | undefined;
    items: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTenantListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTenantListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount: number | undefined;
    items: TenantListDto[] | undefined;
}

export class TenantListDto implements ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    subscriptionEndUtc: moment.Moment | undefined;
    editionId: number | undefined;
    id: number | undefined;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.editionDisplayName = data["editionDisplayName"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.subscriptionEndUtc = data["subscriptionEndUtc"] ? moment(data["subscriptionEndUtc"].toString()) : <any>undefined;
            this.editionId = data["editionId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["editionDisplayName"] = this.editionDisplayName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["subscriptionEndUtc"] = this.subscriptionEndUtc ? this.subscriptionEndUtc.toISOString() : <any>undefined;
        data["editionId"] = this.editionId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantListDto {
        const json = this.toJSON();
        let result = new TenantListDto();
        result.init(json);
        return result;
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    subscriptionEndUtc: moment.Moment | undefined;
    editionId: number | undefined;
    id: number | undefined;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [] as any;
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetTenantFeaturesEditOutput {
        const json = this.toJSON();
        let result = new GetTenantFeaturesEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id: number | undefined;
    featureValues: NameValueDto[];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UpdateTenantFeaturesInput {
        const json = this.toJSON();
        let result = new UpdateTenantFeaturesInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number | undefined;
    featureValues: NameValueDto[];
}

/** 创建租户的DTO信息 */
export class CreateTenantDto implements ICreateTenantDto {
    /** 全局唯一的租户Id */
    tenancyName: string;
    /** 租户名称 */
    name: string;
    userName: string | undefined;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean | undefined;
    /** 验证码 */
    verificationCode: string | undefined;
    /** 租户管理员密码 */
    tenantAdminPassword: string | undefined;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.userName = data["userName"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
            this.verificationCode = data["verificationCode"];
            this.tenantAdminPassword = data["tenantAdminPassword"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["verificationCode"] = this.verificationCode;
        data["tenantAdminPassword"] = this.tenantAdminPassword;
        return data; 
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

/** 创建租户的DTO信息 */
export interface ICreateTenantDto {
    /** 全局唯一的租户Id */
    tenancyName: string;
    /** 租户名称 */
    name: string;
    userName: string | undefined;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean | undefined;
    /** 验证码 */
    verificationCode: string | undefined;
    /** 租户管理员密码 */
    tenantAdminPassword: string | undefined;
}

export class RegisterTenantResultDto implements IRegisterTenantResultDto {
    /** 租户Id */
    tenantId: number | undefined;
    /** 租户是否激活 */
    isActive: boolean | undefined;
    /** 租户启用了用户登陆验证码 */
    useCaptchaOnUserLogin: boolean | undefined;

    constructor(data?: IRegisterTenantResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.isActive = data["isActive"];
            this.useCaptchaOnUserLogin = data["useCaptchaOnUserLogin"];
        }
    }

    static fromJS(data: any): RegisterTenantResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["isActive"] = this.isActive;
        data["useCaptchaOnUserLogin"] = this.useCaptchaOnUserLogin;
        return data; 
    }

    clone(): RegisterTenantResultDto {
        const json = this.toJSON();
        let result = new RegisterTenantResultDto();
        result.init(json);
        return result;
    }
}

export interface IRegisterTenantResultDto {
    /** 租户Id */
    tenantId: number | undefined;
    /** 租户是否激活 */
    isActive: boolean | undefined;
    /** 租户启用了用户登陆验证码 */
    useCaptchaOnUserLogin: boolean | undefined;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general: GeneralSettingsEditDto | undefined;
    userManagement: TenantUserManagementSettingsEditDto;
    email: EmailSettingsEditDto | undefined;
    ldap: LdapSettingsEditDto | undefined;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto | undefined;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : <any>undefined;
            this.userManagement = data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : <any>undefined;
            this.ldap = data["ldap"] ? LdapSettingsEditDto.fromJS(data["ldap"]) : <any>undefined;
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? TenantBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        return data; 
    }

    clone(): TenantSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto | undefined;
    userManagement: TenantUserManagementSettingsEditDto;
    email: EmailSettingsEditDto | undefined;
    ldap: LdapSettingsEditDto | undefined;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto | undefined;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    /** 是否启用注册 */
    allowSelfRegistration: boolean | undefined;
    /** 是否新注册用户默认激活 */
    isNewRegisteredUserActiveByDefault: boolean | undefined;
    /** 是否必须校验邮箱才能登陆 */
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    /** 是否注册使用验证码 */
    useCaptchaOnUserRegistration: boolean | undefined;
    /** 注册验证码类型 */
    captchaOnUserRegistrationType: ValidateCodeType | undefined;
    /** 注册验证码长度 */
    captchaOnUserRegistrationLength: number | undefined;
    /** 是否登陆使用验证码 */
    useCaptchaOnUserLogin: boolean | undefined;
    /** 登陆验证码类型 */
    captchaOnUserLoginType: ValidateCodeType | undefined;
    /** 登陆验证码长度 */
    captchaOnUserLoginLength: number | undefined;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnUserRegistration = data["useCaptchaOnUserRegistration"];
            this.captchaOnUserRegistrationType = data["captchaOnUserRegistrationType"];
            this.captchaOnUserRegistrationLength = data["captchaOnUserRegistrationLength"];
            this.useCaptchaOnUserLogin = data["useCaptchaOnUserLogin"];
            this.captchaOnUserLoginType = data["captchaOnUserLoginType"];
            this.captchaOnUserLoginLength = data["captchaOnUserLoginLength"];
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnUserRegistration"] = this.useCaptchaOnUserRegistration;
        data["captchaOnUserRegistrationType"] = this.captchaOnUserRegistrationType;
        data["captchaOnUserRegistrationLength"] = this.captchaOnUserRegistrationLength;
        data["useCaptchaOnUserLogin"] = this.useCaptchaOnUserLogin;
        data["captchaOnUserLoginType"] = this.captchaOnUserLoginType;
        data["captchaOnUserLoginLength"] = this.captchaOnUserLoginLength;
        return data; 
    }

    clone(): TenantUserManagementSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantUserManagementSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantUserManagementSettingsEditDto {
    /** 是否启用注册 */
    allowSelfRegistration: boolean | undefined;
    /** 是否新注册用户默认激活 */
    isNewRegisteredUserActiveByDefault: boolean | undefined;
    /** 是否必须校验邮箱才能登陆 */
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    /** 是否注册使用验证码 */
    useCaptchaOnUserRegistration: boolean | undefined;
    /** 注册验证码类型 */
    captchaOnUserRegistrationType: ValidateCodeType | undefined;
    /** 注册验证码长度 */
    captchaOnUserRegistrationLength: number | undefined;
    /** 是否登陆使用验证码 */
    useCaptchaOnUserLogin: boolean | undefined;
    /** 登陆验证码类型 */
    captchaOnUserLoginType: ValidateCodeType | undefined;
    /** 登陆验证码长度 */
    captchaOnUserLoginLength: number | undefined;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    /** 模块启用 */
    isModuleEnabled: boolean | undefined;
    /** 启用 */
    isEnabled: boolean | undefined;
    domain: string | undefined;
    /** 用户名 */
    userName: string | undefined;
    /** 密码 */
    password: string | undefined;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isModuleEnabled = data["isModuleEnabled"];
            this.isEnabled = data["isEnabled"];
            this.domain = data["domain"];
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }

    clone(): LdapSettingsEditDto {
        const json = this.toJSON();
        let result = new LdapSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ILdapSettingsEditDto {
    /** 模块启用 */
    isModuleEnabled: boolean | undefined;
    /** 启用 */
    isEnabled: boolean | undefined;
    domain: string | undefined;
    /** 用户名 */
    userName: string | undefined;
    /** 密码 */
    password: string | undefined;
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
            this.taxVatNo = data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data; 
    }

    clone(): TenantBillingSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantBillingSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
}

export class CreateOrUpdateTicketInput implements ICreateOrUpdateTicketInput {
    ticket: TicketEditDto;

    constructor(data?: ICreateOrUpdateTicketInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticket = new TicketEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ticket = data["ticket"] ? TicketEditDto.fromJS(data["ticket"]) : new TicketEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTicketInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTicketInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTicketInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTicketInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTicketInput {
    ticket: TicketEditDto;
}

export class TicketEditDto implements ITicketEditDto {
    /** Id */
    id: string | undefined;
    /** TicketName */
    ticketName: string;
    /** TicketCode */
    ticketCode: string | undefined;
    /** TicketMode */
    ticketMode: TicketModeEnum | undefined;
    /** TicketType */
    ticketType: TicketTypeEnum | undefined;
    /** CheckMethod */
    checkMethod: CheckMethodEnum | undefined;
    /** TicketClassify */
    ticketClassify: TicketClassifyEnum | undefined;
    /** CheckNum */
    checkNum: number | undefined;
    /** EffectiveLong */
    effectiveLong: number | undefined;
    /** UnitPrice */
    unitPrice: number | undefined;
    /** TicketLength */
    ticketLength: number | undefined;
    /** UpperLimit */
    upperLimit: number | undefined;
    /** LowerLimit */
    lowerLimit: number | undefined;
    /** AudioName */
    audioName: string | undefined;
    /** AuditStatus */
    auditStatus: AuditStatusEnum | undefined;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    /** Sort */
    sort: number | undefined;

    constructor(data?: ITicketEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ticketName = data["ticketName"];
            this.ticketCode = data["ticketCode"];
            this.ticketMode = data["ticketMode"];
            this.ticketType = data["ticketType"];
            this.checkMethod = data["checkMethod"];
            this.ticketClassify = data["ticketClassify"];
            this.checkNum = data["checkNum"];
            this.effectiveLong = data["effectiveLong"];
            this.unitPrice = data["unitPrice"];
            this.ticketLength = data["ticketLength"];
            this.upperLimit = data["upperLimit"];
            this.lowerLimit = data["lowerLimit"];
            this.audioName = data["audioName"];
            this.auditStatus = data["auditStatus"];
            this.isEnabled = data["isEnabled"];
            this.sort = data["sort"];
        }
    }

    static fromJS(data: any): TicketEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketName"] = this.ticketName;
        data["ticketCode"] = this.ticketCode;
        data["ticketMode"] = this.ticketMode;
        data["ticketType"] = this.ticketType;
        data["checkMethod"] = this.checkMethod;
        data["ticketClassify"] = this.ticketClassify;
        data["checkNum"] = this.checkNum;
        data["effectiveLong"] = this.effectiveLong;
        data["unitPrice"] = this.unitPrice;
        data["ticketLength"] = this.ticketLength;
        data["upperLimit"] = this.upperLimit;
        data["lowerLimit"] = this.lowerLimit;
        data["audioName"] = this.audioName;
        data["auditStatus"] = this.auditStatus;
        data["isEnabled"] = this.isEnabled;
        data["sort"] = this.sort;
        return data; 
    }

    clone(): TicketEditDto {
        const json = this.toJSON();
        let result = new TicketEditDto();
        result.init(json);
        return result;
    }
}

export interface ITicketEditDto {
    /** Id */
    id: string | undefined;
    /** TicketName */
    ticketName: string;
    /** TicketCode */
    ticketCode: string | undefined;
    /** TicketMode */
    ticketMode: TicketModeEnum | undefined;
    /** TicketType */
    ticketType: TicketTypeEnum | undefined;
    /** CheckMethod */
    checkMethod: CheckMethodEnum | undefined;
    /** TicketClassify */
    ticketClassify: TicketClassifyEnum | undefined;
    /** CheckNum */
    checkNum: number | undefined;
    /** EffectiveLong */
    effectiveLong: number | undefined;
    /** UnitPrice */
    unitPrice: number | undefined;
    /** TicketLength */
    ticketLength: number | undefined;
    /** UpperLimit */
    upperLimit: number | undefined;
    /** LowerLimit */
    lowerLimit: number | undefined;
    /** AudioName */
    audioName: string | undefined;
    /** AuditStatus */
    auditStatus: AuditStatusEnum | undefined;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    /** Sort */
    sort: number | undefined;
}

export class TicketListDto implements ITicketListDto {
    /** BranchId */
    branchId: string | undefined;
    /** TicketName */
    ticketName: string;
    /** TicketCode */
    ticketCode: string | undefined;
    /** TicketMode */
    ticketMode: TicketModeEnum | undefined;
    /** TicketType */
    ticketType: TicketTypeEnum | undefined;
    /** CheckMethod */
    checkMethod: CheckMethodEnum | undefined;
    /** TicketClassify */
    ticketClassify: TicketClassifyEnum | undefined;
    /** CheckNum */
    checkNum: number | undefined;
    /** EffectiveLong */
    effectiveLong: number | undefined;
    /** UnitPrice */
    unitPrice: number | undefined;
    /** TicketLength */
    ticketLength: number | undefined;
    /** UpperLimit */
    upperLimit: number | undefined;
    /** LowerLimit */
    lowerLimit: number | undefined;
    /** AudioName */
    audioName: string | undefined;
    /** AuditStatus */
    auditStatus: AuditStatusEnum | undefined;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    /** Sort */
    sort: number | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ITicketListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketName = data["ticketName"];
            this.ticketCode = data["ticketCode"];
            this.ticketMode = data["ticketMode"];
            this.ticketType = data["ticketType"];
            this.checkMethod = data["checkMethod"];
            this.ticketClassify = data["ticketClassify"];
            this.checkNum = data["checkNum"];
            this.effectiveLong = data["effectiveLong"];
            this.unitPrice = data["unitPrice"];
            this.ticketLength = data["ticketLength"];
            this.upperLimit = data["upperLimit"];
            this.lowerLimit = data["lowerLimit"];
            this.audioName = data["audioName"];
            this.auditStatus = data["auditStatus"];
            this.isEnabled = data["isEnabled"];
            this.sort = data["sort"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketName"] = this.ticketName;
        data["ticketCode"] = this.ticketCode;
        data["ticketMode"] = this.ticketMode;
        data["ticketType"] = this.ticketType;
        data["checkMethod"] = this.checkMethod;
        data["ticketClassify"] = this.ticketClassify;
        data["checkNum"] = this.checkNum;
        data["effectiveLong"] = this.effectiveLong;
        data["unitPrice"] = this.unitPrice;
        data["ticketLength"] = this.ticketLength;
        data["upperLimit"] = this.upperLimit;
        data["lowerLimit"] = this.lowerLimit;
        data["audioName"] = this.audioName;
        data["auditStatus"] = this.auditStatus;
        data["isEnabled"] = this.isEnabled;
        data["sort"] = this.sort;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketListDto {
        const json = this.toJSON();
        let result = new TicketListDto();
        result.init(json);
        return result;
    }
}

export interface ITicketListDto {
    /** BranchId */
    branchId: string | undefined;
    /** TicketName */
    ticketName: string;
    /** TicketCode */
    ticketCode: string | undefined;
    /** TicketMode */
    ticketMode: TicketModeEnum | undefined;
    /** TicketType */
    ticketType: TicketTypeEnum | undefined;
    /** CheckMethod */
    checkMethod: CheckMethodEnum | undefined;
    /** TicketClassify */
    ticketClassify: TicketClassifyEnum | undefined;
    /** CheckNum */
    checkNum: number | undefined;
    /** EffectiveLong */
    effectiveLong: number | undefined;
    /** UnitPrice */
    unitPrice: number | undefined;
    /** TicketLength */
    ticketLength: number | undefined;
    /** UpperLimit */
    upperLimit: number | undefined;
    /** LowerLimit */
    lowerLimit: number | undefined;
    /** AudioName */
    audioName: string | undefined;
    /** AuditStatus */
    auditStatus: AuditStatusEnum | undefined;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    /** Sort */
    sort: number | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetTicketForEditOutput implements IGetTicketForEditOutput {
    ticket: TicketEditDto | undefined;

    constructor(data?: IGetTicketForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticket = data["ticket"] ? TicketEditDto.fromJS(data["ticket"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTicketForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTicketForEditOutput {
        const json = this.toJSON();
        let result = new GetTicketForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTicketForEditOutput {
    ticket: TicketEditDto | undefined;
}

export class GetTicketsInput implements IGetTicketsInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetTicketsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetTicketsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetTicketsInput {
        const json = this.toJSON();
        let result = new GetTicketsInput();
        result.init(json);
        return result;
    }
}

export interface IGetTicketsInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfTicketListDto implements IPagedResultDtoOfTicketListDto {
    totalCount: number | undefined;
    items: TicketListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTicketListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TicketListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTicketListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTicketListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTicketListDto {
    totalCount: number | undefined;
    items: TicketListDto[] | undefined;
}

export class UploadAudioDto implements IUploadAudioDto {
    uri: string | undefined;

    constructor(data?: IUploadAudioDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.uri = data["uri"];
        }
    }

    static fromJS(data: any): UploadAudioDto {
        data = typeof data === 'object' ? data : {};
        let result = new UploadAudioDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uri"] = this.uri;
        return data; 
    }

    clone(): UploadAudioDto {
        const json = this.toJSON();
        let result = new UploadAudioDto();
        result.init(json);
        return result;
    }
}

export interface IUploadAudioDto {
    uri: string | undefined;
}

export class CreateOrUpdateAccountInput implements ICreateOrUpdateAccountInput {
    account: AccountEditDto;

    constructor(data?: ICreateOrUpdateAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.account = new AccountEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.account = data["account"] ? AccountEditDto.fromJS(data["account"]) : new AccountEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateAccountInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateAccountInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateAccountInput {
    account: AccountEditDto;
}

export class AccountEditDto implements IAccountEditDto {
    /** Id */
    id: string | undefined;
    /** AccountNo */
    accountNo: string;
    /** AccountDate */
    accountDate: moment.Moment;
    /** Quantity */
    quantity: number;
    /** Amount */
    amount: number;
    /** AccountStatus */
    accountStatus: AccountStatusEnum | undefined;
    /** CollectiorId */
    collectiorId: number | undefined;
    /** CollectionTime */
    collectionTime: moment.Moment | undefined;
    /** 支付方式 */
    payMethodId: string | undefined;
    /** 备注 */
    remark: string | undefined;
    /** 流水号，包括银行名称，银行账号，流水号 */
    voucherNo: string | undefined;
    /** 应退金额 */
    rAmount: number | undefined;
    /** 总金额 */
    totalAmount: number | undefined;
    /** 应退数量 */
    rQuantity: number | undefined;
    /** 总数量 */
    totalQuantity: number | undefined;

    constructor(data?: IAccountEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.accountNo = data["accountNo"];
            this.accountDate = data["accountDate"] ? moment(data["accountDate"].toString()) : <any>undefined;
            this.quantity = data["quantity"];
            this.amount = data["amount"];
            this.accountStatus = data["accountStatus"];
            this.collectiorId = data["collectiorId"];
            this.collectionTime = data["collectionTime"] ? moment(data["collectionTime"].toString()) : <any>undefined;
            this.payMethodId = data["payMethodId"];
            this.remark = data["remark"];
            this.voucherNo = data["voucherNo"];
            this.rAmount = data["rAmount"];
            this.totalAmount = data["totalAmount"];
            this.rQuantity = data["rQuantity"];
            this.totalQuantity = data["totalQuantity"];
        }
    }

    static fromJS(data: any): AccountEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accountNo"] = this.accountNo;
        data["accountDate"] = this.accountDate ? this.accountDate.toISOString() : <any>undefined;
        data["quantity"] = this.quantity;
        data["amount"] = this.amount;
        data["accountStatus"] = this.accountStatus;
        data["collectiorId"] = this.collectiorId;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["payMethodId"] = this.payMethodId;
        data["remark"] = this.remark;
        data["voucherNo"] = this.voucherNo;
        data["rAmount"] = this.rAmount;
        data["totalAmount"] = this.totalAmount;
        data["rQuantity"] = this.rQuantity;
        data["totalQuantity"] = this.totalQuantity;
        return data; 
    }

    clone(): AccountEditDto {
        const json = this.toJSON();
        let result = new AccountEditDto();
        result.init(json);
        return result;
    }
}

export interface IAccountEditDto {
    /** Id */
    id: string | undefined;
    /** AccountNo */
    accountNo: string;
    /** AccountDate */
    accountDate: moment.Moment;
    /** Quantity */
    quantity: number;
    /** Amount */
    amount: number;
    /** AccountStatus */
    accountStatus: AccountStatusEnum | undefined;
    /** CollectiorId */
    collectiorId: number | undefined;
    /** CollectionTime */
    collectionTime: moment.Moment | undefined;
    /** 支付方式 */
    payMethodId: string | undefined;
    /** 备注 */
    remark: string | undefined;
    /** 流水号，包括银行名称，银行账号，流水号 */
    voucherNo: string | undefined;
    /** 应退金额 */
    rAmount: number | undefined;
    /** 总金额 */
    totalAmount: number | undefined;
    /** 应退数量 */
    rQuantity: number | undefined;
    /** 总数量 */
    totalQuantity: number | undefined;
}

export class AccountListDto implements IAccountListDto {
    /** BranchId */
    branchId: string | undefined;
    /** 结账单号 */
    accountNo: string;
    /** 结账日期 */
    accountDate: moment.Moment;
    /** 数量 */
    quantity: number;
    /** 金额 */
    amount: number;
    /** 收款状态 */
    accountStatus: AccountStatusEnum | undefined;
    /** 收款人标识 */
    collectiorId: number | undefined;
    /** 收款人 */
    collectior: User | undefined;
    /** 收款时间 */
    collectionTime: moment.Moment;
    /** 支付方式 */
    payMethodId: string | undefined;
    payMethod: PayMethod | undefined;
    /** 备注 */
    remark: string | undefined;
    /** 流水号，包括银行名称，银行账号，流水号 */
    voucherNo: string | undefined;
    /** 应退金额 */
    rAmount: number | undefined;
    /** 总金额 */
    totalAmount: number | undefined;
    /** 应退数量 */
    rQuantity: number | undefined;
    /** 总数量 */
    totalQuantity: number | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IAccountListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.accountNo = data["accountNo"];
            this.accountDate = data["accountDate"] ? moment(data["accountDate"].toString()) : <any>undefined;
            this.quantity = data["quantity"];
            this.amount = data["amount"];
            this.accountStatus = data["accountStatus"];
            this.collectiorId = data["collectiorId"];
            this.collectior = data["collectior"] ? User.fromJS(data["collectior"]) : <any>undefined;
            this.collectionTime = data["collectionTime"] ? moment(data["collectionTime"].toString()) : <any>undefined;
            this.payMethodId = data["payMethodId"];
            this.payMethod = data["payMethod"] ? PayMethod.fromJS(data["payMethod"]) : <any>undefined;
            this.remark = data["remark"];
            this.voucherNo = data["voucherNo"];
            this.rAmount = data["rAmount"];
            this.totalAmount = data["totalAmount"];
            this.rQuantity = data["rQuantity"];
            this.totalQuantity = data["totalQuantity"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AccountListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["accountNo"] = this.accountNo;
        data["accountDate"] = this.accountDate ? this.accountDate.toISOString() : <any>undefined;
        data["quantity"] = this.quantity;
        data["amount"] = this.amount;
        data["accountStatus"] = this.accountStatus;
        data["collectiorId"] = this.collectiorId;
        data["collectior"] = this.collectior ? this.collectior.toJSON() : <any>undefined;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["payMethodId"] = this.payMethodId;
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        data["remark"] = this.remark;
        data["voucherNo"] = this.voucherNo;
        data["rAmount"] = this.rAmount;
        data["totalAmount"] = this.totalAmount;
        data["rQuantity"] = this.rQuantity;
        data["totalQuantity"] = this.totalQuantity;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AccountListDto {
        const json = this.toJSON();
        let result = new AccountListDto();
        result.init(json);
        return result;
    }
}

export interface IAccountListDto {
    /** BranchId */
    branchId: string | undefined;
    /** 结账单号 */
    accountNo: string;
    /** 结账日期 */
    accountDate: moment.Moment;
    /** 数量 */
    quantity: number;
    /** 金额 */
    amount: number;
    /** 收款状态 */
    accountStatus: AccountStatusEnum | undefined;
    /** 收款人标识 */
    collectiorId: number | undefined;
    /** 收款人 */
    collectior: User | undefined;
    /** 收款时间 */
    collectionTime: moment.Moment;
    /** 支付方式 */
    payMethodId: string | undefined;
    payMethod: PayMethod | undefined;
    /** 备注 */
    remark: string | undefined;
    /** 流水号，包括银行名称，银行账号，流水号 */
    voucherNo: string | undefined;
    /** 应退金额 */
    rAmount: number | undefined;
    /** 总金额 */
    totalAmount: number | undefined;
    /** 应退数量 */
    rQuantity: number | undefined;
    /** 总数量 */
    totalQuantity: number | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

/** 账单明细 */
export class AccountDetailDto implements IAccountDetailDto {
    /** ActivityNo */
    activityNo: string | undefined;
    /** SourceId */
    sourceId: string | undefined;
    /** Source */
    source: Source | undefined;
    /** ScheduleId */
    scheduleId: string | undefined;
    /** Schedule */
    schedule: Schedule | undefined;
    /** OrgActivityId */
    orgActivityId: string | undefined;
    /** ActivityDate */
    activityDate: moment.Moment | undefined;
    /** PlayDate */
    playDate: moment.Moment | undefined;
    /** CustomerId */
    customerId: string | undefined;
    /** Customer */
    customer: Customer | undefined;
    /** Buyer */
    buyer: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** PayMethodId */
    payMethodId: string | undefined;
    /** PayMethod */
    payMethod: PayMethod | undefined;
    /** VoucherNo */
    voucherNo: string | undefined;
    /** PayStatus */
    payStatus: PayStatusEnum | undefined;
    /** ActivityType */
    activityType: ActivityTypeEnum | undefined;
    /** Remark */
    remark: string | undefined;
    /** IsPrint */
    isPrint: boolean | undefined;
    /** Closed */
    closed: boolean | undefined;
    /** TotalQuantity */
    totalQuantity: number | undefined;
    /** TotalAmount */
    totalAmount: number | undefined;
    /** AccountsId */
    accountsId: string | undefined;
    /** Account */
    account: Account | undefined;
    /** OrderType */
    orderType: OrderTypeEnum | undefined;
    /** 账单对应的票列表 */
    tickets: TicketDetailListDto[] | undefined;

    constructor(data?: IAccountDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.activityNo = data["activityNo"];
            this.sourceId = data["sourceId"];
            this.source = data["source"] ? Source.fromJS(data["source"]) : <any>undefined;
            this.scheduleId = data["scheduleId"];
            this.schedule = data["schedule"] ? Schedule.fromJS(data["schedule"]) : <any>undefined;
            this.orgActivityId = data["orgActivityId"];
            this.activityDate = data["activityDate"] ? moment(data["activityDate"].toString()) : <any>undefined;
            this.playDate = data["playDate"] ? moment(data["playDate"].toString()) : <any>undefined;
            this.customerId = data["customerId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.buyer = data["buyer"];
            this.mobile = data["mobile"];
            this.payMethodId = data["payMethodId"];
            this.payMethod = data["payMethod"] ? PayMethod.fromJS(data["payMethod"]) : <any>undefined;
            this.voucherNo = data["voucherNo"];
            this.payStatus = data["payStatus"];
            this.activityType = data["activityType"];
            this.remark = data["remark"];
            this.isPrint = data["isPrint"];
            this.closed = data["closed"];
            this.totalQuantity = data["totalQuantity"];
            this.totalAmount = data["totalAmount"];
            this.accountsId = data["accountsId"];
            this.account = data["account"] ? Account.fromJS(data["account"]) : <any>undefined;
            this.orderType = data["orderType"];
            if (data["tickets"] && data["tickets"].constructor === Array) {
                this.tickets = [] as any;
                for (let item of data["tickets"])
                    this.tickets.push(TicketDetailListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityNo"] = this.activityNo;
        data["sourceId"] = this.sourceId;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["scheduleId"] = this.scheduleId;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["orgActivityId"] = this.orgActivityId;
        data["activityDate"] = this.activityDate ? this.activityDate.toISOString() : <any>undefined;
        data["playDate"] = this.playDate ? this.playDate.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["buyer"] = this.buyer;
        data["mobile"] = this.mobile;
        data["payMethodId"] = this.payMethodId;
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        data["voucherNo"] = this.voucherNo;
        data["payStatus"] = this.payStatus;
        data["activityType"] = this.activityType;
        data["remark"] = this.remark;
        data["isPrint"] = this.isPrint;
        data["closed"] = this.closed;
        data["totalQuantity"] = this.totalQuantity;
        data["totalAmount"] = this.totalAmount;
        data["accountsId"] = this.accountsId;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["orderType"] = this.orderType;
        if (this.tickets && this.tickets.constructor === Array) {
            data["tickets"] = [];
            for (let item of this.tickets)
                data["tickets"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AccountDetailDto {
        const json = this.toJSON();
        let result = new AccountDetailDto();
        result.init(json);
        return result;
    }
}

/** 账单明细 */
export interface IAccountDetailDto {
    /** ActivityNo */
    activityNo: string | undefined;
    /** SourceId */
    sourceId: string | undefined;
    /** Source */
    source: Source | undefined;
    /** ScheduleId */
    scheduleId: string | undefined;
    /** Schedule */
    schedule: Schedule | undefined;
    /** OrgActivityId */
    orgActivityId: string | undefined;
    /** ActivityDate */
    activityDate: moment.Moment | undefined;
    /** PlayDate */
    playDate: moment.Moment | undefined;
    /** CustomerId */
    customerId: string | undefined;
    /** Customer */
    customer: Customer | undefined;
    /** Buyer */
    buyer: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** PayMethodId */
    payMethodId: string | undefined;
    /** PayMethod */
    payMethod: PayMethod | undefined;
    /** VoucherNo */
    voucherNo: string | undefined;
    /** PayStatus */
    payStatus: PayStatusEnum | undefined;
    /** ActivityType */
    activityType: ActivityTypeEnum | undefined;
    /** Remark */
    remark: string | undefined;
    /** IsPrint */
    isPrint: boolean | undefined;
    /** Closed */
    closed: boolean | undefined;
    /** TotalQuantity */
    totalQuantity: number | undefined;
    /** TotalAmount */
    totalAmount: number | undefined;
    /** AccountsId */
    accountsId: string | undefined;
    /** Account */
    account: Account | undefined;
    /** OrderType */
    orderType: OrderTypeEnum | undefined;
    /** 账单对应的票列表 */
    tickets: TicketDetailListDto[] | undefined;
}

export class TicketDetailListDto implements ITicketDetailListDto {
    /** BranchId */
    branchId: string | undefined;
    /** TicketNo */
    ticketNo: string | undefined;
    /** ActivityDetailId */
    activityDetailId: string | undefined;
    /** ActivityDetail */
    activityDetail: ActivityDetail | undefined;
    /** ActivityId */
    activityId: string | undefined;
    /** Activity */
    activity: Activity | undefined;
    /** OrgActivityDetailId */
    orgActivityDetailId: string | undefined;
    /** OrgActivityId */
    orgActivityId: string | undefined;
    /** CustomerId */
    customerId: string | undefined;
    /** Customer */
    customer: Customer | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** Ticket */
    ticket: Ticket | undefined;
    /** QRCode */
    qrCode: string | undefined;
    /** CheckingQuantity */
    checkingQuantity: number | undefined;
    /** CheckedQuantity */
    checkedQuantity: number | undefined;
    /** StartDateTime */
    startDateTime: moment.Moment | undefined;
    /** EndDateTime */
    endDateTime: moment.Moment | undefined;
    /** CheckMethod */
    checkMethod: CheckMethodEnum | undefined;
    /** RouteId */
    routeId: string | undefined;
    /** ScheduleId */
    scheduleId: string | undefined;
    /** Schedule */
    schedule: Schedule | undefined;
    /** BoatId */
    boatId: string | undefined;
    /** TicketStatus */
    ticketStatus: TicketStatusEnum | undefined;
    /** CheckTime */
    checkTime: moment.Moment | undefined;
    /** 是否打印 */
    isPrint: boolean | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ITicketDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketNo = data["ticketNo"];
            this.activityDetailId = data["activityDetailId"];
            this.activityDetail = data["activityDetail"] ? ActivityDetail.fromJS(data["activityDetail"]) : <any>undefined;
            this.activityId = data["activityId"];
            this.activity = data["activity"] ? Activity.fromJS(data["activity"]) : <any>undefined;
            this.orgActivityDetailId = data["orgActivityDetailId"];
            this.orgActivityId = data["orgActivityId"];
            this.customerId = data["customerId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.ticketId = data["ticketId"];
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.qrCode = data["qrCode"];
            this.checkingQuantity = data["checkingQuantity"];
            this.checkedQuantity = data["checkedQuantity"];
            this.startDateTime = data["startDateTime"] ? moment(data["startDateTime"].toString()) : <any>undefined;
            this.endDateTime = data["endDateTime"] ? moment(data["endDateTime"].toString()) : <any>undefined;
            this.checkMethod = data["checkMethod"];
            this.routeId = data["routeId"];
            this.scheduleId = data["scheduleId"];
            this.schedule = data["schedule"] ? Schedule.fromJS(data["schedule"]) : <any>undefined;
            this.boatId = data["boatId"];
            this.ticketStatus = data["ticketStatus"];
            this.checkTime = data["checkTime"] ? moment(data["checkTime"].toString()) : <any>undefined;
            this.isPrint = data["isPrint"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketNo"] = this.ticketNo;
        data["activityDetailId"] = this.activityDetailId;
        data["activityDetail"] = this.activityDetail ? this.activityDetail.toJSON() : <any>undefined;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["orgActivityDetailId"] = this.orgActivityDetailId;
        data["orgActivityId"] = this.orgActivityId;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["ticketId"] = this.ticketId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["qrCode"] = this.qrCode;
        data["checkingQuantity"] = this.checkingQuantity;
        data["checkedQuantity"] = this.checkedQuantity;
        data["startDateTime"] = this.startDateTime ? this.startDateTime.toISOString() : <any>undefined;
        data["endDateTime"] = this.endDateTime ? this.endDateTime.toISOString() : <any>undefined;
        data["checkMethod"] = this.checkMethod;
        data["routeId"] = this.routeId;
        data["scheduleId"] = this.scheduleId;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["boatId"] = this.boatId;
        data["ticketStatus"] = this.ticketStatus;
        data["checkTime"] = this.checkTime ? this.checkTime.toISOString() : <any>undefined;
        data["isPrint"] = this.isPrint;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketDetailListDto {
        const json = this.toJSON();
        let result = new TicketDetailListDto();
        result.init(json);
        return result;
    }
}

export interface ITicketDetailListDto {
    /** BranchId */
    branchId: string | undefined;
    /** TicketNo */
    ticketNo: string | undefined;
    /** ActivityDetailId */
    activityDetailId: string | undefined;
    /** ActivityDetail */
    activityDetail: ActivityDetail | undefined;
    /** ActivityId */
    activityId: string | undefined;
    /** Activity */
    activity: Activity | undefined;
    /** OrgActivityDetailId */
    orgActivityDetailId: string | undefined;
    /** OrgActivityId */
    orgActivityId: string | undefined;
    /** CustomerId */
    customerId: string | undefined;
    /** Customer */
    customer: Customer | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** Ticket */
    ticket: Ticket | undefined;
    /** QRCode */
    qrCode: string | undefined;
    /** CheckingQuantity */
    checkingQuantity: number | undefined;
    /** CheckedQuantity */
    checkedQuantity: number | undefined;
    /** StartDateTime */
    startDateTime: moment.Moment | undefined;
    /** EndDateTime */
    endDateTime: moment.Moment | undefined;
    /** CheckMethod */
    checkMethod: CheckMethodEnum | undefined;
    /** RouteId */
    routeId: string | undefined;
    /** ScheduleId */
    scheduleId: string | undefined;
    /** Schedule */
    schedule: Schedule | undefined;
    /** BoatId */
    boatId: string | undefined;
    /** TicketStatus */
    ticketStatus: TicketStatusEnum | undefined;
    /** CheckTime */
    checkTime: moment.Moment | undefined;
    /** 是否打印 */
    isPrint: boolean | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetAccountForEditOutput implements IGetAccountForEditOutput {
    account: AccountEditDto | undefined;

    constructor(data?: IGetAccountForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.account = data["account"] ? AccountEditDto.fromJS(data["account"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAccountForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetAccountForEditOutput {
        const json = this.toJSON();
        let result = new GetAccountForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAccountForEditOutput {
    account: AccountEditDto | undefined;
}

export class GetAccountsInput implements IGetAccountsInput {
    /** 结账单号 AccountNo | 收款状态 AccountStatus 1：未收款 0：已收款 
结账日期 AccountDate | 支付方式 PayMethod.PayName */
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetAccountsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetAccountsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetAccountsInput {
        const json = this.toJSON();
        let result = new GetAccountsInput();
        result.init(json);
        return result;
    }
}

export interface IGetAccountsInput {
    /** 结账单号 AccountNo | 收款状态 AccountStatus 1：未收款 0：已收款 
结账日期 AccountDate | 支付方式 PayMethod.PayName */
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfAccountListDto implements IPagedResultDtoOfAccountListDto {
    totalCount: number | undefined;
    items: AccountListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAccountListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(AccountListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAccountListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAccountListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfAccountListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfAccountListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfAccountListDto {
    totalCount: number | undefined;
    items: AccountListDto[] | undefined;
}

export class CreateOrUpdateTicketDetailInput implements ICreateOrUpdateTicketDetailInput {
    ticketDetail: TicketDetailEditDto;

    constructor(data?: ICreateOrUpdateTicketDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticketDetail = new TicketDetailEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketDetail = data["ticketDetail"] ? TicketDetailEditDto.fromJS(data["ticketDetail"]) : new TicketDetailEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTicketDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTicketDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketDetail"] = this.ticketDetail ? this.ticketDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTicketDetailInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTicketDetailInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTicketDetailInput {
    ticketDetail: TicketDetailEditDto;
}

export class TicketDetailEditDto implements ITicketDetailEditDto {
    /** Id */
    id: string | undefined;
    /** TicketNo */
    ticketNo: string | undefined;
    /** ActivityDetailId */
    activityDetailId: string | undefined;
    /** ActivityId */
    activityId: string | undefined;
    /** OrgActivityDetailId */
    orgActivityDetailId: string | undefined;
    /** OrgActivityId */
    orgActivityId: string | undefined;
    /** CustomerId */
    customerId: string | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** QRCode */
    qrCode: string | undefined;
    /** CheckingQuantity */
    checkingQuantity: number | undefined;
    /** CheckedQuantity */
    checkedQuantity: number | undefined;
    /** StartDateTime */
    startDateTime: moment.Moment | undefined;
    /** EndDateTime */
    endDateTime: moment.Moment | undefined;
    /** CheckMethod */
    checkMethod: CheckMethodEnum | undefined;
    /** RouteId */
    routeId: string | undefined;
    /** ScheduleId */
    scheduleId: string | undefined;
    /** Schedule */
    schedule: Schedule | undefined;
    /** BoatId */
    boatId: string | undefined;
    /** TicketStatus */
    ticketStatus: TicketStatusEnum | undefined;
    /** CheckTime */
    checkTime: moment.Moment | undefined;
    /** 是否打印 */
    isPrint: boolean | undefined;

    constructor(data?: ITicketDetailEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ticketNo = data["ticketNo"];
            this.activityDetailId = data["activityDetailId"];
            this.activityId = data["activityId"];
            this.orgActivityDetailId = data["orgActivityDetailId"];
            this.orgActivityId = data["orgActivityId"];
            this.customerId = data["customerId"];
            this.ticketId = data["ticketId"];
            this.qrCode = data["qrCode"];
            this.checkingQuantity = data["checkingQuantity"];
            this.checkedQuantity = data["checkedQuantity"];
            this.startDateTime = data["startDateTime"] ? moment(data["startDateTime"].toString()) : <any>undefined;
            this.endDateTime = data["endDateTime"] ? moment(data["endDateTime"].toString()) : <any>undefined;
            this.checkMethod = data["checkMethod"];
            this.routeId = data["routeId"];
            this.scheduleId = data["scheduleId"];
            this.schedule = data["schedule"] ? Schedule.fromJS(data["schedule"]) : <any>undefined;
            this.boatId = data["boatId"];
            this.ticketStatus = data["ticketStatus"];
            this.checkTime = data["checkTime"] ? moment(data["checkTime"].toString()) : <any>undefined;
            this.isPrint = data["isPrint"];
        }
    }

    static fromJS(data: any): TicketDetailEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDetailEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketNo"] = this.ticketNo;
        data["activityDetailId"] = this.activityDetailId;
        data["activityId"] = this.activityId;
        data["orgActivityDetailId"] = this.orgActivityDetailId;
        data["orgActivityId"] = this.orgActivityId;
        data["customerId"] = this.customerId;
        data["ticketId"] = this.ticketId;
        data["qrCode"] = this.qrCode;
        data["checkingQuantity"] = this.checkingQuantity;
        data["checkedQuantity"] = this.checkedQuantity;
        data["startDateTime"] = this.startDateTime ? this.startDateTime.toISOString() : <any>undefined;
        data["endDateTime"] = this.endDateTime ? this.endDateTime.toISOString() : <any>undefined;
        data["checkMethod"] = this.checkMethod;
        data["routeId"] = this.routeId;
        data["scheduleId"] = this.scheduleId;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["boatId"] = this.boatId;
        data["ticketStatus"] = this.ticketStatus;
        data["checkTime"] = this.checkTime ? this.checkTime.toISOString() : <any>undefined;
        data["isPrint"] = this.isPrint;
        return data; 
    }

    clone(): TicketDetailEditDto {
        const json = this.toJSON();
        let result = new TicketDetailEditDto();
        result.init(json);
        return result;
    }
}

export interface ITicketDetailEditDto {
    /** Id */
    id: string | undefined;
    /** TicketNo */
    ticketNo: string | undefined;
    /** ActivityDetailId */
    activityDetailId: string | undefined;
    /** ActivityId */
    activityId: string | undefined;
    /** OrgActivityDetailId */
    orgActivityDetailId: string | undefined;
    /** OrgActivityId */
    orgActivityId: string | undefined;
    /** CustomerId */
    customerId: string | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** QRCode */
    qrCode: string | undefined;
    /** CheckingQuantity */
    checkingQuantity: number | undefined;
    /** CheckedQuantity */
    checkedQuantity: number | undefined;
    /** StartDateTime */
    startDateTime: moment.Moment | undefined;
    /** EndDateTime */
    endDateTime: moment.Moment | undefined;
    /** CheckMethod */
    checkMethod: CheckMethodEnum | undefined;
    /** RouteId */
    routeId: string | undefined;
    /** ScheduleId */
    scheduleId: string | undefined;
    /** Schedule */
    schedule: Schedule | undefined;
    /** BoatId */
    boatId: string | undefined;
    /** TicketStatus */
    ticketStatus: TicketStatusEnum | undefined;
    /** CheckTime */
    checkTime: moment.Moment | undefined;
    /** 是否打印 */
    isPrint: boolean | undefined;
}

export class GetTicketDetailForEditOutput implements IGetTicketDetailForEditOutput {
    ticketDetail: TicketDetailEditDto | undefined;

    constructor(data?: IGetTicketDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketDetail = data["ticketDetail"] ? TicketDetailEditDto.fromJS(data["ticketDetail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTicketDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketDetail"] = this.ticketDetail ? this.ticketDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTicketDetailForEditOutput {
        const json = this.toJSON();
        let result = new GetTicketDetailForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTicketDetailForEditOutput {
    ticketDetail: TicketDetailEditDto | undefined;
}

export class GetTicketDetailsInput implements IGetTicketDetailsInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetTicketDetailsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetTicketDetailsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketDetailsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetTicketDetailsInput {
        const json = this.toJSON();
        let result = new GetTicketDetailsInput();
        result.init(json);
        return result;
    }
}

export interface IGetTicketDetailsInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfTicketDetailListDto implements IPagedResultDtoOfTicketDetailListDto {
    totalCount: number | undefined;
    items: TicketDetailListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTicketDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TicketDetailListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTicketDetailListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTicketDetailListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTicketDetailListDto {
    totalCount: number | undefined;
    items: TicketDetailListDto[] | undefined;
}

export class CreateOrUpdateTicketDetailHistoryInput implements ICreateOrUpdateTicketDetailHistoryInput {
    ticketDetailHistory: TicketDetailHistoryEditDto;

    constructor(data?: ICreateOrUpdateTicketDetailHistoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticketDetailHistory = new TicketDetailHistoryEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketDetailHistory = data["ticketDetailHistory"] ? TicketDetailHistoryEditDto.fromJS(data["ticketDetailHistory"]) : new TicketDetailHistoryEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTicketDetailHistoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTicketDetailHistoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketDetailHistory"] = this.ticketDetailHistory ? this.ticketDetailHistory.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTicketDetailHistoryInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTicketDetailHistoryInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTicketDetailHistoryInput {
    ticketDetailHistory: TicketDetailHistoryEditDto;
}

export class TicketDetailHistoryEditDto implements ITicketDetailHistoryEditDto {
    /** Id */
    id: string | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** DeviceId */
    deviceId: string | undefined;
    /** DeviceName */
    deviceName: string | undefined;
    /** TicketDetailId */
    ticketDetailId: string | undefined;
    /** TicketNo */
    ticketNo: string | undefined;
    /** CustomerId */
    customerId: string | undefined;
    /** VisitValue */
    visitValue: string | undefined;
    /** ValidationType */
    validationType: string | undefined;
    /** TicketName */
    ticketName: string | undefined;
    /** StatusCode */
    statusCode: CheckStatusEnum | undefined;
    /** StatusText */
    statusText: string | undefined;
    /** CheckDate */
    checkDate: moment.Moment | undefined;
    /** Year */
    year: number | undefined;
    /** Month */
    month: number | undefined;
    /** Day */
    day: number | undefined;
    /** Hour */
    hour: number | undefined;
    /** Minute */
    minute: number | undefined;
    /** YearWeek */
    yearWeek: number | undefined;
    /** WeekDay */
    weekDay: number | undefined;
    /** CheckTime */
    checkTime: moment.Moment | undefined;
    /** CheckerId */
    checkerId: number | undefined;
    /** Checker */
    checker: User | undefined;
    /** CheckCount */
    checkCount: number | undefined;

    constructor(data?: ITicketDetailHistoryEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ticketId = data["ticketId"];
            this.deviceId = data["deviceId"];
            this.deviceName = data["deviceName"];
            this.ticketDetailId = data["ticketDetailId"];
            this.ticketNo = data["ticketNo"];
            this.customerId = data["customerId"];
            this.visitValue = data["visitValue"];
            this.validationType = data["validationType"];
            this.ticketName = data["ticketName"];
            this.statusCode = data["statusCode"];
            this.statusText = data["statusText"];
            this.checkDate = data["checkDate"] ? moment(data["checkDate"].toString()) : <any>undefined;
            this.year = data["year"];
            this.month = data["month"];
            this.day = data["day"];
            this.hour = data["hour"];
            this.minute = data["minute"];
            this.yearWeek = data["yearWeek"];
            this.weekDay = data["weekDay"];
            this.checkTime = data["checkTime"] ? moment(data["checkTime"].toString()) : <any>undefined;
            this.checkerId = data["checkerId"];
            this.checker = data["checker"] ? User.fromJS(data["checker"]) : <any>undefined;
            this.checkCount = data["checkCount"];
        }
    }

    static fromJS(data: any): TicketDetailHistoryEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDetailHistoryEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketId"] = this.ticketId;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["ticketDetailId"] = this.ticketDetailId;
        data["ticketNo"] = this.ticketNo;
        data["customerId"] = this.customerId;
        data["visitValue"] = this.visitValue;
        data["validationType"] = this.validationType;
        data["ticketName"] = this.ticketName;
        data["statusCode"] = this.statusCode;
        data["statusText"] = this.statusText;
        data["checkDate"] = this.checkDate ? this.checkDate.toISOString() : <any>undefined;
        data["year"] = this.year;
        data["month"] = this.month;
        data["day"] = this.day;
        data["hour"] = this.hour;
        data["minute"] = this.minute;
        data["yearWeek"] = this.yearWeek;
        data["weekDay"] = this.weekDay;
        data["checkTime"] = this.checkTime ? this.checkTime.toISOString() : <any>undefined;
        data["checkerId"] = this.checkerId;
        data["checker"] = this.checker ? this.checker.toJSON() : <any>undefined;
        data["checkCount"] = this.checkCount;
        return data; 
    }

    clone(): TicketDetailHistoryEditDto {
        const json = this.toJSON();
        let result = new TicketDetailHistoryEditDto();
        result.init(json);
        return result;
    }
}

export interface ITicketDetailHistoryEditDto {
    /** Id */
    id: string | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** DeviceId */
    deviceId: string | undefined;
    /** DeviceName */
    deviceName: string | undefined;
    /** TicketDetailId */
    ticketDetailId: string | undefined;
    /** TicketNo */
    ticketNo: string | undefined;
    /** CustomerId */
    customerId: string | undefined;
    /** VisitValue */
    visitValue: string | undefined;
    /** ValidationType */
    validationType: string | undefined;
    /** TicketName */
    ticketName: string | undefined;
    /** StatusCode */
    statusCode: CheckStatusEnum | undefined;
    /** StatusText */
    statusText: string | undefined;
    /** CheckDate */
    checkDate: moment.Moment | undefined;
    /** Year */
    year: number | undefined;
    /** Month */
    month: number | undefined;
    /** Day */
    day: number | undefined;
    /** Hour */
    hour: number | undefined;
    /** Minute */
    minute: number | undefined;
    /** YearWeek */
    yearWeek: number | undefined;
    /** WeekDay */
    weekDay: number | undefined;
    /** CheckTime */
    checkTime: moment.Moment | undefined;
    /** CheckerId */
    checkerId: number | undefined;
    /** Checker */
    checker: User | undefined;
    /** CheckCount */
    checkCount: number | undefined;
}

export class TicketDetailHistoryListDto implements ITicketDetailHistoryListDto {
    /** BranchId */
    branchId: string | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** Ticket */
    ticket: Ticket | undefined;
    /** DeviceId */
    deviceId: string | undefined;
    /** Device */
    device: Device | undefined;
    /** DeviceName */
    deviceName: string | undefined;
    /** TicketDetailId */
    ticketDetailId: string | undefined;
    /** TicketDetail */
    ticketDetail: TicketDetail | undefined;
    /** TicketNo */
    ticketNo: string | undefined;
    /** CustomerId */
    customerId: string | undefined;
    /** Customer */
    customer: Customer | undefined;
    /** VisitValue */
    visitValue: string | undefined;
    /** ValidationType */
    validationType: string | undefined;
    /** TicketName */
    ticketName: string | undefined;
    /** StatusCode */
    statusCode: CheckStatusEnum | undefined;
    /** StatusText */
    statusText: string | undefined;
    /** CheckDate */
    checkDate: moment.Moment | undefined;
    /** Year */
    year: number | undefined;
    /** Month */
    month: number | undefined;
    /** Day */
    day: number | undefined;
    /** Hour */
    hour: number | undefined;
    /** Minute */
    minute: number | undefined;
    /** YearWeek */
    yearWeek: number | undefined;
    /** WeekDay */
    weekDay: number | undefined;
    /** CheckTime */
    checkTime: moment.Moment | undefined;
    /** CheckerId */
    checkerId: number | undefined;
    /** Checker */
    checker: User | undefined;
    /** CheckCount */
    checkCount: number | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ITicketDetailHistoryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketId = data["ticketId"];
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.deviceId = data["deviceId"];
            this.device = data["device"] ? Device.fromJS(data["device"]) : <any>undefined;
            this.deviceName = data["deviceName"];
            this.ticketDetailId = data["ticketDetailId"];
            this.ticketDetail = data["ticketDetail"] ? TicketDetail.fromJS(data["ticketDetail"]) : <any>undefined;
            this.ticketNo = data["ticketNo"];
            this.customerId = data["customerId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.visitValue = data["visitValue"];
            this.validationType = data["validationType"];
            this.ticketName = data["ticketName"];
            this.statusCode = data["statusCode"];
            this.statusText = data["statusText"];
            this.checkDate = data["checkDate"] ? moment(data["checkDate"].toString()) : <any>undefined;
            this.year = data["year"];
            this.month = data["month"];
            this.day = data["day"];
            this.hour = data["hour"];
            this.minute = data["minute"];
            this.yearWeek = data["yearWeek"];
            this.weekDay = data["weekDay"];
            this.checkTime = data["checkTime"] ? moment(data["checkTime"].toString()) : <any>undefined;
            this.checkerId = data["checkerId"];
            this.checker = data["checker"] ? User.fromJS(data["checker"]) : <any>undefined;
            this.checkCount = data["checkCount"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketDetailHistoryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDetailHistoryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketId"] = this.ticketId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["deviceId"] = this.deviceId;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["deviceName"] = this.deviceName;
        data["ticketDetailId"] = this.ticketDetailId;
        data["ticketDetail"] = this.ticketDetail ? this.ticketDetail.toJSON() : <any>undefined;
        data["ticketNo"] = this.ticketNo;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["visitValue"] = this.visitValue;
        data["validationType"] = this.validationType;
        data["ticketName"] = this.ticketName;
        data["statusCode"] = this.statusCode;
        data["statusText"] = this.statusText;
        data["checkDate"] = this.checkDate ? this.checkDate.toISOString() : <any>undefined;
        data["year"] = this.year;
        data["month"] = this.month;
        data["day"] = this.day;
        data["hour"] = this.hour;
        data["minute"] = this.minute;
        data["yearWeek"] = this.yearWeek;
        data["weekDay"] = this.weekDay;
        data["checkTime"] = this.checkTime ? this.checkTime.toISOString() : <any>undefined;
        data["checkerId"] = this.checkerId;
        data["checker"] = this.checker ? this.checker.toJSON() : <any>undefined;
        data["checkCount"] = this.checkCount;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketDetailHistoryListDto {
        const json = this.toJSON();
        let result = new TicketDetailHistoryListDto();
        result.init(json);
        return result;
    }
}

export interface ITicketDetailHistoryListDto {
    /** BranchId */
    branchId: string | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** Ticket */
    ticket: Ticket | undefined;
    /** DeviceId */
    deviceId: string | undefined;
    /** Device */
    device: Device | undefined;
    /** DeviceName */
    deviceName: string | undefined;
    /** TicketDetailId */
    ticketDetailId: string | undefined;
    /** TicketDetail */
    ticketDetail: TicketDetail | undefined;
    /** TicketNo */
    ticketNo: string | undefined;
    /** CustomerId */
    customerId: string | undefined;
    /** Customer */
    customer: Customer | undefined;
    /** VisitValue */
    visitValue: string | undefined;
    /** ValidationType */
    validationType: string | undefined;
    /** TicketName */
    ticketName: string | undefined;
    /** StatusCode */
    statusCode: CheckStatusEnum | undefined;
    /** StatusText */
    statusText: string | undefined;
    /** CheckDate */
    checkDate: moment.Moment | undefined;
    /** Year */
    year: number | undefined;
    /** Month */
    month: number | undefined;
    /** Day */
    day: number | undefined;
    /** Hour */
    hour: number | undefined;
    /** Minute */
    minute: number | undefined;
    /** YearWeek */
    yearWeek: number | undefined;
    /** WeekDay */
    weekDay: number | undefined;
    /** CheckTime */
    checkTime: moment.Moment | undefined;
    /** CheckerId */
    checkerId: number | undefined;
    /** Checker */
    checker: User | undefined;
    /** CheckCount */
    checkCount: number | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetTicketDetailHistoryForEditOutput implements IGetTicketDetailHistoryForEditOutput {
    ticketDetailHistory: TicketDetailHistoryEditDto | undefined;

    constructor(data?: IGetTicketDetailHistoryForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketDetailHistory = data["ticketDetailHistory"] ? TicketDetailHistoryEditDto.fromJS(data["ticketDetailHistory"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTicketDetailHistoryForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketDetailHistoryForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketDetailHistory"] = this.ticketDetailHistory ? this.ticketDetailHistory.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTicketDetailHistoryForEditOutput {
        const json = this.toJSON();
        let result = new GetTicketDetailHistoryForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTicketDetailHistoryForEditOutput {
    ticketDetailHistory: TicketDetailHistoryEditDto | undefined;
}

export class PagedResultDtoOfTicketDetailHistoryListDto implements IPagedResultDtoOfTicketDetailHistoryListDto {
    totalCount: number | undefined;
    items: TicketDetailHistoryListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTicketDetailHistoryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TicketDetailHistoryListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketDetailHistoryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketDetailHistoryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTicketDetailHistoryListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTicketDetailHistoryListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTicketDetailHistoryListDto {
    totalCount: number | undefined;
    items: TicketDetailHistoryListDto[] | undefined;
}

export class CreateOrUpdateTicketIntroduceInput implements ICreateOrUpdateTicketIntroduceInput {
    ticketIntroduce: TicketIntroduceEditDto;

    constructor(data?: ICreateOrUpdateTicketIntroduceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticketIntroduce = new TicketIntroduceEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketIntroduce = data["ticketIntroduce"] ? TicketIntroduceEditDto.fromJS(data["ticketIntroduce"]) : new TicketIntroduceEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTicketIntroduceInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTicketIntroduceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketIntroduce"] = this.ticketIntroduce ? this.ticketIntroduce.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTicketIntroduceInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTicketIntroduceInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTicketIntroduceInput {
    ticketIntroduce: TicketIntroduceEditDto;
}

export class TicketIntroduceEditDto implements ITicketIntroduceEditDto {
    /** Id */
    id: string | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** ScenicSpotId */
    scenicSpotId: string | undefined;
    /** TradeName */
    tradeName: string | undefined;
    /** TradeInfo */
    tradeInfo: string | undefined;
    /** Address */
    address: string | undefined;
    /** CoverMap */
    coverMap: string | undefined;
    /** Abstract */
    abstract: string | undefined;
    /** Notice */
    notice: string | undefined;
    /** RefundRule */
    refundRule: string | undefined;
    /** IsOnLine */
    isOnLine: boolean | undefined;

    constructor(data?: ITicketIntroduceEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ticketId = data["ticketId"];
            this.scenicSpotId = data["scenicSpotId"];
            this.tradeName = data["tradeName"];
            this.tradeInfo = data["tradeInfo"];
            this.address = data["address"];
            this.coverMap = data["coverMap"];
            this.abstract = data["abstract"];
            this.notice = data["notice"];
            this.refundRule = data["refundRule"];
            this.isOnLine = data["isOnLine"];
        }
    }

    static fromJS(data: any): TicketIntroduceEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketIntroduceEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketId"] = this.ticketId;
        data["scenicSpotId"] = this.scenicSpotId;
        data["tradeName"] = this.tradeName;
        data["tradeInfo"] = this.tradeInfo;
        data["address"] = this.address;
        data["coverMap"] = this.coverMap;
        data["abstract"] = this.abstract;
        data["notice"] = this.notice;
        data["refundRule"] = this.refundRule;
        data["isOnLine"] = this.isOnLine;
        return data; 
    }

    clone(): TicketIntroduceEditDto {
        const json = this.toJSON();
        let result = new TicketIntroduceEditDto();
        result.init(json);
        return result;
    }
}

export interface ITicketIntroduceEditDto {
    /** Id */
    id: string | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** ScenicSpotId */
    scenicSpotId: string | undefined;
    /** TradeName */
    tradeName: string | undefined;
    /** TradeInfo */
    tradeInfo: string | undefined;
    /** Address */
    address: string | undefined;
    /** CoverMap */
    coverMap: string | undefined;
    /** Abstract */
    abstract: string | undefined;
    /** Notice */
    notice: string | undefined;
    /** RefundRule */
    refundRule: string | undefined;
    /** IsOnLine */
    isOnLine: boolean | undefined;
}

export class TicketIntroduceListDto implements ITicketIntroduceListDto {
    /** BranchId */
    branchId: string | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** Ticket */
    ticket: Ticket | undefined;
    /** ScenicSpotId */
    scenicSpotId: string | undefined;
    /** ScenicSpot */
    scenicSpot: ScenicSpot | undefined;
    /** TradeName */
    tradeName: string | undefined;
    /** TradeInfo */
    tradeInfo: string | undefined;
    /** Address */
    address: string | undefined;
    /** CoverMap */
    coverMap: string | undefined;
    /** Abstract */
    abstract: string | undefined;
    /** Notice */
    notice: string | undefined;
    /** RefundRule */
    refundRule: string | undefined;
    /** IsOnLine */
    isOnLine: boolean | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ITicketIntroduceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketId = data["ticketId"];
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.scenicSpotId = data["scenicSpotId"];
            this.scenicSpot = data["scenicSpot"] ? ScenicSpot.fromJS(data["scenicSpot"]) : <any>undefined;
            this.tradeName = data["tradeName"];
            this.tradeInfo = data["tradeInfo"];
            this.address = data["address"];
            this.coverMap = data["coverMap"];
            this.abstract = data["abstract"];
            this.notice = data["notice"];
            this.refundRule = data["refundRule"];
            this.isOnLine = data["isOnLine"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketIntroduceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketIntroduceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketId"] = this.ticketId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["scenicSpotId"] = this.scenicSpotId;
        data["scenicSpot"] = this.scenicSpot ? this.scenicSpot.toJSON() : <any>undefined;
        data["tradeName"] = this.tradeName;
        data["tradeInfo"] = this.tradeInfo;
        data["address"] = this.address;
        data["coverMap"] = this.coverMap;
        data["abstract"] = this.abstract;
        data["notice"] = this.notice;
        data["refundRule"] = this.refundRule;
        data["isOnLine"] = this.isOnLine;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketIntroduceListDto {
        const json = this.toJSON();
        let result = new TicketIntroduceListDto();
        result.init(json);
        return result;
    }
}

export interface ITicketIntroduceListDto {
    /** BranchId */
    branchId: string | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** Ticket */
    ticket: Ticket | undefined;
    /** ScenicSpotId */
    scenicSpotId: string | undefined;
    /** ScenicSpot */
    scenicSpot: ScenicSpot | undefined;
    /** TradeName */
    tradeName: string | undefined;
    /** TradeInfo */
    tradeInfo: string | undefined;
    /** Address */
    address: string | undefined;
    /** CoverMap */
    coverMap: string | undefined;
    /** Abstract */
    abstract: string | undefined;
    /** Notice */
    notice: string | undefined;
    /** RefundRule */
    refundRule: string | undefined;
    /** IsOnLine */
    isOnLine: boolean | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetTicketIntroduceForEditOutput implements IGetTicketIntroduceForEditOutput {
    ticketIntroduce: TicketIntroduceEditDto | undefined;

    constructor(data?: IGetTicketIntroduceForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketIntroduce = data["ticketIntroduce"] ? TicketIntroduceEditDto.fromJS(data["ticketIntroduce"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTicketIntroduceForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketIntroduceForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketIntroduce"] = this.ticketIntroduce ? this.ticketIntroduce.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTicketIntroduceForEditOutput {
        const json = this.toJSON();
        let result = new GetTicketIntroduceForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTicketIntroduceForEditOutput {
    ticketIntroduce: TicketIntroduceEditDto | undefined;
}

export class PagedResultDtoOfTicketIntroduceListDto implements IPagedResultDtoOfTicketIntroduceListDto {
    totalCount: number | undefined;
    items: TicketIntroduceListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTicketIntroduceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TicketIntroduceListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketIntroduceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketIntroduceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTicketIntroduceListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTicketIntroduceListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTicketIntroduceListDto {
    totalCount: number | undefined;
    items: TicketIntroduceListDto[] | undefined;
}

export class CreateOrUpdateTicketPriceInput implements ICreateOrUpdateTicketPriceInput {
    ticketPrice: TicketPriceEditDto;

    constructor(data?: ICreateOrUpdateTicketPriceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticketPrice = new TicketPriceEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketPrice = data["ticketPrice"] ? TicketPriceEditDto.fromJS(data["ticketPrice"]) : new TicketPriceEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTicketPriceInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTicketPriceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTicketPriceInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTicketPriceInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTicketPriceInput {
    ticketPrice: TicketPriceEditDto;
}

export class TicketPriceEditDto implements ITicketPriceEditDto {
    /** Id */
    id: string | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    /** Sort */
    sort: number | undefined;
    /** Price */
    price: number | undefined;
    /** Discount */
    discount: number | undefined;
    /** 退款折扣 */
    rDiscount: number | undefined;
    /** UpperTime */
    upperTime: moment.Moment | undefined;
    /** LowerTime */
    lowerTime: moment.Moment | undefined;
    /** Position */
    position: PositionEnum | undefined;
    /** 价格名称 */
    ticketName: string | undefined;
    lowerTimeStr: string | undefined;
    upperTimeStr: string | undefined;
    /** 仓位 */
    warePosition: WareHousePosition | undefined;

    constructor(data?: ITicketPriceEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ticketId = data["ticketId"];
            this.isEnabled = data["isEnabled"];
            this.sort = data["sort"];
            this.price = data["price"];
            this.discount = data["discount"];
            this.rDiscount = data["rDiscount"];
            this.upperTime = data["upperTime"] ? moment(data["upperTime"].toString()) : <any>undefined;
            this.lowerTime = data["lowerTime"] ? moment(data["lowerTime"].toString()) : <any>undefined;
            this.position = data["position"];
            this.ticketName = data["ticketName"];
            this.lowerTimeStr = data["lowerTimeStr"];
            this.upperTimeStr = data["upperTimeStr"];
            this.warePosition = data["warePosition"];
        }
    }

    static fromJS(data: any): TicketPriceEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketPriceEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketId"] = this.ticketId;
        data["isEnabled"] = this.isEnabled;
        data["sort"] = this.sort;
        data["price"] = this.price;
        data["discount"] = this.discount;
        data["rDiscount"] = this.rDiscount;
        data["upperTime"] = this.upperTime ? this.upperTime.toISOString() : <any>undefined;
        data["lowerTime"] = this.lowerTime ? this.lowerTime.toISOString() : <any>undefined;
        data["position"] = this.position;
        data["ticketName"] = this.ticketName;
        data["lowerTimeStr"] = this.lowerTimeStr;
        data["upperTimeStr"] = this.upperTimeStr;
        data["warePosition"] = this.warePosition;
        return data; 
    }

    clone(): TicketPriceEditDto {
        const json = this.toJSON();
        let result = new TicketPriceEditDto();
        result.init(json);
        return result;
    }
}

export interface ITicketPriceEditDto {
    /** Id */
    id: string | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    /** Sort */
    sort: number | undefined;
    /** Price */
    price: number | undefined;
    /** Discount */
    discount: number | undefined;
    /** 退款折扣 */
    rDiscount: number | undefined;
    /** UpperTime */
    upperTime: moment.Moment | undefined;
    /** LowerTime */
    lowerTime: moment.Moment | undefined;
    /** Position */
    position: PositionEnum | undefined;
    /** 价格名称 */
    ticketName: string | undefined;
    lowerTimeStr: string | undefined;
    upperTimeStr: string | undefined;
    /** 仓位 */
    warePosition: WareHousePosition | undefined;
}

export class GetTicketPriceForEditOutput implements IGetTicketPriceForEditOutput {
    ticketPrice: TicketPriceEditDto | undefined;

    constructor(data?: IGetTicketPriceForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketPrice = data["ticketPrice"] ? TicketPriceEditDto.fromJS(data["ticketPrice"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTicketPriceForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketPriceForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTicketPriceForEditOutput {
        const json = this.toJSON();
        let result = new GetTicketPriceForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTicketPriceForEditOutput {
    ticketPrice: TicketPriceEditDto | undefined;
}

export class GetTicketPricesInput implements IGetTicketPricesInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetTicketPricesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetTicketPricesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketPricesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetTicketPricesInput {
        const json = this.toJSON();
        let result = new GetTicketPricesInput();
        result.init(json);
        return result;
    }
}

export interface IGetTicketPricesInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfTicketPriceListDto implements IPagedResultDtoOfTicketPriceListDto {
    totalCount: number | undefined;
    items: TicketPriceListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTicketPriceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TicketPriceListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketPriceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketPriceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTicketPriceListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTicketPriceListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTicketPriceListDto {
    totalCount: number | undefined;
    items: TicketPriceListDto[] | undefined;
}

export class CreateOrUpdateTicketRoleInput implements ICreateOrUpdateTicketRoleInput {
    ticketRole: TicketRoleEditDto;

    constructor(data?: ICreateOrUpdateTicketRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticketRole = new TicketRoleEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketRole = data["ticketRole"] ? TicketRoleEditDto.fromJS(data["ticketRole"]) : new TicketRoleEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTicketRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTicketRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketRole"] = this.ticketRole ? this.ticketRole.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTicketRoleInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTicketRoleInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTicketRoleInput {
    ticketRole: TicketRoleEditDto;
}

/** 的列表DTO Yozeev.BusinessLogic.TicketRole */
export class TicketRoleEditDto implements ITicketRoleEditDto {
    /** Id */
    id: string | undefined;
    /** RoleId */
    roleId: number;
    /** TicketPriceId */
    ticketPriceId: string;

    constructor(data?: ITicketRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.roleId = data["roleId"];
            this.ticketPriceId = data["ticketPriceId"];
        }
    }

    static fromJS(data: any): TicketRoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketRoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleId"] = this.roleId;
        data["ticketPriceId"] = this.ticketPriceId;
        return data; 
    }

    clone(): TicketRoleEditDto {
        const json = this.toJSON();
        let result = new TicketRoleEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.TicketRole */
export interface ITicketRoleEditDto {
    /** Id */
    id: string | undefined;
    /** RoleId */
    roleId: number;
    /** TicketPriceId */
    ticketPriceId: string;
}

/** 的编辑DTO Yozeev.BusinessLogic.TicketRole */
export class TicketRoleListDto implements ITicketRoleListDto {
    /** BranchId */
    branchId: string | undefined;
    /** RoleId */
    roleId: number;
    /** Role */
    role: Role | undefined;
    /** TicketPriceId */
    ticketPriceId: string;
    /** TicketPrice */
    ticketPrice: TicketPrice | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ITicketRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.roleId = data["roleId"];
            this.role = data["role"] ? Role.fromJS(data["role"]) : <any>undefined;
            this.ticketPriceId = data["ticketPriceId"];
            this.ticketPrice = data["ticketPrice"] ? TicketPrice.fromJS(data["ticketPrice"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["roleId"] = this.roleId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["ticketPriceId"] = this.ticketPriceId;
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketRoleListDto {
        const json = this.toJSON();
        let result = new TicketRoleListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.TicketRole */
export interface ITicketRoleListDto {
    /** BranchId */
    branchId: string | undefined;
    /** RoleId */
    roleId: number;
    /** Role */
    role: Role | undefined;
    /** TicketPriceId */
    ticketPriceId: string;
    /** TicketPrice */
    ticketPrice: TicketPrice | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

/** 读取可编辑的Dto */
export class GetTicketRoleForEditOutput implements IGetTicketRoleForEditOutput {
    ticketRole: TicketRoleEditDto | undefined;

    constructor(data?: IGetTicketRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketRole = data["ticketRole"] ? TicketRoleEditDto.fromJS(data["ticketRole"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTicketRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketRole"] = this.ticketRole ? this.ticketRole.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTicketRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetTicketRoleForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetTicketRoleForEditOutput {
    ticketRole: TicketRoleEditDto | undefined;
}

export class PagedResultDtoOfTicketRoleListDto implements IPagedResultDtoOfTicketRoleListDto {
    totalCount: number | undefined;
    items: TicketRoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTicketRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TicketRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTicketRoleListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTicketRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTicketRoleListDto {
    totalCount: number | undefined;
    items: TicketRoleListDto[] | undefined;
}

export class CreateOrUpdateTicketScheduleEnableInput implements ICreateOrUpdateTicketScheduleEnableInput {
    ticketScheduleEnable: TicketScheduleEnableEditDto;

    constructor(data?: ICreateOrUpdateTicketScheduleEnableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticketScheduleEnable = new TicketScheduleEnableEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketScheduleEnable = data["ticketScheduleEnable"] ? TicketScheduleEnableEditDto.fromJS(data["ticketScheduleEnable"]) : new TicketScheduleEnableEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTicketScheduleEnableInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTicketScheduleEnableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketScheduleEnable"] = this.ticketScheduleEnable ? this.ticketScheduleEnable.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTicketScheduleEnableInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTicketScheduleEnableInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTicketScheduleEnableInput {
    ticketScheduleEnable: TicketScheduleEnableEditDto;
}

export class TicketScheduleEnableEditDto implements ITicketScheduleEnableEditDto {
    /** Id */
    id: string | undefined;
    /** ScheduleId */
    scheduleId: string;
    /** 票价Id */
    ticketPriceId: string | undefined;

    constructor(data?: ITicketScheduleEnableEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.scheduleId = data["scheduleId"];
            this.ticketPriceId = data["ticketPriceId"];
        }
    }

    static fromJS(data: any): TicketScheduleEnableEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketScheduleEnableEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["scheduleId"] = this.scheduleId;
        data["ticketPriceId"] = this.ticketPriceId;
        return data; 
    }

    clone(): TicketScheduleEnableEditDto {
        const json = this.toJSON();
        let result = new TicketScheduleEnableEditDto();
        result.init(json);
        return result;
    }
}

export interface ITicketScheduleEnableEditDto {
    /** Id */
    id: string | undefined;
    /** ScheduleId */
    scheduleId: string;
    /** 票价Id */
    ticketPriceId: string | undefined;
}

export class TicketScheduleEnableListDto implements ITicketScheduleEnableListDto {
    /** BranchId */
    branchId: string | undefined;
    /** ScheduleId */
    scheduleId: string;
    /** Schedule */
    schedule: Schedule | undefined;
    /** TicketId */
    ticketPriceId: string | undefined;
    /** Ticket */
    ticketPrice: TicketPrice | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ITicketScheduleEnableListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.scheduleId = data["scheduleId"];
            this.schedule = data["schedule"] ? Schedule.fromJS(data["schedule"]) : <any>undefined;
            this.ticketPriceId = data["ticketPriceId"];
            this.ticketPrice = data["ticketPrice"] ? TicketPrice.fromJS(data["ticketPrice"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketScheduleEnableListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketScheduleEnableListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["scheduleId"] = this.scheduleId;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["ticketPriceId"] = this.ticketPriceId;
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketScheduleEnableListDto {
        const json = this.toJSON();
        let result = new TicketScheduleEnableListDto();
        result.init(json);
        return result;
    }
}

export interface ITicketScheduleEnableListDto {
    /** BranchId */
    branchId: string | undefined;
    /** ScheduleId */
    scheduleId: string;
    /** Schedule */
    schedule: Schedule | undefined;
    /** TicketId */
    ticketPriceId: string | undefined;
    /** Ticket */
    ticketPrice: TicketPrice | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetTicketScheduleEnableForEditOutput implements IGetTicketScheduleEnableForEditOutput {
    ticketScheduleEnable: TicketScheduleEnableEditDto | undefined;

    constructor(data?: IGetTicketScheduleEnableForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketScheduleEnable = data["ticketScheduleEnable"] ? TicketScheduleEnableEditDto.fromJS(data["ticketScheduleEnable"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTicketScheduleEnableForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketScheduleEnableForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketScheduleEnable"] = this.ticketScheduleEnable ? this.ticketScheduleEnable.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTicketScheduleEnableForEditOutput {
        const json = this.toJSON();
        let result = new GetTicketScheduleEnableForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTicketScheduleEnableForEditOutput {
    ticketScheduleEnable: TicketScheduleEnableEditDto | undefined;
}

export class PagedResultDtoOfTicketScheduleEnableListDto implements IPagedResultDtoOfTicketScheduleEnableListDto {
    totalCount: number | undefined;
    items: TicketScheduleEnableListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTicketScheduleEnableListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TicketScheduleEnableListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketScheduleEnableListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketScheduleEnableListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTicketScheduleEnableListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTicketScheduleEnableListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTicketScheduleEnableListDto {
    totalCount: number | undefined;
    items: TicketScheduleEnableListDto[] | undefined;
}

export class CreateOrUpdateTicketStationInput implements ICreateOrUpdateTicketStationInput {
    ticketStation: TicketStationEditDto;

    constructor(data?: ICreateOrUpdateTicketStationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticketStation = new TicketStationEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketStation = data["ticketStation"] ? TicketStationEditDto.fromJS(data["ticketStation"]) : new TicketStationEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTicketStationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTicketStationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketStation"] = this.ticketStation ? this.ticketStation.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTicketStationInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTicketStationInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTicketStationInput {
    ticketStation: TicketStationEditDto;
}

export class TicketStationEditDto implements ITicketStationEditDto {
    /** Id */
    id: string | undefined;
    /** ScenicSpotId */
    scenicSpotId: string;
    /** StationName */
    stationName: string | undefined;
    /** Remand */
    remand: string | undefined;

    constructor(data?: ITicketStationEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.scenicSpotId = data["scenicSpotId"];
            this.stationName = data["stationName"];
            this.remand = data["remand"];
        }
    }

    static fromJS(data: any): TicketStationEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketStationEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["scenicSpotId"] = this.scenicSpotId;
        data["stationName"] = this.stationName;
        data["remand"] = this.remand;
        return data; 
    }

    clone(): TicketStationEditDto {
        const json = this.toJSON();
        let result = new TicketStationEditDto();
        result.init(json);
        return result;
    }
}

export interface ITicketStationEditDto {
    /** Id */
    id: string | undefined;
    /** ScenicSpotId */
    scenicSpotId: string;
    /** StationName */
    stationName: string | undefined;
    /** Remand */
    remand: string | undefined;
}

export class TicketStationListDto implements ITicketStationListDto {
    /** BranchId */
    branchId: string | undefined;
    /** ScenicSpotId */
    scenicSpotId: string;
    /** ScenicSpot */
    scenicSpot: ScenicSpot | undefined;
    /** StationName */
    stationName: string | undefined;
    /** Remand */
    remand: string | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ITicketStationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.scenicSpotId = data["scenicSpotId"];
            this.scenicSpot = data["scenicSpot"] ? ScenicSpot.fromJS(data["scenicSpot"]) : <any>undefined;
            this.stationName = data["stationName"];
            this.remand = data["remand"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketStationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketStationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["scenicSpotId"] = this.scenicSpotId;
        data["scenicSpot"] = this.scenicSpot ? this.scenicSpot.toJSON() : <any>undefined;
        data["stationName"] = this.stationName;
        data["remand"] = this.remand;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketStationListDto {
        const json = this.toJSON();
        let result = new TicketStationListDto();
        result.init(json);
        return result;
    }
}

export interface ITicketStationListDto {
    /** BranchId */
    branchId: string | undefined;
    /** ScenicSpotId */
    scenicSpotId: string;
    /** ScenicSpot */
    scenicSpot: ScenicSpot | undefined;
    /** StationName */
    stationName: string | undefined;
    /** Remand */
    remand: string | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetTicketStationForEditOutput implements IGetTicketStationForEditOutput {
    ticketStation: TicketStationEditDto | undefined;

    constructor(data?: IGetTicketStationForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketStation = data["ticketStation"] ? TicketStationEditDto.fromJS(data["ticketStation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTicketStationForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketStationForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketStation"] = this.ticketStation ? this.ticketStation.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTicketStationForEditOutput {
        const json = this.toJSON();
        let result = new GetTicketStationForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTicketStationForEditOutput {
    ticketStation: TicketStationEditDto | undefined;
}

export class PagedResultDtoOfTicketStationListDto implements IPagedResultDtoOfTicketStationListDto {
    totalCount: number | undefined;
    items: TicketStationListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTicketStationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TicketStationListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketStationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketStationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTicketStationListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTicketStationListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTicketStationListDto {
    totalCount: number | undefined;
    items: TicketStationListDto[] | undefined;
}

export class CreateOrUpdateTicketStationEnableInput implements ICreateOrUpdateTicketStationEnableInput {
    ticketStationEnable: TicketStationEnableEditDto;

    constructor(data?: ICreateOrUpdateTicketStationEnableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticketStationEnable = new TicketStationEnableEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketStationEnable = data["ticketStationEnable"] ? TicketStationEnableEditDto.fromJS(data["ticketStationEnable"]) : new TicketStationEnableEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTicketStationEnableInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTicketStationEnableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketStationEnable"] = this.ticketStationEnable ? this.ticketStationEnable.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTicketStationEnableInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTicketStationEnableInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTicketStationEnableInput {
    ticketStationEnable: TicketStationEnableEditDto;
}

export class TicketStationEnableEditDto implements ITicketStationEnableEditDto {
    /** Id */
    id: string | undefined;
    /** StationId */
    stationId: string | undefined;
    /** TicketId */
    ticketId: string | undefined;

    constructor(data?: ITicketStationEnableEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.stationId = data["stationId"];
            this.ticketId = data["ticketId"];
        }
    }

    static fromJS(data: any): TicketStationEnableEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketStationEnableEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["stationId"] = this.stationId;
        data["ticketId"] = this.ticketId;
        return data; 
    }

    clone(): TicketStationEnableEditDto {
        const json = this.toJSON();
        let result = new TicketStationEnableEditDto();
        result.init(json);
        return result;
    }
}

export interface ITicketStationEnableEditDto {
    /** Id */
    id: string | undefined;
    /** StationId */
    stationId: string | undefined;
    /** TicketId */
    ticketId: string | undefined;
}

export class TicketStationEnableListDto implements ITicketStationEnableListDto {
    /** BranchId */
    branchId: string | undefined;
    /** StationId */
    stationId: string | undefined;
    /** Station */
    station: TicketStation | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** Ticket */
    ticket: Ticket | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ITicketStationEnableListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.stationId = data["stationId"];
            this.station = data["station"] ? TicketStation.fromJS(data["station"]) : <any>undefined;
            this.ticketId = data["ticketId"];
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketStationEnableListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketStationEnableListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["stationId"] = this.stationId;
        data["station"] = this.station ? this.station.toJSON() : <any>undefined;
        data["ticketId"] = this.ticketId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketStationEnableListDto {
        const json = this.toJSON();
        let result = new TicketStationEnableListDto();
        result.init(json);
        return result;
    }
}

export interface ITicketStationEnableListDto {
    /** BranchId */
    branchId: string | undefined;
    /** StationId */
    stationId: string | undefined;
    /** Station */
    station: TicketStation | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** Ticket */
    ticket: Ticket | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class TicketStation implements ITicketStation {
    branchId: string | undefined;
    scenicSpotId: string;
    scenicSpot: ScenicSpot | undefined;
    stationName: string | undefined;
    remand: string | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ITicketStation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.scenicSpotId = data["scenicSpotId"];
            this.scenicSpot = data["scenicSpot"] ? ScenicSpot.fromJS(data["scenicSpot"]) : <any>undefined;
            this.stationName = data["stationName"];
            this.remand = data["remand"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketStation {
        data = typeof data === 'object' ? data : {};
        let result = new TicketStation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["scenicSpotId"] = this.scenicSpotId;
        data["scenicSpot"] = this.scenicSpot ? this.scenicSpot.toJSON() : <any>undefined;
        data["stationName"] = this.stationName;
        data["remand"] = this.remand;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketStation {
        const json = this.toJSON();
        let result = new TicketStation();
        result.init(json);
        return result;
    }
}

export interface ITicketStation {
    branchId: string | undefined;
    scenicSpotId: string;
    scenicSpot: ScenicSpot | undefined;
    stationName: string | undefined;
    remand: string | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetTicketStationEnableForEditOutput implements IGetTicketStationEnableForEditOutput {
    ticketStationEnable: TicketStationEnableEditDto | undefined;

    constructor(data?: IGetTicketStationEnableForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketStationEnable = data["ticketStationEnable"] ? TicketStationEnableEditDto.fromJS(data["ticketStationEnable"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTicketStationEnableForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketStationEnableForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketStationEnable"] = this.ticketStationEnable ? this.ticketStationEnable.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTicketStationEnableForEditOutput {
        const json = this.toJSON();
        let result = new GetTicketStationEnableForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTicketStationEnableForEditOutput {
    ticketStationEnable: TicketStationEnableEditDto | undefined;
}

export class PagedResultDtoOfTicketStationEnableListDto implements IPagedResultDtoOfTicketStationEnableListDto {
    totalCount: number | undefined;
    items: TicketStationEnableListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTicketStationEnableListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TicketStationEnableListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketStationEnableListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketStationEnableListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTicketStationEnableListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTicketStationEnableListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTicketStationEnableListDto {
    totalCount: number | undefined;
    items: TicketStationEnableListDto[] | undefined;
}

export class CreateOrUpdateTicketUserEnableInput implements ICreateOrUpdateTicketUserEnableInput {
    ticketUserEnable: TicketUserEnableEditDto;

    constructor(data?: ICreateOrUpdateTicketUserEnableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticketUserEnable = new TicketUserEnableEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketUserEnable = data["ticketUserEnable"] ? TicketUserEnableEditDto.fromJS(data["ticketUserEnable"]) : new TicketUserEnableEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTicketUserEnableInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTicketUserEnableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketUserEnable"] = this.ticketUserEnable ? this.ticketUserEnable.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTicketUserEnableInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTicketUserEnableInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTicketUserEnableInput {
    ticketUserEnable: TicketUserEnableEditDto;
}

export class TicketUserEnableEditDto implements ITicketUserEnableEditDto {
    /** Id */
    id: string | undefined;
    /** SaleUserId */
    saleUserId: number | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** 票价标识 */
    ticketPriceId: string | undefined;

    constructor(data?: ITicketUserEnableEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.saleUserId = data["saleUserId"];
            this.ticketId = data["ticketId"];
            this.ticketPriceId = data["ticketPriceId"];
        }
    }

    static fromJS(data: any): TicketUserEnableEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketUserEnableEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["saleUserId"] = this.saleUserId;
        data["ticketId"] = this.ticketId;
        data["ticketPriceId"] = this.ticketPriceId;
        return data; 
    }

    clone(): TicketUserEnableEditDto {
        const json = this.toJSON();
        let result = new TicketUserEnableEditDto();
        result.init(json);
        return result;
    }
}

export interface ITicketUserEnableEditDto {
    /** Id */
    id: string | undefined;
    /** SaleUserId */
    saleUserId: number | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** 票价标识 */
    ticketPriceId: string | undefined;
}

export class TicketUserEnableListDto implements ITicketUserEnableListDto {
    /** BranchId */
    branchId: string | undefined;
    /** SaleUserId */
    saleUserId: number | undefined;
    /** SaleUser */
    saleUser: User | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** Ticket */
    ticket: Ticket | undefined;
    /** 票价标识 */
    ticketPriceId: string | undefined;
    ticketPrice: TicketPrice | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ITicketUserEnableListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.saleUserId = data["saleUserId"];
            this.saleUser = data["saleUser"] ? User.fromJS(data["saleUser"]) : <any>undefined;
            this.ticketId = data["ticketId"];
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.ticketPriceId = data["ticketPriceId"];
            this.ticketPrice = data["ticketPrice"] ? TicketPrice.fromJS(data["ticketPrice"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketUserEnableListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketUserEnableListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["saleUserId"] = this.saleUserId;
        data["saleUser"] = this.saleUser ? this.saleUser.toJSON() : <any>undefined;
        data["ticketId"] = this.ticketId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["ticketPriceId"] = this.ticketPriceId;
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketUserEnableListDto {
        const json = this.toJSON();
        let result = new TicketUserEnableListDto();
        result.init(json);
        return result;
    }
}

export interface ITicketUserEnableListDto {
    /** BranchId */
    branchId: string | undefined;
    /** SaleUserId */
    saleUserId: number | undefined;
    /** SaleUser */
    saleUser: User | undefined;
    /** TicketId */
    ticketId: string | undefined;
    /** Ticket */
    ticket: Ticket | undefined;
    /** 票价标识 */
    ticketPriceId: string | undefined;
    ticketPrice: TicketPrice | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetTicketUserEnableForEditOutput implements IGetTicketUserEnableForEditOutput {
    ticketUserEnable: TicketUserEnableEditDto | undefined;

    constructor(data?: IGetTicketUserEnableForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketUserEnable = data["ticketUserEnable"] ? TicketUserEnableEditDto.fromJS(data["ticketUserEnable"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTicketUserEnableForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketUserEnableForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketUserEnable"] = this.ticketUserEnable ? this.ticketUserEnable.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTicketUserEnableForEditOutput {
        const json = this.toJSON();
        let result = new GetTicketUserEnableForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTicketUserEnableForEditOutput {
    ticketUserEnable: TicketUserEnableEditDto | undefined;
}

export class PagedResultDtoOfTicketUserEnableListDto implements IPagedResultDtoOfTicketUserEnableListDto {
    totalCount: number | undefined;
    items: TicketUserEnableListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTicketUserEnableListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TicketUserEnableListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketUserEnableListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketUserEnableListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTicketUserEnableListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTicketUserEnableListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTicketUserEnableListDto {
    totalCount: number | undefined;
    items: TicketUserEnableListDto[] | undefined;
}

export enum SettingScopes {
    Application = <any>"Application", 
    Tenant = <any>"Tenant", 
    User = <any>"User", 
    All = <any>"All", 
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfNameValueDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfNameValueDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;
}

export class CreateOrUpdateTravelAgencyInput implements ICreateOrUpdateTravelAgencyInput {
    travelAgency: TravelAgencyEditDto;

    constructor(data?: ICreateOrUpdateTravelAgencyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.travelAgency = new TravelAgencyEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.travelAgency = data["travelAgency"] ? TravelAgencyEditDto.fromJS(data["travelAgency"]) : new TravelAgencyEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTravelAgencyInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTravelAgencyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["travelAgency"] = this.travelAgency ? this.travelAgency.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTravelAgencyInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTravelAgencyInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTravelAgencyInput {
    travelAgency: TravelAgencyEditDto;
}

export class TravelAgencyEditDto implements ITravelAgencyEditDto {
    /** Id */
    id: string | undefined;
    /** TravelName */
    travelName: string;
    /** Mobile */
    mobile: string;
    /** Contacts */
    contacts: string;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    /** Discount */
    discount: number | undefined;
    /** PayMethod */
    payMethod: PayMethodEnum;
    /** TotalSum */
    totalSum: number;
    /** PrepaidAmount */
    prepaidAmount: number;
    /** AlarmAmount */
    alarmAmount: number;
    /** UpperLimit */
    upperLimit: number;
    /** Lowerlimit */
    lowerlimit: number;
    /** 登录密码 */
    passward: string | undefined;

    constructor(data?: ITravelAgencyEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.travelName = data["travelName"];
            this.mobile = data["mobile"];
            this.contacts = data["contacts"];
            this.isEnabled = data["isEnabled"];
            this.discount = data["discount"];
            this.payMethod = data["payMethod"];
            this.totalSum = data["totalSum"];
            this.prepaidAmount = data["prepaidAmount"];
            this.alarmAmount = data["alarmAmount"];
            this.upperLimit = data["upperLimit"];
            this.lowerlimit = data["lowerlimit"];
            this.passward = data["passward"];
        }
    }

    static fromJS(data: any): TravelAgencyEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TravelAgencyEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["travelName"] = this.travelName;
        data["mobile"] = this.mobile;
        data["contacts"] = this.contacts;
        data["isEnabled"] = this.isEnabled;
        data["discount"] = this.discount;
        data["payMethod"] = this.payMethod;
        data["totalSum"] = this.totalSum;
        data["prepaidAmount"] = this.prepaidAmount;
        data["alarmAmount"] = this.alarmAmount;
        data["upperLimit"] = this.upperLimit;
        data["lowerlimit"] = this.lowerlimit;
        data["passward"] = this.passward;
        return data; 
    }

    clone(): TravelAgencyEditDto {
        const json = this.toJSON();
        let result = new TravelAgencyEditDto();
        result.init(json);
        return result;
    }
}

export interface ITravelAgencyEditDto {
    /** Id */
    id: string | undefined;
    /** TravelName */
    travelName: string;
    /** Mobile */
    mobile: string;
    /** Contacts */
    contacts: string;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    /** Discount */
    discount: number | undefined;
    /** PayMethod */
    payMethod: PayMethodEnum;
    /** TotalSum */
    totalSum: number;
    /** PrepaidAmount */
    prepaidAmount: number;
    /** AlarmAmount */
    alarmAmount: number;
    /** UpperLimit */
    upperLimit: number;
    /** Lowerlimit */
    lowerlimit: number;
    /** 登录密码 */
    passward: string | undefined;
}

export class TravelAgencyListDto implements ITravelAgencyListDto {
    /** BranchId */
    branchId: string | undefined;
    /** TravelName */
    travelName: string;
    /** Mobile */
    mobile: string;
    /** Contacts */
    contacts: string;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    /** Discount */
    discount: number | undefined;
    /** PayMethod */
    payMethod: PayMethodEnum;
    /** TotalSum */
    totalSum: number;
    /** PrepaidAmount */
    prepaidAmount: number;
    /** AlarmAmount */
    alarmAmount: number;
    /** UpperLimit */
    upperLimit: number;
    /** Lowerlimit */
    lowerlimit: number;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ITravelAgencyListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.travelName = data["travelName"];
            this.mobile = data["mobile"];
            this.contacts = data["contacts"];
            this.isEnabled = data["isEnabled"];
            this.discount = data["discount"];
            this.payMethod = data["payMethod"];
            this.totalSum = data["totalSum"];
            this.prepaidAmount = data["prepaidAmount"];
            this.alarmAmount = data["alarmAmount"];
            this.upperLimit = data["upperLimit"];
            this.lowerlimit = data["lowerlimit"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TravelAgencyListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TravelAgencyListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["travelName"] = this.travelName;
        data["mobile"] = this.mobile;
        data["contacts"] = this.contacts;
        data["isEnabled"] = this.isEnabled;
        data["discount"] = this.discount;
        data["payMethod"] = this.payMethod;
        data["totalSum"] = this.totalSum;
        data["prepaidAmount"] = this.prepaidAmount;
        data["alarmAmount"] = this.alarmAmount;
        data["upperLimit"] = this.upperLimit;
        data["lowerlimit"] = this.lowerlimit;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TravelAgencyListDto {
        const json = this.toJSON();
        let result = new TravelAgencyListDto();
        result.init(json);
        return result;
    }
}

export interface ITravelAgencyListDto {
    /** BranchId */
    branchId: string | undefined;
    /** TravelName */
    travelName: string;
    /** Mobile */
    mobile: string;
    /** Contacts */
    contacts: string;
    /** IsEnabled */
    isEnabled: boolean | undefined;
    /** Discount */
    discount: number | undefined;
    /** PayMethod */
    payMethod: PayMethodEnum;
    /** TotalSum */
    totalSum: number;
    /** PrepaidAmount */
    prepaidAmount: number;
    /** AlarmAmount */
    alarmAmount: number;
    /** UpperLimit */
    upperLimit: number;
    /** Lowerlimit */
    lowerlimit: number;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetTravelAgencyForEditOutput implements IGetTravelAgencyForEditOutput {
    travelAgency: TravelAgencyEditDto | undefined;

    constructor(data?: IGetTravelAgencyForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.travelAgency = data["travelAgency"] ? TravelAgencyEditDto.fromJS(data["travelAgency"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTravelAgencyForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTravelAgencyForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["travelAgency"] = this.travelAgency ? this.travelAgency.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTravelAgencyForEditOutput {
        const json = this.toJSON();
        let result = new GetTravelAgencyForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTravelAgencyForEditOutput {
    travelAgency: TravelAgencyEditDto | undefined;
}

export class PagedResultDtoOfTravelAgencyListDto implements IPagedResultDtoOfTravelAgencyListDto {
    totalCount: number | undefined;
    items: TravelAgencyListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTravelAgencyListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TravelAgencyListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTravelAgencyListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTravelAgencyListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTravelAgencyListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTravelAgencyListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTravelAgencyListDto {
    totalCount: number | undefined;
    items: TravelAgencyListDto[] | undefined;
}

export class GetTravelAgencysInput implements IGetTravelAgencysInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetTravelAgencysInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetTravelAgencysInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTravelAgencysInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetTravelAgencysInput {
        const json = this.toJSON();
        let result = new GetTravelAgencysInput();
        result.init(json);
        return result;
    }
}

export interface IGetTravelAgencysInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class CreateOrUpdateTravelTicketDetailInput implements ICreateOrUpdateTravelTicketDetailInput {
    travelTicketDetail: TravelTicketDetailEditDto;

    constructor(data?: ICreateOrUpdateTravelTicketDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.travelTicketDetail = new TravelTicketDetailEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.travelTicketDetail = data["travelTicketDetail"] ? TravelTicketDetailEditDto.fromJS(data["travelTicketDetail"]) : new TravelTicketDetailEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTravelTicketDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTravelTicketDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["travelTicketDetail"] = this.travelTicketDetail ? this.travelTicketDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTravelTicketDetailInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTravelTicketDetailInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTravelTicketDetailInput {
    travelTicketDetail: TravelTicketDetailEditDto;
}

export class TravelTicketDetailEditDto implements ITravelTicketDetailEditDto {
    /** Id */
    id: string | undefined;
    /** CustomerId */
    customerId: string;
    /** TravelAgencyId */
    travelAgencyId: string;
    /** ActivityTempId */
    activityTempId: string;
    /** ActivityTempDetailId */
    activityTempDetailId: string;

    constructor(data?: ITravelTicketDetailEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.customerId = data["customerId"];
            this.travelAgencyId = data["travelAgencyId"];
            this.activityTempId = data["activityTempId"];
            this.activityTempDetailId = data["activityTempDetailId"];
        }
    }

    static fromJS(data: any): TravelTicketDetailEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TravelTicketDetailEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerId"] = this.customerId;
        data["travelAgencyId"] = this.travelAgencyId;
        data["activityTempId"] = this.activityTempId;
        data["activityTempDetailId"] = this.activityTempDetailId;
        return data; 
    }

    clone(): TravelTicketDetailEditDto {
        const json = this.toJSON();
        let result = new TravelTicketDetailEditDto();
        result.init(json);
        return result;
    }
}

export interface ITravelTicketDetailEditDto {
    /** Id */
    id: string | undefined;
    /** CustomerId */
    customerId: string;
    /** TravelAgencyId */
    travelAgencyId: string;
    /** ActivityTempId */
    activityTempId: string;
    /** ActivityTempDetailId */
    activityTempDetailId: string;
}

export class TravelTicketDetailListDto implements ITravelTicketDetailListDto {
    /** BranchId */
    branchId: string | undefined;
    /** CustomerId */
    customerId: string;
    /** Customer */
    customer: Customer | undefined;
    /** TravelAgencyId */
    travelAgencyId: string;
    /** TravelAgency */
    travelAgency: TravelAgency | undefined;
    /** ActivityTempId */
    activityTempId: string;
    /** ActivityTemp */
    activityTemp: ActivityTemp | undefined;
    /** ActivityTempDetailId */
    activityTempDetailId: string;
    /** ActivityTempDetail */
    activityTempDetail: ActivityTempDetail | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ITravelTicketDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.customerId = data["customerId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.travelAgencyId = data["travelAgencyId"];
            this.travelAgency = data["travelAgency"] ? TravelAgency.fromJS(data["travelAgency"]) : <any>undefined;
            this.activityTempId = data["activityTempId"];
            this.activityTemp = data["activityTemp"] ? ActivityTemp.fromJS(data["activityTemp"]) : <any>undefined;
            this.activityTempDetailId = data["activityTempDetailId"];
            this.activityTempDetail = data["activityTempDetail"] ? ActivityTempDetail.fromJS(data["activityTempDetail"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TravelTicketDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TravelTicketDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["travelAgencyId"] = this.travelAgencyId;
        data["travelAgency"] = this.travelAgency ? this.travelAgency.toJSON() : <any>undefined;
        data["activityTempId"] = this.activityTempId;
        data["activityTemp"] = this.activityTemp ? this.activityTemp.toJSON() : <any>undefined;
        data["activityTempDetailId"] = this.activityTempDetailId;
        data["activityTempDetail"] = this.activityTempDetail ? this.activityTempDetail.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TravelTicketDetailListDto {
        const json = this.toJSON();
        let result = new TravelTicketDetailListDto();
        result.init(json);
        return result;
    }
}

export interface ITravelTicketDetailListDto {
    /** BranchId */
    branchId: string | undefined;
    /** CustomerId */
    customerId: string;
    /** Customer */
    customer: Customer | undefined;
    /** TravelAgencyId */
    travelAgencyId: string;
    /** TravelAgency */
    travelAgency: TravelAgency | undefined;
    /** ActivityTempId */
    activityTempId: string;
    /** ActivityTemp */
    activityTemp: ActivityTemp | undefined;
    /** ActivityTempDetailId */
    activityTempDetailId: string;
    /** ActivityTempDetail */
    activityTempDetail: ActivityTempDetail | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetTravelTicketDetailForEditOutput implements IGetTravelTicketDetailForEditOutput {
    travelTicketDetail: TravelTicketDetailEditDto | undefined;

    constructor(data?: IGetTravelTicketDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.travelTicketDetail = data["travelTicketDetail"] ? TravelTicketDetailEditDto.fromJS(data["travelTicketDetail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTravelTicketDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTravelTicketDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["travelTicketDetail"] = this.travelTicketDetail ? this.travelTicketDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTravelTicketDetailForEditOutput {
        const json = this.toJSON();
        let result = new GetTravelTicketDetailForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTravelTicketDetailForEditOutput {
    travelTicketDetail: TravelTicketDetailEditDto | undefined;
}

export class PagedResultDtoOfTravelTicketDetailListDto implements IPagedResultDtoOfTravelTicketDetailListDto {
    totalCount: number | undefined;
    items: TravelTicketDetailListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTravelTicketDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TravelTicketDetailListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTravelTicketDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTravelTicketDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTravelTicketDetailListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTravelTicketDetailListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTravelTicketDetailListDto {
    totalCount: number | undefined;
    items: TravelTicketDetailListDto[] | undefined;
}

/** 用户信息新增和编辑时用Dto */
export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    /** 用户信息编辑Dto */
    user: UserEditDto | undefined;
    /** 授权的角色 */
    assignedRoleNames: string[];
    /** 所在的组织机构的ID */
    organizationUnits: number[] | undefined;
    /** 发送激活邮件 */
    sendActivationEmail: boolean | undefined;
    /** 设置随机密码 */
    setRandomPassword: boolean | undefined;
    /** 机构标识 */
    branchId: string | undefined;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.assignedRoleNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : <any>undefined;
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [] as any;
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames.push(item);
            }
            if (data["organizationUnits"] && data["organizationUnits"].constructor === Array) {
                this.organizationUnits = [] as any;
                for (let item of data["organizationUnits"])
                    this.organizationUnits.push(item);
            }
            this.sendActivationEmail = data["sendActivationEmail"];
            this.setRandomPassword = data["setRandomPassword"];
            this.branchId = data["branchId"];
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        if (this.organizationUnits && this.organizationUnits.constructor === Array) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        data["branchId"] = this.branchId;
        return data; 
    }

    clone(): CreateOrUpdateUserInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateUserInput();
        result.init(json);
        return result;
    }
}

/** 用户信息新增和编辑时用Dto */
export interface ICreateOrUpdateUserInput {
    /** 用户信息编辑Dto */
    user: UserEditDto | undefined;
    /** 授权的角色 */
    assignedRoleNames: string[];
    /** 所在的组织机构的ID */
    organizationUnits: number[] | undefined;
    /** 发送激活邮件 */
    sendActivationEmail: boolean | undefined;
    /** 设置随机密码 */
    setRandomPassword: boolean | undefined;
    /** 机构标识 */
    branchId: string | undefined;
}

/** 用户信息编辑用Dto */
export class UserEditDto implements IUserEditDto {
    /** 根据id是否有值来判断是创建还是添加 */
    id: number | undefined;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    isLockoutEnabled: boolean | undefined;
    /** 需要修改密码 */
    needToChangeThePassword: boolean | undefined;
    /** 头像Id */
    profilePictureId: string | undefined;
    isTwoFactorEnabled: boolean | undefined;
    isActive: boolean | undefined;
    branchId: string | undefined;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.password = data["password"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
            this.needToChangeThePassword = data["needToChangeThePassword"];
            this.profilePictureId = data["profilePictureId"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.isActive = data["isActive"];
            this.branchId = data["branchId"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["needToChangeThePassword"] = this.needToChangeThePassword;
        data["profilePictureId"] = this.profilePictureId;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isActive"] = this.isActive;
        data["branchId"] = this.branchId;
        return data; 
    }

    clone(): UserEditDto {
        const json = this.toJSON();
        let result = new UserEditDto();
        result.init(json);
        return result;
    }
}

/** 用户信息编辑用Dto */
export interface IUserEditDto {
    /** 根据id是否有值来判断是创建还是添加 */
    id: number | undefined;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    isLockoutEnabled: boolean | undefined;
    /** 需要修改密码 */
    needToChangeThePassword: boolean | undefined;
    /** 头像Id */
    profilePictureId: string | undefined;
    isTwoFactorEnabled: boolean | undefined;
    isActive: boolean | undefined;
    branchId: string | undefined;
}

export class GetUserForEditTreeOutput implements IGetUserForEditTreeOutput {
    user: UserEditDto | undefined;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitListDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
    /** 机构 */
    branch: Branch | undefined;

    constructor(data?: IGetUserForEditTreeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : <any>undefined;
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles.push(UserRoleDto.fromJS(item));
            }
            if (data["allOrganizationUnits"] && data["allOrganizationUnits"].constructor === Array) {
                this.allOrganizationUnits = [] as any;
                for (let item of data["allOrganizationUnits"])
                    this.allOrganizationUnits.push(OrganizationUnitListDto.fromJS(item));
            }
            if (data["memberedOrganizationUnits"] && data["memberedOrganizationUnits"].constructor === Array) {
                this.memberedOrganizationUnits = [] as any;
                for (let item of data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits.push(item);
            }
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetUserForEditTreeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditTreeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (this.allOrganizationUnits && this.allOrganizationUnits.constructor === Array) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (this.memberedOrganizationUnits && this.memberedOrganizationUnits.constructor === Array) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetUserForEditTreeOutput {
        const json = this.toJSON();
        let result = new GetUserForEditTreeOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserForEditTreeOutput {
    user: UserEditDto | undefined;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitListDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
    /** 机构 */
    branch: Branch | undefined;
}

export class UserRoleDto implements IUserRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean | undefined;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.roleDisplayName = data["roleDisplayName"];
            this.isAssigned = data["isAssigned"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        return data; 
    }

    clone(): UserRoleDto {
        const json = this.toJSON();
        let result = new UserRoleDto();
        result.init(json);
        return result;
    }
}

export interface IUserRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean | undefined;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount: number | undefined;
    items: UserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfUserListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number | undefined;
    items: UserListDto[] | undefined;
}

/** 用户信息列表Dto */
export class UserListDto implements IUserListDto {
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    isEmailConfirmed: boolean | undefined;
    roles: UserListRoleDto[] | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    isActive: boolean | undefined;
    id: number | undefined;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles.push(UserListRoleDto.fromJS(item));
            }
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserListDto {
        const json = this.toJSON();
        let result = new UserListDto();
        result.init(json);
        return result;
    }
}

/** 用户信息列表Dto */
export interface IUserListDto {
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    isEmailConfirmed: boolean | undefined;
    roles: UserListRoleDto[] | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    isActive: boolean | undefined;
    id: number | undefined;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data; 
    }

    clone(): UserListRoleDto {
        const json = this.toJSON();
        let result = new UserListRoleDto();
        result.init(json);
        return result;
    }
}

export interface IUserListRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
}

export class GetUserPermissionsTreeForEditOutput implements IGetUserPermissionsTreeForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetUserPermissionsTreeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsTreeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsTreeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetUserPermissionsTreeForEditOutput {
        const json = this.toJSON();
        let result = new GetUserPermissionsTreeForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserPermissionsTreeForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto | undefined;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitListDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePictureId = data["profilePictureId"];
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : <any>undefined;
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles.push(UserRoleDto.fromJS(item));
            }
            if (data["allOrganizationUnits"] && data["allOrganizationUnits"].constructor === Array) {
                this.allOrganizationUnits = [] as any;
                for (let item of data["allOrganizationUnits"])
                    this.allOrganizationUnits.push(OrganizationUnitListDto.fromJS(item));
            }
            if (data["memberedOrganizationUnits"] && data["memberedOrganizationUnits"].constructor === Array) {
                this.memberedOrganizationUnits = [] as any;
                for (let item of data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (this.allOrganizationUnits && this.allOrganizationUnits.constructor === Array) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (this.memberedOrganizationUnits && this.memberedOrganizationUnits.constructor === Array) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        return data; 
    }

    clone(): GetUserForEditOutput {
        const json = this.toJSON();
        let result = new GetUserForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto | undefined;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitListDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    /** 所有的权限 */
    permissions: FlatPermissionDto[] | undefined;
    /** 已有权限 */
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetUserPermissionsForEditOutput {
        const json = this.toJSON();
        let result = new GetUserPermissionsForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserPermissionsForEditOutput {
    /** 所有的权限 */
    permissions: FlatPermissionDto[] | undefined;
    /** 已有权限 */
    grantedPermissionNames: string[] | undefined;
}

export class NullableIdDtoOfInt64 implements INullableIdDtoOfInt64 {
    id: number | undefined;

    constructor(data?: INullableIdDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): NullableIdDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new NullableIdDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): NullableIdDtoOfInt64 {
        const json = this.toJSON();
        let result = new NullableIdDtoOfInt64();
        result.init(json);
        return result;
    }
}

export interface INullableIdDtoOfInt64 {
    id: number | undefined;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id: number | undefined;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDtoOfInt64 {
        const json = this.toJSON();
        let result = new EntityDtoOfInt64();
        result.init(json);
        return result;
    }
}

export interface IEntityDtoOfInt64 {
    id: number | undefined;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id: number | undefined;
    grantedPermissionNames: string[];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): UpdateUserPermissionsInput {
        const json = this.toJSON();
        let result = new UpdateUserPermissionsInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserPermissionsInput {
    id: number | undefined;
    grantedPermissionNames: string[];
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount: number | undefined;
    items: LinkedUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfLinkedUserDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount: number | undefined;
    items: LinkedUserDto[] | undefined;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    id: number | undefined;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.username = data["username"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["id"] = this.id;
        return data; 
    }

    clone(): LinkedUserDto {
        const json = this.toJSON();
        let result = new LinkedUserDto();
        result.init(json);
        return result;
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    id: number | undefined;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfLinkedUserDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.usernameOrEmailAddress = data["usernameOrEmailAddress"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data; 
    }

    clone(): LinkToUserInput {
        const json = this.toJSON();
        let result = new LinkToUserInput();
        result.init(json);
        return result;
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number | undefined;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): UnlinkUserInput {
        const json = this.toJSON();
        let result = new UnlinkUserInput();
        result.init(json);
        return result;
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;

    constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfUserLoginAttemptDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmailAddress: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment | undefined;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.result = data["result"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): UserLoginAttemptDto {
        const json = this.toJSON();
        let result = new UserLoginAttemptDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmailAddress: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class CreateOrUpdateVerifiableSetInput implements ICreateOrUpdateVerifiableSetInput {
    verifiableSet: VerifiableSetEditDto;

    constructor(data?: ICreateOrUpdateVerifiableSetInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.verifiableSet = new VerifiableSetEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.verifiableSet = data["verifiableSet"] ? VerifiableSetEditDto.fromJS(data["verifiableSet"]) : new VerifiableSetEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateVerifiableSetInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateVerifiableSetInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["verifiableSet"] = this.verifiableSet ? this.verifiableSet.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateVerifiableSetInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateVerifiableSetInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateVerifiableSetInput {
    verifiableSet: VerifiableSetEditDto;
}

export class VerifiableSetEditDto implements IVerifiableSetEditDto {
    /** Id */
    id: string | undefined;
    /** DeviceId */
    deviceId: string;
    /** VerifiableType */
    verifiableType: VerifiableTypeEnum;
    /** IsEnabled */
    isEnabled: boolean;

    constructor(data?: IVerifiableSetEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.deviceId = data["deviceId"];
            this.verifiableType = data["verifiableType"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): VerifiableSetEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifiableSetEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceId"] = this.deviceId;
        data["verifiableType"] = this.verifiableType;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }

    clone(): VerifiableSetEditDto {
        const json = this.toJSON();
        let result = new VerifiableSetEditDto();
        result.init(json);
        return result;
    }
}

export interface IVerifiableSetEditDto {
    /** Id */
    id: string | undefined;
    /** DeviceId */
    deviceId: string;
    /** VerifiableType */
    verifiableType: VerifiableTypeEnum;
    /** IsEnabled */
    isEnabled: boolean;
}

export class VerifiableSetListDto implements IVerifiableSetListDto {
    /** BranchId */
    branchId: string | undefined;
    /** DeviceId */
    deviceId: string;
    /** VerifiableType */
    verifiableType: VerifiableTypeEnum;
    /** IsEnabled */
    isEnabled: boolean;
    /** Device */
    device: Device | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IVerifiableSetListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.deviceId = data["deviceId"];
            this.verifiableType = data["verifiableType"];
            this.isEnabled = data["isEnabled"];
            this.device = data["device"] ? Device.fromJS(data["device"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): VerifiableSetListDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifiableSetListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["deviceId"] = this.deviceId;
        data["verifiableType"] = this.verifiableType;
        data["isEnabled"] = this.isEnabled;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): VerifiableSetListDto {
        const json = this.toJSON();
        let result = new VerifiableSetListDto();
        result.init(json);
        return result;
    }
}

export interface IVerifiableSetListDto {
    /** BranchId */
    branchId: string | undefined;
    /** DeviceId */
    deviceId: string;
    /** VerifiableType */
    verifiableType: VerifiableTypeEnum;
    /** IsEnabled */
    isEnabled: boolean;
    /** Device */
    device: Device | undefined;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetVerifiableSetForEditOutput implements IGetVerifiableSetForEditOutput {
    verifiableSet: VerifiableSetEditDto | undefined;

    constructor(data?: IGetVerifiableSetForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.verifiableSet = data["verifiableSet"] ? VerifiableSetEditDto.fromJS(data["verifiableSet"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetVerifiableSetForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetVerifiableSetForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["verifiableSet"] = this.verifiableSet ? this.verifiableSet.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetVerifiableSetForEditOutput {
        const json = this.toJSON();
        let result = new GetVerifiableSetForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetVerifiableSetForEditOutput {
    verifiableSet: VerifiableSetEditDto | undefined;
}

export class PagedResultDtoOfVerifiableSetListDto implements IPagedResultDtoOfVerifiableSetListDto {
    totalCount: number | undefined;
    items: VerifiableSetListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfVerifiableSetListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(VerifiableSetListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfVerifiableSetListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfVerifiableSetListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfVerifiableSetListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfVerifiableSetListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfVerifiableSetListDto {
    totalCount: number | undefined;
    items: VerifiableSetListDto[] | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["latestWebLogLines"] && data["latestWebLogLines"].constructor === Array) {
                this.latestWebLogLines = [] as any;
                for (let item of data["latestWebLogLines"])
                    this.latestWebLogLines.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.latestWebLogLines && this.latestWebLogLines.constructor === Array) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data; 
    }

    clone(): GetLatestWebLogsOutput {
        const json = this.toJSON();
        let result = new GetLatestWebLogsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export class CreateOrUpdateWechatAppConfigInput implements ICreateOrUpdateWechatAppConfigInput {
    wechatAppConfig: WechatAppConfigEditDto;

    constructor(data?: ICreateOrUpdateWechatAppConfigInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.wechatAppConfig = new WechatAppConfigEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.wechatAppConfig = data["wechatAppConfig"] ? WechatAppConfigEditDto.fromJS(data["wechatAppConfig"]) : new WechatAppConfigEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateWechatAppConfigInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateWechatAppConfigInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wechatAppConfig"] = this.wechatAppConfig ? this.wechatAppConfig.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateWechatAppConfigInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateWechatAppConfigInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateWechatAppConfigInput {
    wechatAppConfig: WechatAppConfigEditDto;
}

export class WechatAppConfigEditDto implements IWechatAppConfigEditDto {
    /** Id */
    id: number | undefined;
    /** AppId */
    appId: string;
    /** AppSecret */
    appSecret: string;
    /** Token */
    token: string;
    /** EncodingAESKey */
    encodingAESKey: string | undefined;
    /** 公众号名称 */
    name: string;
    /** 公众号原始ID */
    appOrgId: string | undefined;
    /** 公众号类型 */
    appType: WechatAppTypeEnum;
    /** QRCodeUrl */
    qrCodeUrl: string | undefined;

    constructor(data?: IWechatAppConfigEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.appId = data["appId"];
            this.appSecret = data["appSecret"];
            this.token = data["token"];
            this.encodingAESKey = data["encodingAESKey"];
            this.name = data["name"];
            this.appOrgId = data["appOrgId"];
            this.appType = data["appType"];
            this.qrCodeUrl = data["qrCodeUrl"];
        }
    }

    static fromJS(data: any): WechatAppConfigEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new WechatAppConfigEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["appId"] = this.appId;
        data["appSecret"] = this.appSecret;
        data["token"] = this.token;
        data["encodingAESKey"] = this.encodingAESKey;
        data["name"] = this.name;
        data["appOrgId"] = this.appOrgId;
        data["appType"] = this.appType;
        data["qrCodeUrl"] = this.qrCodeUrl;
        return data; 
    }

    clone(): WechatAppConfigEditDto {
        const json = this.toJSON();
        let result = new WechatAppConfigEditDto();
        result.init(json);
        return result;
    }
}

export interface IWechatAppConfigEditDto {
    /** Id */
    id: number | undefined;
    /** AppId */
    appId: string;
    /** AppSecret */
    appSecret: string;
    /** Token */
    token: string;
    /** EncodingAESKey */
    encodingAESKey: string | undefined;
    /** 公众号名称 */
    name: string;
    /** 公众号原始ID */
    appOrgId: string | undefined;
    /** 公众号类型 */
    appType: WechatAppTypeEnum;
    /** QRCodeUrl */
    qrCodeUrl: string | undefined;
}

export enum WechatAppTypeEnum {
    订阅号 = <any>"订阅号", 
    认证订阅号 = <any>"认证订阅号", 
    服务号 = <any>"服务号", 
    认证服务号 = <any>"认证服务号", 
}

export class WechatAppConfigListDto implements IWechatAppConfigListDto {
    /** AppId */
    appId: string;
    /** 公众号名称 */
    name: string;
    /** 公众号类型 */
    appType: WechatAppTypeEnum | undefined;
    /** 公众号类型中文名称 */
    appTypeStr: string | undefined;
    /** QRCodeUrl */
    qrCodeUrl: string | undefined;
    /** 已注册到应用冲 */
    registered: boolean | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IWechatAppConfigListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.appId = data["appId"];
            this.name = data["name"];
            this.appType = data["appType"];
            this.appTypeStr = data["appTypeStr"];
            this.qrCodeUrl = data["qrCodeUrl"];
            this.registered = data["registered"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WechatAppConfigListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WechatAppConfigListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId;
        data["name"] = this.name;
        data["appType"] = this.appType;
        data["appTypeStr"] = this.appTypeStr;
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["registered"] = this.registered;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): WechatAppConfigListDto {
        const json = this.toJSON();
        let result = new WechatAppConfigListDto();
        result.init(json);
        return result;
    }
}

export interface IWechatAppConfigListDto {
    /** AppId */
    appId: string;
    /** 公众号名称 */
    name: string;
    /** 公众号类型 */
    appType: WechatAppTypeEnum | undefined;
    /** 公众号类型中文名称 */
    appTypeStr: string | undefined;
    /** QRCodeUrl */
    qrCodeUrl: string | undefined;
    /** 已注册到应用冲 */
    registered: boolean | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class GetWechatAppConfigForEditOutput implements IGetWechatAppConfigForEditOutput {
    wechatAppConfig: WechatAppConfigEditDto | undefined;
    wechatAppTypeList: KeyValuePairOfStringAndInt32[] | undefined;

    constructor(data?: IGetWechatAppConfigForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wechatAppConfig = data["wechatAppConfig"] ? WechatAppConfigEditDto.fromJS(data["wechatAppConfig"]) : <any>undefined;
            if (data["wechatAppTypeList"] && data["wechatAppTypeList"].constructor === Array) {
                this.wechatAppTypeList = [] as any;
                for (let item of data["wechatAppTypeList"])
                    this.wechatAppTypeList.push(KeyValuePairOfStringAndInt32.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetWechatAppConfigForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWechatAppConfigForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wechatAppConfig"] = this.wechatAppConfig ? this.wechatAppConfig.toJSON() : <any>undefined;
        if (this.wechatAppTypeList && this.wechatAppTypeList.constructor === Array) {
            data["wechatAppTypeList"] = [];
            for (let item of this.wechatAppTypeList)
                data["wechatAppTypeList"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetWechatAppConfigForEditOutput {
        const json = this.toJSON();
        let result = new GetWechatAppConfigForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetWechatAppConfigForEditOutput {
    wechatAppConfig: WechatAppConfigEditDto | undefined;
    wechatAppTypeList: KeyValuePairOfStringAndInt32[] | undefined;
}

export class KeyValuePairOfStringAndInt32 implements IKeyValuePairOfStringAndInt32 {
    readonly key: string | undefined;
    readonly value: number | undefined;

    constructor(data?: IKeyValuePairOfStringAndInt32) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).key = data["key"];
            (<any>this).value = data["value"];
        }
    }

    static fromJS(data: any): KeyValuePairOfStringAndInt32 {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValuePairOfStringAndInt32();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }

    clone(): KeyValuePairOfStringAndInt32 {
        const json = this.toJSON();
        let result = new KeyValuePairOfStringAndInt32();
        result.init(json);
        return result;
    }
}

export interface IKeyValuePairOfStringAndInt32 {
    key: string | undefined;
    value: number | undefined;
}

export class PagedResultDtoOfWechatAppConfigListDto implements IPagedResultDtoOfWechatAppConfigListDto {
    totalCount: number | undefined;
    items: WechatAppConfigListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWechatAppConfigListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(WechatAppConfigListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWechatAppConfigListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWechatAppConfigListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfWechatAppConfigListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfWechatAppConfigListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfWechatAppConfigListDto {
    totalCount: number | undefined;
    items: WechatAppConfigListDto[] | undefined;
}

export class GetImageTextMaterialsInput implements IGetImageTextMaterialsInput {
    appId: string;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetImageTextMaterialsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.appId = data["appId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetImageTextMaterialsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetImageTextMaterialsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetImageTextMaterialsInput {
        const json = this.toJSON();
        let result = new GetImageTextMaterialsInput();
        result.init(json);
        return result;
    }
}

export interface IGetImageTextMaterialsInput {
    appId: string;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfMediaList_News_Item implements IPagedResultDtoOfMediaList_News_Item {
    totalCount: number | undefined;
    items: MediaList_News_Item[] | undefined;

    constructor(data?: IPagedResultDtoOfMediaList_News_Item) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(MediaList_News_Item.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMediaList_News_Item {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMediaList_News_Item();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfMediaList_News_Item {
        const json = this.toJSON();
        let result = new PagedResultDtoOfMediaList_News_Item();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfMediaList_News_Item {
    totalCount: number | undefined;
    items: MediaList_News_Item[] | undefined;
}

export class MediaList_News_Item implements IMediaList_News_Item {
    media_id: string | undefined;
    content: Media_News_Content | undefined;
    update_time: number | undefined;

    constructor(data?: IMediaList_News_Item) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.media_id = data["media_id"];
            this.content = data["content"] ? Media_News_Content.fromJS(data["content"]) : <any>undefined;
            this.update_time = data["update_time"];
        }
    }

    static fromJS(data: any): MediaList_News_Item {
        data = typeof data === 'object' ? data : {};
        let result = new MediaList_News_Item();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["media_id"] = this.media_id;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        data["update_time"] = this.update_time;
        return data; 
    }

    clone(): MediaList_News_Item {
        const json = this.toJSON();
        let result = new MediaList_News_Item();
        result.init(json);
        return result;
    }
}

export interface IMediaList_News_Item {
    media_id: string | undefined;
    content: Media_News_Content | undefined;
    update_time: number | undefined;
}

export class Media_News_Content implements IMedia_News_Content {
    news_item: Media_News_Content_Item[] | undefined;

    constructor(data?: IMedia_News_Content) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["news_item"] && data["news_item"].constructor === Array) {
                this.news_item = [] as any;
                for (let item of data["news_item"])
                    this.news_item.push(Media_News_Content_Item.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Media_News_Content {
        data = typeof data === 'object' ? data : {};
        let result = new Media_News_Content();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.news_item && this.news_item.constructor === Array) {
            data["news_item"] = [];
            for (let item of this.news_item)
                data["news_item"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Media_News_Content {
        const json = this.toJSON();
        let result = new Media_News_Content();
        result.init(json);
        return result;
    }
}

export interface IMedia_News_Content {
    news_item: Media_News_Content_Item[] | undefined;
}

export class Media_News_Content_Item implements IMedia_News_Content_Item {
    url: string | undefined;
    thumb_url: string | undefined;
    thumb_media_id: string | undefined;
    author: string | undefined;
    title: string | undefined;
    content_source_url: string | undefined;
    content: string | undefined;
    digest: string | undefined;
    show_cover_pic: string | undefined;
    need_open_comment: number | undefined;
    only_fans_can_comment: number | undefined;

    constructor(data?: IMedia_News_Content_Item) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.url = data["url"];
            this.thumb_url = data["thumb_url"];
            this.thumb_media_id = data["thumb_media_id"];
            this.author = data["author"];
            this.title = data["title"];
            this.content_source_url = data["content_source_url"];
            this.content = data["content"];
            this.digest = data["digest"];
            this.show_cover_pic = data["show_cover_pic"];
            this.need_open_comment = data["need_open_comment"];
            this.only_fans_can_comment = data["only_fans_can_comment"];
        }
    }

    static fromJS(data: any): Media_News_Content_Item {
        data = typeof data === 'object' ? data : {};
        let result = new Media_News_Content_Item();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["thumb_url"] = this.thumb_url;
        data["thumb_media_id"] = this.thumb_media_id;
        data["author"] = this.author;
        data["title"] = this.title;
        data["content_source_url"] = this.content_source_url;
        data["content"] = this.content;
        data["digest"] = this.digest;
        data["show_cover_pic"] = this.show_cover_pic;
        data["need_open_comment"] = this.need_open_comment;
        data["only_fans_can_comment"] = this.only_fans_can_comment;
        return data; 
    }

    clone(): Media_News_Content_Item {
        const json = this.toJSON();
        let result = new Media_News_Content_Item();
        result.init(json);
        return result;
    }
}

export interface IMedia_News_Content_Item {
    url: string | undefined;
    thumb_url: string | undefined;
    thumb_media_id: string | undefined;
    author: string | undefined;
    title: string | undefined;
    content_source_url: string | undefined;
    content: string | undefined;
    digest: string | undefined;
    show_cover_pic: string | undefined;
    need_open_comment: number | undefined;
    only_fans_can_comment: number | undefined;
}

export class GetOtherMaterialsInput implements IGetOtherMaterialsInput {
    appId: string;
    materialType: UploadMediaFileType;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetOtherMaterialsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.appId = data["appId"];
            this.materialType = data["materialType"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetOtherMaterialsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetOtherMaterialsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId;
        data["materialType"] = this.materialType;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetOtherMaterialsInput {
        const json = this.toJSON();
        let result = new GetOtherMaterialsInput();
        result.init(json);
        return result;
    }
}

export interface IGetOtherMaterialsInput {
    appId: string;
    materialType: UploadMediaFileType;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export enum UploadMediaFileType {
    Image = <any>"image", 
    Voice = <any>"voice", 
    Video = <any>"video", 
    Thumb = <any>"thumb", 
    News = <any>"news", 
}

export class PagedResultDtoOfMediaList_Others_Item implements IPagedResultDtoOfMediaList_Others_Item {
    totalCount: number | undefined;
    items: MediaList_Others_Item[] | undefined;

    constructor(data?: IPagedResultDtoOfMediaList_Others_Item) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(MediaList_Others_Item.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMediaList_Others_Item {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMediaList_Others_Item();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfMediaList_Others_Item {
        const json = this.toJSON();
        let result = new PagedResultDtoOfMediaList_Others_Item();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfMediaList_Others_Item {
    totalCount: number | undefined;
    items: MediaList_Others_Item[] | undefined;
}

export class MediaList_Others_Item implements IMediaList_Others_Item {
    media_id: string | undefined;
    name: string | undefined;
    update_time: number | undefined;
    url: string | undefined;

    constructor(data?: IMediaList_Others_Item) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.media_id = data["media_id"];
            this.name = data["name"];
            this.update_time = data["update_time"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): MediaList_Others_Item {
        data = typeof data === 'object' ? data : {};
        let result = new MediaList_Others_Item();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["media_id"] = this.media_id;
        data["name"] = this.name;
        data["update_time"] = this.update_time;
        data["url"] = this.url;
        return data; 
    }

    clone(): MediaList_Others_Item {
        const json = this.toJSON();
        let result = new MediaList_Others_Item();
        result.init(json);
        return result;
    }
}

export interface IMediaList_Others_Item {
    media_id: string | undefined;
    name: string | undefined;
    update_time: number | undefined;
    url: string | undefined;
}

/** 创建或编辑菜单 */
export class CreateOrEditWechatMenuInput implements ICreateOrEditWechatMenuInput {
    /** 应用key */
    appId: string | undefined;
    /** 菜单数据结构 */
    menu: MenuFull_RootButton[] | undefined;
    /** 匹配规则，当菜单是个性化菜单的时候输入 */
    matchRule: MenuMatchRule | undefined;

    constructor(data?: ICreateOrEditWechatMenuInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.appId = data["appId"];
            if (data["menu"] && data["menu"].constructor === Array) {
                this.menu = [] as any;
                for (let item of data["menu"])
                    this.menu.push(MenuFull_RootButton.fromJS(item));
            }
            this.matchRule = data["matchRule"] ? MenuMatchRule.fromJS(data["matchRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateOrEditWechatMenuInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWechatMenuInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId;
        if (this.menu && this.menu.constructor === Array) {
            data["menu"] = [];
            for (let item of this.menu)
                data["menu"].push(item.toJSON());
        }
        data["matchRule"] = this.matchRule ? this.matchRule.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrEditWechatMenuInput {
        const json = this.toJSON();
        let result = new CreateOrEditWechatMenuInput();
        result.init(json);
        return result;
    }
}

/** 创建或编辑菜单 */
export interface ICreateOrEditWechatMenuInput {
    /** 应用key */
    appId: string | undefined;
    /** 菜单数据结构 */
    menu: MenuFull_RootButton[] | undefined;
    /** 匹配规则，当菜单是个性化菜单的时候输入 */
    matchRule: MenuMatchRule | undefined;
}

export class MenuFull_RootButton implements IMenuFull_RootButton {
    type: string | undefined;
    key: string | undefined;
    name: string | undefined;
    url: string | undefined;
    news_info: NewsInfo | undefined;
    appid: string | undefined;
    pagepath: string | undefined;
    media_id: string | undefined;
    sub_button: MenuFull_RootButton[] | undefined;

    constructor(data?: IMenuFull_RootButton) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.key = data["key"];
            this.name = data["name"];
            this.url = data["url"];
            this.news_info = data["news_info"] ? NewsInfo.fromJS(data["news_info"]) : <any>undefined;
            this.appid = data["appid"];
            this.pagepath = data["pagepath"];
            this.media_id = data["media_id"];
            if (data["sub_button"] && data["sub_button"].constructor === Array) {
                this.sub_button = [] as any;
                for (let item of data["sub_button"])
                    this.sub_button.push(MenuFull_RootButton.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MenuFull_RootButton {
        data = typeof data === 'object' ? data : {};
        let result = new MenuFull_RootButton();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["key"] = this.key;
        data["name"] = this.name;
        data["url"] = this.url;
        data["news_info"] = this.news_info ? this.news_info.toJSON() : <any>undefined;
        data["appid"] = this.appid;
        data["pagepath"] = this.pagepath;
        data["media_id"] = this.media_id;
        if (this.sub_button && this.sub_button.constructor === Array) {
            data["sub_button"] = [];
            for (let item of this.sub_button)
                data["sub_button"].push(item.toJSON());
        }
        return data; 
    }

    clone(): MenuFull_RootButton {
        const json = this.toJSON();
        let result = new MenuFull_RootButton();
        result.init(json);
        return result;
    }
}

export interface IMenuFull_RootButton {
    type: string | undefined;
    key: string | undefined;
    name: string | undefined;
    url: string | undefined;
    news_info: NewsInfo | undefined;
    appid: string | undefined;
    pagepath: string | undefined;
    media_id: string | undefined;
    sub_button: MenuFull_RootButton[] | undefined;
}

export class MenuMatchRule implements IMenuMatchRule {
    tag_id: string | undefined;
    group_id: string | undefined;
    sex: string | undefined;
    country: string | undefined;
    province: string | undefined;
    city: string | undefined;
    client_platform_type: string | undefined;
    language: string | undefined;

    constructor(data?: IMenuMatchRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tag_id = data["tag_id"];
            this.group_id = data["group_id"];
            this.sex = data["sex"];
            this.country = data["country"];
            this.province = data["province"];
            this.city = data["city"];
            this.client_platform_type = data["client_platform_type"];
            this.language = data["language"];
        }
    }

    static fromJS(data: any): MenuMatchRule {
        data = typeof data === 'object' ? data : {};
        let result = new MenuMatchRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tag_id"] = this.tag_id;
        data["group_id"] = this.group_id;
        data["sex"] = this.sex;
        data["country"] = this.country;
        data["province"] = this.province;
        data["city"] = this.city;
        data["client_platform_type"] = this.client_platform_type;
        data["language"] = this.language;
        return data; 
    }

    clone(): MenuMatchRule {
        const json = this.toJSON();
        let result = new MenuMatchRule();
        result.init(json);
        return result;
    }
}

export interface IMenuMatchRule {
    tag_id: string | undefined;
    group_id: string | undefined;
    sex: string | undefined;
    country: string | undefined;
    province: string | undefined;
    city: string | undefined;
    client_platform_type: string | undefined;
    language: string | undefined;
}

export class NewsInfo implements INewsInfo {
    list: NewsInfoItem[] | undefined;

    constructor(data?: INewsInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["list"] && data["list"].constructor === Array) {
                this.list = [] as any;
                for (let item of data["list"])
                    this.list.push(NewsInfoItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NewsInfo {
        data = typeof data === 'object' ? data : {};
        let result = new NewsInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.list && this.list.constructor === Array) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        return data; 
    }

    clone(): NewsInfo {
        const json = this.toJSON();
        let result = new NewsInfo();
        result.init(json);
        return result;
    }
}

export interface INewsInfo {
    list: NewsInfoItem[] | undefined;
}

export class NewsInfoItem implements INewsInfoItem {
    title: string | undefined;
    author: string | undefined;
    digest: string | undefined;
    show_cover: number | undefined;
    cover_url: string | undefined;
    content_url: string | undefined;
    source_url: string | undefined;

    constructor(data?: INewsInfoItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.author = data["author"];
            this.digest = data["digest"];
            this.show_cover = data["show_cover"];
            this.cover_url = data["cover_url"];
            this.content_url = data["content_url"];
            this.source_url = data["source_url"];
        }
    }

    static fromJS(data: any): NewsInfoItem {
        data = typeof data === 'object' ? data : {};
        let result = new NewsInfoItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["author"] = this.author;
        data["digest"] = this.digest;
        data["show_cover"] = this.show_cover;
        data["cover_url"] = this.cover_url;
        data["content_url"] = this.content_url;
        data["source_url"] = this.source_url;
        return data; 
    }

    clone(): NewsInfoItem {
        const json = this.toJSON();
        let result = new NewsInfoItem();
        result.init(json);
        return result;
    }
}

export interface INewsInfoItem {
    title: string | undefined;
    author: string | undefined;
    digest: string | undefined;
    show_cover: number | undefined;
    cover_url: string | undefined;
    content_url: string | undefined;
    source_url: string | undefined;
}

export class GetWechatMenuForEditOutput implements IGetWechatMenuForEditOutput {
    /** 默认菜单
(单独对象,数据结构参照 MenuFull_ButtonGroup) */
    menu: any | undefined;
    /** 有个性化菜单时显示。最新的在最前。
(集合 数据结构参照 MenuFull_ConditionalButtonGroup) */
    conditionalmenu: any | undefined;
    /** 菜单类型 */
    menuTypeList: KeyValuePairOfStringAndString[] | undefined;

    constructor(data?: IGetWechatMenuForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.menu = data["menu"];
            this.conditionalmenu = data["conditionalmenu"];
            if (data["menuTypeList"] && data["menuTypeList"].constructor === Array) {
                this.menuTypeList = [] as any;
                for (let item of data["menuTypeList"])
                    this.menuTypeList.push(KeyValuePairOfStringAndString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetWechatMenuForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWechatMenuForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menu"] = this.menu;
        data["conditionalmenu"] = this.conditionalmenu;
        if (this.menuTypeList && this.menuTypeList.constructor === Array) {
            data["menuTypeList"] = [];
            for (let item of this.menuTypeList)
                data["menuTypeList"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetWechatMenuForEditOutput {
        const json = this.toJSON();
        let result = new GetWechatMenuForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetWechatMenuForEditOutput {
    /** 默认菜单
(单独对象,数据结构参照 MenuFull_ButtonGroup) */
    menu: any | undefined;
    /** 有个性化菜单时显示。最新的在最前。
(集合 数据结构参照 MenuFull_ConditionalButtonGroup) */
    conditionalmenu: any | undefined;
    /** 菜单类型 */
    menuTypeList: KeyValuePairOfStringAndString[] | undefined;
}

export class CreateOrUpdateWharfInput implements ICreateOrUpdateWharfInput {
    wharf: WharfEditDto;

    constructor(data?: ICreateOrUpdateWharfInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.wharf = new WharfEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.wharf = data["wharf"] ? WharfEditDto.fromJS(data["wharf"]) : new WharfEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateWharfInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateWharfInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wharf"] = this.wharf ? this.wharf.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateWharfInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateWharfInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateWharfInput {
    wharf: WharfEditDto;
}

export class WharfEditDto implements IWharfEditDto {
    /** Id */
    id: string | undefined;
    /** WharfName */
    wharfName: string;
    /** WharfNo */
    wharfNo: string;
    /** WharfLeader */
    wharfLeader: string;
    /** LeaderMobile */
    leaderMobile: number;
    /** WharfPosition */
    wharfPosition: string;
    /** IsEenable */
    isEenable: boolean;

    constructor(data?: IWharfEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.wharfName = data["wharfName"];
            this.wharfNo = data["wharfNo"];
            this.wharfLeader = data["wharfLeader"];
            this.leaderMobile = data["leaderMobile"];
            this.wharfPosition = data["wharfPosition"];
            this.isEenable = data["isEenable"];
        }
    }

    static fromJS(data: any): WharfEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new WharfEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["wharfName"] = this.wharfName;
        data["wharfNo"] = this.wharfNo;
        data["wharfLeader"] = this.wharfLeader;
        data["leaderMobile"] = this.leaderMobile;
        data["wharfPosition"] = this.wharfPosition;
        data["isEenable"] = this.isEenable;
        return data; 
    }

    clone(): WharfEditDto {
        const json = this.toJSON();
        let result = new WharfEditDto();
        result.init(json);
        return result;
    }
}

export interface IWharfEditDto {
    /** Id */
    id: string | undefined;
    /** WharfName */
    wharfName: string;
    /** WharfNo */
    wharfNo: string;
    /** WharfLeader */
    wharfLeader: string;
    /** LeaderMobile */
    leaderMobile: number;
    /** WharfPosition */
    wharfPosition: string;
    /** IsEenable */
    isEenable: boolean;
}

export class WharfListDto implements IWharfListDto {
    /** BranchId */
    branchId: string | undefined;
    /** WharfName */
    wharfName: string;
    /** WharfNo */
    wharfNo: string;
    /** WharfLeader */
    wharfLeader: string;
    /** LeaderMobile */
    leaderMobile: number;
    /** WharfPosition */
    wharfPosition: string;
    /** IsEenable */
    isEenable: boolean;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IWharfListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.wharfName = data["wharfName"];
            this.wharfNo = data["wharfNo"];
            this.wharfLeader = data["wharfLeader"];
            this.leaderMobile = data["leaderMobile"];
            this.wharfPosition = data["wharfPosition"];
            this.isEenable = data["isEenable"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WharfListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WharfListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["wharfName"] = this.wharfName;
        data["wharfNo"] = this.wharfNo;
        data["wharfLeader"] = this.wharfLeader;
        data["leaderMobile"] = this.leaderMobile;
        data["wharfPosition"] = this.wharfPosition;
        data["isEenable"] = this.isEenable;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): WharfListDto {
        const json = this.toJSON();
        let result = new WharfListDto();
        result.init(json);
        return result;
    }
}

export interface IWharfListDto {
    /** BranchId */
    branchId: string | undefined;
    /** WharfName */
    wharfName: string;
    /** WharfNo */
    wharfNo: string;
    /** WharfLeader */
    wharfLeader: string;
    /** LeaderMobile */
    leaderMobile: number;
    /** WharfPosition */
    wharfPosition: string;
    /** IsEenable */
    isEenable: boolean;
    creatorUser: User | undefined;
    branch: Branch | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetWharfForEditOutput implements IGetWharfForEditOutput {
    wharf: WharfEditDto | undefined;

    constructor(data?: IGetWharfForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wharf = data["wharf"] ? WharfEditDto.fromJS(data["wharf"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetWharfForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWharfForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wharf"] = this.wharf ? this.wharf.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetWharfForEditOutput {
        const json = this.toJSON();
        let result = new GetWharfForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetWharfForEditOutput {
    wharf: WharfEditDto | undefined;
}

export class GetWharfsInput implements IGetWharfsInput {
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetWharfsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetWharfsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWharfsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetWharfsInput {
        const json = this.toJSON();
        let result = new GetWharfsInput();
        result.init(json);
        return result;
    }
}

export interface IGetWharfsInput {
    queryData: QueryData[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfWharfListDto implements IPagedResultDtoOfWharfListDto {
    totalCount: number | undefined;
    items: WharfListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWharfListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(WharfListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWharfListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWharfListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfWharfListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfWharfListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfWharfListDto {
    totalCount: number | undefined;
    items: WharfListDto[] | undefined;
}

export class BoatRunningStatusDto implements IBoatRunningStatusDto {
    boat: Boat | undefined;
    schedule: Schedule | undefined;
    saled: number | undefined;
    rate: string | undefined;

    constructor(data?: IBoatRunningStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.boat = data["boat"] ? Boat.fromJS(data["boat"]) : <any>undefined;
            this.schedule = data["schedule"] ? Schedule.fromJS(data["schedule"]) : <any>undefined;
            this.saled = data["saled"];
            this.rate = data["rate"];
        }
    }

    static fromJS(data: any): BoatRunningStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new BoatRunningStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["boat"] = this.boat ? this.boat.toJSON() : <any>undefined;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["saled"] = this.saled;
        data["rate"] = this.rate;
        return data; 
    }

    clone(): BoatRunningStatusDto {
        const json = this.toJSON();
        let result = new BoatRunningStatusDto();
        result.init(json);
        return result;
    }
}

export interface IBoatRunningStatusDto {
    boat: Boat | undefined;
    schedule: Schedule | undefined;
    saled: number | undefined;
    rate: string | undefined;
}

export enum AnalyticType {
    Daily = <any>"Daily", 
    Weekly = <any>"Weekly", 
    Monthly = <any>"Monthly", 
    Yearly = <any>"Yearly", 
}

/** 首页营收状况Dto */
export class RevenueAnalyticsResultDto implements IRevenueAnalyticsResultDto {
    /** 游客统计 */
    customerAnal: CustomerAnalytics | undefined;
    /** 收入统计 */
    financeAnal: FinanceAnalytics | undefined;

    constructor(data?: IRevenueAnalyticsResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerAnal = data["customerAnal"] ? CustomerAnalytics.fromJS(data["customerAnal"]) : <any>undefined;
            this.financeAnal = data["financeAnal"] ? FinanceAnalytics.fromJS(data["financeAnal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RevenueAnalyticsResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RevenueAnalyticsResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerAnal"] = this.customerAnal ? this.customerAnal.toJSON() : <any>undefined;
        data["financeAnal"] = this.financeAnal ? this.financeAnal.toJSON() : <any>undefined;
        return data; 
    }

    clone(): RevenueAnalyticsResultDto {
        const json = this.toJSON();
        let result = new RevenueAnalyticsResultDto();
        result.init(json);
        return result;
    }
}

/** 首页营收状况Dto */
export interface IRevenueAnalyticsResultDto {
    /** 游客统计 */
    customerAnal: CustomerAnalytics | undefined;
    /** 收入统计 */
    financeAnal: FinanceAnalytics | undefined;
}

export class CustomerAnalytics implements ICustomerAnalytics {
    timeSpan: string[] | undefined;
    count: number[] | undefined;
    totalCount: number | undefined;

    constructor(data?: ICustomerAnalytics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["timeSpan"] && data["timeSpan"].constructor === Array) {
                this.timeSpan = [] as any;
                for (let item of data["timeSpan"])
                    this.timeSpan.push(item);
            }
            if (data["count"] && data["count"].constructor === Array) {
                this.count = [] as any;
                for (let item of data["count"])
                    this.count.push(item);
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): CustomerAnalytics {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerAnalytics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.timeSpan && this.timeSpan.constructor === Array) {
            data["timeSpan"] = [];
            for (let item of this.timeSpan)
                data["timeSpan"].push(item);
        }
        if (this.count && this.count.constructor === Array) {
            data["count"] = [];
            for (let item of this.count)
                data["count"].push(item);
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CustomerAnalytics {
        const json = this.toJSON();
        let result = new CustomerAnalytics();
        result.init(json);
        return result;
    }
}

export interface ICustomerAnalytics {
    timeSpan: string[] | undefined;
    count: number[] | undefined;
    totalCount: number | undefined;
}

export class FinanceAnalytics implements IFinanceAnalytics {
    timeSpan: string[] | undefined;
    amount: number[] | undefined;
    totalAmount: number | undefined;

    constructor(data?: IFinanceAnalytics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["timeSpan"] && data["timeSpan"].constructor === Array) {
                this.timeSpan = [] as any;
                for (let item of data["timeSpan"])
                    this.timeSpan.push(item);
            }
            if (data["amount"] && data["amount"].constructor === Array) {
                this.amount = [] as any;
                for (let item of data["amount"])
                    this.amount.push(item);
            }
            this.totalAmount = data["totalAmount"];
        }
    }

    static fromJS(data: any): FinanceAnalytics {
        data = typeof data === 'object' ? data : {};
        let result = new FinanceAnalytics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.timeSpan && this.timeSpan.constructor === Array) {
            data["timeSpan"] = [];
            for (let item of this.timeSpan)
                data["timeSpan"].push(item);
        }
        if (this.amount && this.amount.constructor === Array) {
            data["amount"] = [];
            for (let item of this.amount)
                data["amount"].push(item);
        }
        data["totalAmount"] = this.totalAmount;
        return data; 
    }

    clone(): FinanceAnalytics {
        const json = this.toJSON();
        let result = new FinanceAnalytics();
        result.init(json);
        return result;
    }
}

export interface IFinanceAnalytics {
    timeSpan: string[] | undefined;
    amount: number[] | undefined;
    totalAmount: number | undefined;
}

export class ScheduleAnalResultDto implements IScheduleAnalResultDto {
    schedule: Schedule | undefined;
    route: Route | undefined;
    boat: Boat | undefined;

    constructor(data?: IScheduleAnalResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.schedule = data["schedule"] ? Schedule.fromJS(data["schedule"]) : <any>undefined;
            this.route = data["route"] ? Route.fromJS(data["route"]) : <any>undefined;
            this.boat = data["boat"] ? Boat.fromJS(data["boat"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ScheduleAnalResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleAnalResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["route"] = this.route ? this.route.toJSON() : <any>undefined;
        data["boat"] = this.boat ? this.boat.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ScheduleAnalResultDto {
        const json = this.toJSON();
        let result = new ScheduleAnalResultDto();
        result.init(json);
        return result;
    }
}

export interface IScheduleAnalResultDto {
    schedule: Schedule | undefined;
    route: Route | undefined;
    boat: Boat | undefined;
}

export class TicketRatesResult implements ITicketRatesResult {
    ticketTypeId: string | undefined;
    ticketTypeName: string | undefined;
    count: number | undefined;

    constructor(data?: ITicketRatesResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketTypeId = data["ticketTypeId"];
            this.ticketTypeName = data["ticketTypeName"];
            this.count = data["count"];
        }
    }

    static fromJS(data: any): TicketRatesResult {
        data = typeof data === 'object' ? data : {};
        let result = new TicketRatesResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketTypeId"] = this.ticketTypeId;
        data["ticketTypeName"] = this.ticketTypeName;
        data["count"] = this.count;
        return data; 
    }

    clone(): TicketRatesResult {
        const json = this.toJSON();
        let result = new TicketRatesResult();
        result.init(json);
        return result;
    }
}

export interface ITicketRatesResult {
    ticketTypeId: string | undefined;
    ticketTypeName: string | undefined;
    count: number | undefined;
}

export class StatsPagedResultDtoOfGetOrderSourceResultDto implements IStatsPagedResultDtoOfGetOrderSourceResultDto {
    total: GetOrderSourceResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: GetOrderSourceResultDto[] | undefined;

    constructor(data?: IStatsPagedResultDtoOfGetOrderSourceResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"] ? GetOrderSourceResultDto.fromJS(data["total"]) : <any>undefined;
            if (data["filters"]) {
                this.filters = {} as any;
                for (let key in data["filters"]) {
                    if (data["filters"].hasOwnProperty(key))
                        this.filters[key] = data["filters"][key] !== undefined ? data["filters"][key] : [];
                }
            }
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(GetOrderSourceResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatsPagedResultDtoOfGetOrderSourceResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatsPagedResultDtoOfGetOrderSourceResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total ? this.total.toJSON() : <any>undefined;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    data["filters"][key] = this.filters[key];
            }
        }
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StatsPagedResultDtoOfGetOrderSourceResultDto {
        const json = this.toJSON();
        let result = new StatsPagedResultDtoOfGetOrderSourceResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatsPagedResultDtoOfGetOrderSourceResultDto {
    total: GetOrderSourceResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: GetOrderSourceResultDto[] | undefined;
}

export class GetOrderSourceResultDto implements IGetOrderSourceResultDto {
    /** 订单来源ID */
    source: Source | undefined;
    /** 售票数量 */
    saleCount: number | undefined;
    /** 退票数量 */
    refundCount: number | undefined;
    /** 数量小计 */
    totalCount: number | undefined;
    /** 售票金额 */
    saleAmount: number | undefined;
    /** 退票金额 */
    refundAmount: number | undefined;
    /** 金额小计 */
    totalAmount: number | undefined;

    constructor(data?: IGetOrderSourceResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.source = data["source"] ? Source.fromJS(data["source"]) : <any>undefined;
            this.saleCount = data["saleCount"];
            this.refundCount = data["refundCount"];
            this.totalCount = data["totalCount"];
            this.saleAmount = data["saleAmount"];
            this.refundAmount = data["refundAmount"];
            this.totalAmount = data["totalAmount"];
        }
    }

    static fromJS(data: any): GetOrderSourceResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrderSourceResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["saleCount"] = this.saleCount;
        data["refundCount"] = this.refundCount;
        data["totalCount"] = this.totalCount;
        data["saleAmount"] = this.saleAmount;
        data["refundAmount"] = this.refundAmount;
        data["totalAmount"] = this.totalAmount;
        return data; 
    }

    clone(): GetOrderSourceResultDto {
        const json = this.toJSON();
        let result = new GetOrderSourceResultDto();
        result.init(json);
        return result;
    }
}

export interface IGetOrderSourceResultDto {
    /** 订单来源ID */
    source: Source | undefined;
    /** 售票数量 */
    saleCount: number | undefined;
    /** 退票数量 */
    refundCount: number | undefined;
    /** 数量小计 */
    totalCount: number | undefined;
    /** 售票金额 */
    saleAmount: number | undefined;
    /** 退票金额 */
    refundAmount: number | undefined;
    /** 金额小计 */
    totalAmount: number | undefined;
}

export class StatsPagedResultDtoOfGetPayMethodResultDto implements IStatsPagedResultDtoOfGetPayMethodResultDto {
    total: GetPayMethodResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: GetPayMethodResultDto[] | undefined;

    constructor(data?: IStatsPagedResultDtoOfGetPayMethodResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"] ? GetPayMethodResultDto.fromJS(data["total"]) : <any>undefined;
            if (data["filters"]) {
                this.filters = {} as any;
                for (let key in data["filters"]) {
                    if (data["filters"].hasOwnProperty(key))
                        this.filters[key] = data["filters"][key] !== undefined ? data["filters"][key] : [];
                }
            }
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(GetPayMethodResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatsPagedResultDtoOfGetPayMethodResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatsPagedResultDtoOfGetPayMethodResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total ? this.total.toJSON() : <any>undefined;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    data["filters"][key] = this.filters[key];
            }
        }
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StatsPagedResultDtoOfGetPayMethodResultDto {
        const json = this.toJSON();
        let result = new StatsPagedResultDtoOfGetPayMethodResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatsPagedResultDtoOfGetPayMethodResultDto {
    total: GetPayMethodResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: GetPayMethodResultDto[] | undefined;
}

export class GetPayMethodResultDto implements IGetPayMethodResultDto {
    /** 支付方式 */
    payMethod: PayMethod | undefined;
    /** 售票数量 */
    saleCount: number | undefined;
    /** 退票数量 */
    refundCount: number | undefined;
    /** 数量小计 */
    totalCount: number | undefined;
    /** 金额 */
    saleAmount: number | undefined;
    /** 退票金额 */
    refundAmount: number | undefined;
    /** 金额小计 */
    totalAmount: number | undefined;

    constructor(data?: IGetPayMethodResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.payMethod = data["payMethod"] ? PayMethod.fromJS(data["payMethod"]) : <any>undefined;
            this.saleCount = data["saleCount"];
            this.refundCount = data["refundCount"];
            this.totalCount = data["totalCount"];
            this.saleAmount = data["saleAmount"];
            this.refundAmount = data["refundAmount"];
            this.totalAmount = data["totalAmount"];
        }
    }

    static fromJS(data: any): GetPayMethodResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPayMethodResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        data["saleCount"] = this.saleCount;
        data["refundCount"] = this.refundCount;
        data["totalCount"] = this.totalCount;
        data["saleAmount"] = this.saleAmount;
        data["refundAmount"] = this.refundAmount;
        data["totalAmount"] = this.totalAmount;
        return data; 
    }

    clone(): GetPayMethodResultDto {
        const json = this.toJSON();
        let result = new GetPayMethodResultDto();
        result.init(json);
        return result;
    }
}

export interface IGetPayMethodResultDto {
    /** 支付方式 */
    payMethod: PayMethod | undefined;
    /** 售票数量 */
    saleCount: number | undefined;
    /** 退票数量 */
    refundCount: number | undefined;
    /** 数量小计 */
    totalCount: number | undefined;
    /** 金额 */
    saleAmount: number | undefined;
    /** 退票金额 */
    refundAmount: number | undefined;
    /** 金额小计 */
    totalAmount: number | undefined;
}

export class StatsPagedResultDtoOfScheduleResultDto implements IStatsPagedResultDtoOfScheduleResultDto {
    total: ScheduleResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: ScheduleResultDto[] | undefined;

    constructor(data?: IStatsPagedResultDtoOfScheduleResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"] ? ScheduleResultDto.fromJS(data["total"]) : <any>undefined;
            if (data["filters"]) {
                this.filters = {} as any;
                for (let key in data["filters"]) {
                    if (data["filters"].hasOwnProperty(key))
                        this.filters[key] = data["filters"][key] !== undefined ? data["filters"][key] : [];
                }
            }
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ScheduleResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatsPagedResultDtoOfScheduleResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatsPagedResultDtoOfScheduleResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total ? this.total.toJSON() : <any>undefined;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    data["filters"][key] = this.filters[key];
            }
        }
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StatsPagedResultDtoOfScheduleResultDto {
        const json = this.toJSON();
        let result = new StatsPagedResultDtoOfScheduleResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatsPagedResultDtoOfScheduleResultDto {
    total: ScheduleResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: ScheduleResultDto[] | undefined;
}

/** 航线统计Dto */
export class ScheduleResultDto implements IScheduleResultDto {
    /** 航线 */
    route: Route | undefined;
    /** 航班数量 */
    boatCount: number | undefined;
    /** 游船航次 */
    boats: BoatInfo[] | undefined;
    /** 售票数量 */
    saleCount: number | undefined;
    /** 退票数量 */
    refundCount: number | undefined;
    /** 数量小计 */
    totalCount: number | undefined;
    /** 销售金额 */
    saleAmount: number | undefined;
    /** 退票金额 */
    refundAmount: number | undefined;
    /** 金额小计 */
    totalAmount: number | undefined;

    constructor(data?: IScheduleResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.route = data["route"] ? Route.fromJS(data["route"]) : <any>undefined;
            this.boatCount = data["boatCount"];
            if (data["boats"] && data["boats"].constructor === Array) {
                this.boats = [] as any;
                for (let item of data["boats"])
                    this.boats.push(BoatInfo.fromJS(item));
            }
            this.saleCount = data["saleCount"];
            this.refundCount = data["refundCount"];
            this.totalCount = data["totalCount"];
            this.saleAmount = data["saleAmount"];
            this.refundAmount = data["refundAmount"];
            this.totalAmount = data["totalAmount"];
        }
    }

    static fromJS(data: any): ScheduleResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["route"] = this.route ? this.route.toJSON() : <any>undefined;
        data["boatCount"] = this.boatCount;
        if (this.boats && this.boats.constructor === Array) {
            data["boats"] = [];
            for (let item of this.boats)
                data["boats"].push(item.toJSON());
        }
        data["saleCount"] = this.saleCount;
        data["refundCount"] = this.refundCount;
        data["totalCount"] = this.totalCount;
        data["saleAmount"] = this.saleAmount;
        data["refundAmount"] = this.refundAmount;
        data["totalAmount"] = this.totalAmount;
        return data; 
    }

    clone(): ScheduleResultDto {
        const json = this.toJSON();
        let result = new ScheduleResultDto();
        result.init(json);
        return result;
    }
}

/** 航线统计Dto */
export interface IScheduleResultDto {
    /** 航线 */
    route: Route | undefined;
    /** 航班数量 */
    boatCount: number | undefined;
    /** 游船航次 */
    boats: BoatInfo[] | undefined;
    /** 售票数量 */
    saleCount: number | undefined;
    /** 退票数量 */
    refundCount: number | undefined;
    /** 数量小计 */
    totalCount: number | undefined;
    /** 销售金额 */
    saleAmount: number | undefined;
    /** 退票金额 */
    refundAmount: number | undefined;
    /** 金额小计 */
    totalAmount: number | undefined;
}

/** 游船航次信息 */
export class BoatInfo implements IBoatInfo {
    /** 游船名称 */
    boatName: string | undefined;
    /** 航次 */
    count: number | undefined;

    constructor(data?: IBoatInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.boatName = data["boatName"];
            this.count = data["count"];
        }
    }

    static fromJS(data: any): BoatInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BoatInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["boatName"] = this.boatName;
        data["count"] = this.count;
        return data; 
    }

    clone(): BoatInfo {
        const json = this.toJSON();
        let result = new BoatInfo();
        result.init(json);
        return result;
    }
}

/** 游船航次信息 */
export interface IBoatInfo {
    /** 游船名称 */
    boatName: string | undefined;
    /** 航次 */
    count: number | undefined;
}

export class StatsPagedResultDtoOfScheduleDetailResultDto implements IStatsPagedResultDtoOfScheduleDetailResultDto {
    total: ScheduleDetailResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: ScheduleDetailResultDto[] | undefined;

    constructor(data?: IStatsPagedResultDtoOfScheduleDetailResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"] ? ScheduleDetailResultDto.fromJS(data["total"]) : <any>undefined;
            if (data["filters"]) {
                this.filters = {} as any;
                for (let key in data["filters"]) {
                    if (data["filters"].hasOwnProperty(key))
                        this.filters[key] = data["filters"][key] !== undefined ? data["filters"][key] : [];
                }
            }
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ScheduleDetailResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatsPagedResultDtoOfScheduleDetailResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatsPagedResultDtoOfScheduleDetailResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total ? this.total.toJSON() : <any>undefined;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    data["filters"][key] = this.filters[key];
            }
        }
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StatsPagedResultDtoOfScheduleDetailResultDto {
        const json = this.toJSON();
        let result = new StatsPagedResultDtoOfScheduleDetailResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatsPagedResultDtoOfScheduleDetailResultDto {
    total: ScheduleDetailResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: ScheduleDetailResultDto[] | undefined;
}

/** 航线统计详情 */
export class ScheduleDetailResultDto implements IScheduleDetailResultDto {
    scheduleId: string | undefined;
    scheduleCode: string | undefined;
    saleDate: moment.Moment | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    seatQuantity: number | undefined;
    surplusQuantity: number | undefined;
    scheduleStatus: ScheduleStatusEnum | undefined;
    /** 审核状态 */
    auditStatus: AuditStatusEnum | undefined;
    /** 检票开始时间 */
    checkStartTime: moment.Moment | undefined;
    /** 检票结束时间 */
    checkEndTime: moment.Moment | undefined;
    /** 预留数 */
    reserveQuantity: number | undefined;
    route: Route | undefined;
    boat: Boat | undefined;
    tickets: Ticket[] | undefined;
    saledCount: number | undefined;

    constructor(data?: IScheduleDetailResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scheduleId = data["scheduleId"];
            this.scheduleCode = data["scheduleCode"];
            this.saleDate = data["saleDate"] ? moment(data["saleDate"].toString()) : <any>undefined;
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.seatQuantity = data["seatQuantity"];
            this.surplusQuantity = data["surplusQuantity"];
            this.scheduleStatus = data["scheduleStatus"];
            this.auditStatus = data["auditStatus"];
            this.checkStartTime = data["checkStartTime"] ? moment(data["checkStartTime"].toString()) : <any>undefined;
            this.checkEndTime = data["checkEndTime"] ? moment(data["checkEndTime"].toString()) : <any>undefined;
            this.reserveQuantity = data["reserveQuantity"];
            this.route = data["route"] ? Route.fromJS(data["route"]) : <any>undefined;
            this.boat = data["boat"] ? Boat.fromJS(data["boat"]) : <any>undefined;
            if (data["tickets"] && data["tickets"].constructor === Array) {
                this.tickets = [] as any;
                for (let item of data["tickets"])
                    this.tickets.push(Ticket.fromJS(item));
            }
            this.saledCount = data["saledCount"];
        }
    }

    static fromJS(data: any): ScheduleDetailResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleDetailResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheduleId"] = this.scheduleId;
        data["scheduleCode"] = this.scheduleCode;
        data["saleDate"] = this.saleDate ? this.saleDate.toISOString() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["seatQuantity"] = this.seatQuantity;
        data["surplusQuantity"] = this.surplusQuantity;
        data["scheduleStatus"] = this.scheduleStatus;
        data["auditStatus"] = this.auditStatus;
        data["checkStartTime"] = this.checkStartTime ? this.checkStartTime.toISOString() : <any>undefined;
        data["checkEndTime"] = this.checkEndTime ? this.checkEndTime.toISOString() : <any>undefined;
        data["reserveQuantity"] = this.reserveQuantity;
        data["route"] = this.route ? this.route.toJSON() : <any>undefined;
        data["boat"] = this.boat ? this.boat.toJSON() : <any>undefined;
        if (this.tickets && this.tickets.constructor === Array) {
            data["tickets"] = [];
            for (let item of this.tickets)
                data["tickets"].push(item.toJSON());
        }
        data["saledCount"] = this.saledCount;
        return data; 
    }

    clone(): ScheduleDetailResultDto {
        const json = this.toJSON();
        let result = new ScheduleDetailResultDto();
        result.init(json);
        return result;
    }
}

/** 航线统计详情 */
export interface IScheduleDetailResultDto {
    scheduleId: string | undefined;
    scheduleCode: string | undefined;
    saleDate: moment.Moment | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    seatQuantity: number | undefined;
    surplusQuantity: number | undefined;
    scheduleStatus: ScheduleStatusEnum | undefined;
    /** 审核状态 */
    auditStatus: AuditStatusEnum | undefined;
    /** 检票开始时间 */
    checkStartTime: moment.Moment | undefined;
    /** 检票结束时间 */
    checkEndTime: moment.Moment | undefined;
    /** 预留数 */
    reserveQuantity: number | undefined;
    route: Route | undefined;
    boat: Boat | undefined;
    tickets: Ticket[] | undefined;
    saledCount: number | undefined;
}

export class StatsPagedResultDtoOfScheduleCheckResultDto implements IStatsPagedResultDtoOfScheduleCheckResultDto {
    total: ScheduleCheckResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: ScheduleCheckResultDto[] | undefined;

    constructor(data?: IStatsPagedResultDtoOfScheduleCheckResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"] ? ScheduleCheckResultDto.fromJS(data["total"]) : <any>undefined;
            if (data["filters"]) {
                this.filters = {} as any;
                for (let key in data["filters"]) {
                    if (data["filters"].hasOwnProperty(key))
                        this.filters[key] = data["filters"][key] !== undefined ? data["filters"][key] : [];
                }
            }
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ScheduleCheckResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatsPagedResultDtoOfScheduleCheckResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatsPagedResultDtoOfScheduleCheckResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total ? this.total.toJSON() : <any>undefined;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    data["filters"][key] = this.filters[key];
            }
        }
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StatsPagedResultDtoOfScheduleCheckResultDto {
        const json = this.toJSON();
        let result = new StatsPagedResultDtoOfScheduleCheckResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatsPagedResultDtoOfScheduleCheckResultDto {
    total: ScheduleCheckResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: ScheduleCheckResultDto[] | undefined;
}

export class ScheduleCheckResultDto implements IScheduleCheckResultDto {
    schedule: Schedule | undefined;
    route: Route | undefined;
    boat: Boat | undefined;
    wharf: Wharf | undefined;
    totalQuantity: number | undefined;
    checkedQuantity: number | undefined;
    uncheckedQuantity: number | undefined;

    constructor(data?: IScheduleCheckResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.schedule = data["schedule"] ? Schedule.fromJS(data["schedule"]) : <any>undefined;
            this.route = data["route"] ? Route.fromJS(data["route"]) : <any>undefined;
            this.boat = data["boat"] ? Boat.fromJS(data["boat"]) : <any>undefined;
            this.wharf = data["wharf"] ? Wharf.fromJS(data["wharf"]) : <any>undefined;
            this.totalQuantity = data["totalQuantity"];
            this.checkedQuantity = data["checkedQuantity"];
            this.uncheckedQuantity = data["uncheckedQuantity"];
        }
    }

    static fromJS(data: any): ScheduleCheckResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleCheckResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["route"] = this.route ? this.route.toJSON() : <any>undefined;
        data["boat"] = this.boat ? this.boat.toJSON() : <any>undefined;
        data["wharf"] = this.wharf ? this.wharf.toJSON() : <any>undefined;
        data["totalQuantity"] = this.totalQuantity;
        data["checkedQuantity"] = this.checkedQuantity;
        data["uncheckedQuantity"] = this.uncheckedQuantity;
        return data; 
    }

    clone(): ScheduleCheckResultDto {
        const json = this.toJSON();
        let result = new ScheduleCheckResultDto();
        result.init(json);
        return result;
    }
}

export interface IScheduleCheckResultDto {
    schedule: Schedule | undefined;
    route: Route | undefined;
    boat: Boat | undefined;
    wharf: Wharf | undefined;
    totalQuantity: number | undefined;
    checkedQuantity: number | undefined;
    uncheckedQuantity: number | undefined;
}

export class PagedResultDtoOfScheduleCheckDetailDto implements IPagedResultDtoOfScheduleCheckDetailDto {
    totalCount: number | undefined;
    items: ScheduleCheckDetailDto[] | undefined;

    constructor(data?: IPagedResultDtoOfScheduleCheckDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ScheduleCheckDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfScheduleCheckDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfScheduleCheckDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfScheduleCheckDetailDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfScheduleCheckDetailDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfScheduleCheckDetailDto {
    totalCount: number | undefined;
    items: ScheduleCheckDetailDto[] | undefined;
}

export class ScheduleCheckDetailDto implements IScheduleCheckDetailDto {
    ticket: Ticket | undefined;
    schedule: Schedule | undefined;
    ticketDetail: TicketDetail | undefined;
    customer: Customer | undefined;

    constructor(data?: IScheduleCheckDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.schedule = data["schedule"] ? Schedule.fromJS(data["schedule"]) : <any>undefined;
            this.ticketDetail = data["ticketDetail"] ? TicketDetail.fromJS(data["ticketDetail"]) : <any>undefined;
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ScheduleCheckDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleCheckDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["ticketDetail"] = this.ticketDetail ? this.ticketDetail.toJSON() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ScheduleCheckDetailDto {
        const json = this.toJSON();
        let result = new ScheduleCheckDetailDto();
        result.init(json);
        return result;
    }
}

export interface IScheduleCheckDetailDto {
    ticket: Ticket | undefined;
    schedule: Schedule | undefined;
    ticketDetail: TicketDetail | undefined;
    customer: Customer | undefined;
}

export class StatsPagedResultDtoOfScheduleTicketResultDto implements IStatsPagedResultDtoOfScheduleTicketResultDto {
    total: ScheduleTicketResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: ScheduleTicketResultDto[] | undefined;

    constructor(data?: IStatsPagedResultDtoOfScheduleTicketResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"] ? ScheduleTicketResultDto.fromJS(data["total"]) : <any>undefined;
            if (data["filters"]) {
                this.filters = {} as any;
                for (let key in data["filters"]) {
                    if (data["filters"].hasOwnProperty(key))
                        this.filters[key] = data["filters"][key] !== undefined ? data["filters"][key] : [];
                }
            }
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ScheduleTicketResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatsPagedResultDtoOfScheduleTicketResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatsPagedResultDtoOfScheduleTicketResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total ? this.total.toJSON() : <any>undefined;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    data["filters"][key] = this.filters[key];
            }
        }
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StatsPagedResultDtoOfScheduleTicketResultDto {
        const json = this.toJSON();
        let result = new StatsPagedResultDtoOfScheduleTicketResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatsPagedResultDtoOfScheduleTicketResultDto {
    total: ScheduleTicketResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: ScheduleTicketResultDto[] | undefined;
}

export class ScheduleTicketResultDto implements IScheduleTicketResultDto {
    schedule: Schedule | undefined;
    route: Route | undefined;
    boat: Boat | undefined;
    saleCount: number | undefined;
    refundCount: number | undefined;
    totalCount: number | undefined;
    saleAmount: number | undefined;
    refundAmount: number | undefined;
    totalAmount: number | undefined;

    constructor(data?: IScheduleTicketResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.schedule = data["schedule"] ? Schedule.fromJS(data["schedule"]) : <any>undefined;
            this.route = data["route"] ? Route.fromJS(data["route"]) : <any>undefined;
            this.boat = data["boat"] ? Boat.fromJS(data["boat"]) : <any>undefined;
            this.saleCount = data["saleCount"];
            this.refundCount = data["refundCount"];
            this.totalCount = data["totalCount"];
            this.saleAmount = data["saleAmount"];
            this.refundAmount = data["refundAmount"];
            this.totalAmount = data["totalAmount"];
        }
    }

    static fromJS(data: any): ScheduleTicketResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleTicketResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["route"] = this.route ? this.route.toJSON() : <any>undefined;
        data["boat"] = this.boat ? this.boat.toJSON() : <any>undefined;
        data["saleCount"] = this.saleCount;
        data["refundCount"] = this.refundCount;
        data["totalCount"] = this.totalCount;
        data["saleAmount"] = this.saleAmount;
        data["refundAmount"] = this.refundAmount;
        data["totalAmount"] = this.totalAmount;
        return data; 
    }

    clone(): ScheduleTicketResultDto {
        const json = this.toJSON();
        let result = new ScheduleTicketResultDto();
        result.init(json);
        return result;
    }
}

export interface IScheduleTicketResultDto {
    schedule: Schedule | undefined;
    route: Route | undefined;
    boat: Boat | undefined;
    saleCount: number | undefined;
    refundCount: number | undefined;
    totalCount: number | undefined;
    saleAmount: number | undefined;
    refundAmount: number | undefined;
    totalAmount: number | undefined;
}

export class PagedResultDtoOfScheduleTicketDetailResultDto implements IPagedResultDtoOfScheduleTicketDetailResultDto {
    totalCount: number | undefined;
    items: ScheduleTicketDetailResultDto[] | undefined;

    constructor(data?: IPagedResultDtoOfScheduleTicketDetailResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ScheduleTicketDetailResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfScheduleTicketDetailResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfScheduleTicketDetailResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfScheduleTicketDetailResultDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfScheduleTicketDetailResultDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfScheduleTicketDetailResultDto {
    totalCount: number | undefined;
    items: ScheduleTicketDetailResultDto[] | undefined;
}

export class ScheduleTicketDetailResultDto implements IScheduleTicketDetailResultDto {
    ticket: Ticket | undefined;
    schedule: Schedule | undefined;
    ticketDetail: TicketDetail | undefined;
    customer: Customer | undefined;
    salePrice: number | undefined;

    constructor(data?: IScheduleTicketDetailResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.schedule = data["schedule"] ? Schedule.fromJS(data["schedule"]) : <any>undefined;
            this.ticketDetail = data["ticketDetail"] ? TicketDetail.fromJS(data["ticketDetail"]) : <any>undefined;
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.salePrice = data["salePrice"];
        }
    }

    static fromJS(data: any): ScheduleTicketDetailResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleTicketDetailResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
        data["ticketDetail"] = this.ticketDetail ? this.ticketDetail.toJSON() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["salePrice"] = this.salePrice;
        return data; 
    }

    clone(): ScheduleTicketDetailResultDto {
        const json = this.toJSON();
        let result = new ScheduleTicketDetailResultDto();
        result.init(json);
        return result;
    }
}

export interface IScheduleTicketDetailResultDto {
    ticket: Ticket | undefined;
    schedule: Schedule | undefined;
    ticketDetail: TicketDetail | undefined;
    customer: Customer | undefined;
    salePrice: number | undefined;
}

export class StatsPagedResultDtoOfSellerDailyResultDto implements IStatsPagedResultDtoOfSellerDailyResultDto {
    total: SellerDailyResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: SellerDailyResultDto[] | undefined;

    constructor(data?: IStatsPagedResultDtoOfSellerDailyResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"] ? SellerDailyResultDto.fromJS(data["total"]) : <any>undefined;
            if (data["filters"]) {
                this.filters = {} as any;
                for (let key in data["filters"]) {
                    if (data["filters"].hasOwnProperty(key))
                        this.filters[key] = data["filters"][key] !== undefined ? data["filters"][key] : [];
                }
            }
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(SellerDailyResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatsPagedResultDtoOfSellerDailyResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatsPagedResultDtoOfSellerDailyResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total ? this.total.toJSON() : <any>undefined;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    data["filters"][key] = this.filters[key];
            }
        }
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StatsPagedResultDtoOfSellerDailyResultDto {
        const json = this.toJSON();
        let result = new StatsPagedResultDtoOfSellerDailyResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatsPagedResultDtoOfSellerDailyResultDto {
    total: SellerDailyResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: SellerDailyResultDto[] | undefined;
}

export class SellerDailyResultDto implements ISellerDailyResultDto {
    /** 售票员 */
    saler: User | undefined;
    /** 现金售票金额 */
    cashSaleAmount: number | undefined;
    /** 微信售票金额 */
    weiChatSaleAmount: number | undefined;
    /** 刷卡售票金额 */
    cardSaleAmount: number | undefined;
    /** 支付宝售票金额 */
    zhiFuBaoSaleAmount: number | undefined;
    /** 现金退票金额 */
    cashRefundAmount: number | undefined;
    /** 微信退票金额 */
    weiChatRefundAmount: number | undefined;
    /** 刷卡退票金额 */
    cardRefundAmount: number | undefined;
    /** 支付宝退票金额 */
    zhiFuBaoRefundAmount: number | undefined;
    /** 售票数量 */
    saleCount: number | undefined;
    /** 退票数量 */
    refundCount: number | undefined;
    /** 数量小计 */
    totalCount: number | undefined;
    /** 销售金额小计 */
    totalSaleAmount: number | undefined;
    /** 退票金额小计 */
    totalRefundAmount: number | undefined;
    /** 应收总金额 */
    totalAmount: number | undefined;

    constructor(data?: ISellerDailyResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.saler = data["saler"] ? User.fromJS(data["saler"]) : <any>undefined;
            this.cashSaleAmount = data["cashSaleAmount"];
            this.weiChatSaleAmount = data["weiChatSaleAmount"];
            this.cardSaleAmount = data["cardSaleAmount"];
            this.zhiFuBaoSaleAmount = data["zhiFuBaoSaleAmount"];
            this.cashRefundAmount = data["cashRefundAmount"];
            this.weiChatRefundAmount = data["weiChatRefundAmount"];
            this.cardRefundAmount = data["cardRefundAmount"];
            this.zhiFuBaoRefundAmount = data["zhiFuBaoRefundAmount"];
            this.saleCount = data["saleCount"];
            this.refundCount = data["refundCount"];
            this.totalCount = data["totalCount"];
            this.totalSaleAmount = data["totalSaleAmount"];
            this.totalRefundAmount = data["totalRefundAmount"];
            this.totalAmount = data["totalAmount"];
        }
    }

    static fromJS(data: any): SellerDailyResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SellerDailyResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["saler"] = this.saler ? this.saler.toJSON() : <any>undefined;
        data["cashSaleAmount"] = this.cashSaleAmount;
        data["weiChatSaleAmount"] = this.weiChatSaleAmount;
        data["cardSaleAmount"] = this.cardSaleAmount;
        data["zhiFuBaoSaleAmount"] = this.zhiFuBaoSaleAmount;
        data["cashRefundAmount"] = this.cashRefundAmount;
        data["weiChatRefundAmount"] = this.weiChatRefundAmount;
        data["cardRefundAmount"] = this.cardRefundAmount;
        data["zhiFuBaoRefundAmount"] = this.zhiFuBaoRefundAmount;
        data["saleCount"] = this.saleCount;
        data["refundCount"] = this.refundCount;
        data["totalCount"] = this.totalCount;
        data["totalSaleAmount"] = this.totalSaleAmount;
        data["totalRefundAmount"] = this.totalRefundAmount;
        data["totalAmount"] = this.totalAmount;
        return data; 
    }

    clone(): SellerDailyResultDto {
        const json = this.toJSON();
        let result = new SellerDailyResultDto();
        result.init(json);
        return result;
    }
}

export interface ISellerDailyResultDto {
    /** 售票员 */
    saler: User | undefined;
    /** 现金售票金额 */
    cashSaleAmount: number | undefined;
    /** 微信售票金额 */
    weiChatSaleAmount: number | undefined;
    /** 刷卡售票金额 */
    cardSaleAmount: number | undefined;
    /** 支付宝售票金额 */
    zhiFuBaoSaleAmount: number | undefined;
    /** 现金退票金额 */
    cashRefundAmount: number | undefined;
    /** 微信退票金额 */
    weiChatRefundAmount: number | undefined;
    /** 刷卡退票金额 */
    cardRefundAmount: number | undefined;
    /** 支付宝退票金额 */
    zhiFuBaoRefundAmount: number | undefined;
    /** 售票数量 */
    saleCount: number | undefined;
    /** 退票数量 */
    refundCount: number | undefined;
    /** 数量小计 */
    totalCount: number | undefined;
    /** 销售金额小计 */
    totalSaleAmount: number | undefined;
    /** 退票金额小计 */
    totalRefundAmount: number | undefined;
    /** 应收总金额 */
    totalAmount: number | undefined;
}

export class StatsPagedResultDtoOfSellerTicketResultDto implements IStatsPagedResultDtoOfSellerTicketResultDto {
    total: SellerTicketResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: SellerTicketResultDto[] | undefined;

    constructor(data?: IStatsPagedResultDtoOfSellerTicketResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"] ? SellerTicketResultDto.fromJS(data["total"]) : <any>undefined;
            if (data["filters"]) {
                this.filters = {} as any;
                for (let key in data["filters"]) {
                    if (data["filters"].hasOwnProperty(key))
                        this.filters[key] = data["filters"][key] !== undefined ? data["filters"][key] : [];
                }
            }
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(SellerTicketResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatsPagedResultDtoOfSellerTicketResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatsPagedResultDtoOfSellerTicketResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total ? this.total.toJSON() : <any>undefined;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    data["filters"][key] = this.filters[key];
            }
        }
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StatsPagedResultDtoOfSellerTicketResultDto {
        const json = this.toJSON();
        let result = new StatsPagedResultDtoOfSellerTicketResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatsPagedResultDtoOfSellerTicketResultDto {
    total: SellerTicketResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: SellerTicketResultDto[] | undefined;
}

/** 售票员售票统计 */
export class SellerTicketResultDto implements ISellerTicketResultDto {
    /** 售票员 */
    saler: User | undefined;
    /** 现金售票金额 */
    cashSaleAmount: number | undefined;
    /** 微信售票金额 */
    weiChatSaleAmount: number | undefined;
    /** 刷卡售票金额 */
    cardSaleAmount: number | undefined;
    /** 支付宝售票金额 */
    zhiFuBaoSaleAmount: number | undefined;
    /** 现金退票金额 */
    cashRefundAmount: number | undefined;
    /** 微信退票金额 */
    weiChatRefundAmount: number | undefined;
    /** 刷卡退票金额 */
    cardRefundAmount: number | undefined;
    /** 支付宝退票金额 */
    zhiFuBaoRefundAmount: number | undefined;
    /** 现金售票数量 */
    cashSaleCount: number | undefined;
    /** 微信售票数量 */
    weiChatSaleCount: number | undefined;
    /** 刷卡售票数量 */
    cardSaleCount: number | undefined;
    /** 支付宝售票数量 */
    zhiFuBaoSaleCount: number | undefined;
    /** 现金退票数量 */
    cashRefundCount: number | undefined;
    /** 微信退票数量 */
    weiChatRefundCount: number | undefined;
    /** 刷卡退票数量 */
    cardRefundCount: number | undefined;
    /** 支付宝退票数量 */
    zhiFuBaoRefundCount: number | undefined;
    /** 现金金额小计 */
    cashTotalAmount: number | undefined;
    /** 现金数量小计 */
    cashTotalCount: number | undefined;
    /** 微信金额小计 */
    weiChatTotalAmount: number | undefined;
    /** 微信数量小计 */
    weiChatTotalCount: number | undefined;
    /** 刷卡金额小计 */
    cardTotalAmount: number | undefined;
    /** 刷卡数量小计 */
    cardTotalCount: number | undefined;
    /** 支付宝数量小计 */
    zhiFuBaoTotalCount: number | undefined;
    /** 支付宝金额小计 */
    zhiFuBaoTotalAmount: number | undefined;

    constructor(data?: ISellerTicketResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.saler = data["saler"] ? User.fromJS(data["saler"]) : <any>undefined;
            this.cashSaleAmount = data["cashSaleAmount"];
            this.weiChatSaleAmount = data["weiChatSaleAmount"];
            this.cardSaleAmount = data["cardSaleAmount"];
            this.zhiFuBaoSaleAmount = data["zhiFuBaoSaleAmount"];
            this.cashRefundAmount = data["cashRefundAmount"];
            this.weiChatRefundAmount = data["weiChatRefundAmount"];
            this.cardRefundAmount = data["cardRefundAmount"];
            this.zhiFuBaoRefundAmount = data["zhiFuBaoRefundAmount"];
            this.cashSaleCount = data["cashSaleCount"];
            this.weiChatSaleCount = data["weiChatSaleCount"];
            this.cardSaleCount = data["cardSaleCount"];
            this.zhiFuBaoSaleCount = data["zhiFuBaoSaleCount"];
            this.cashRefundCount = data["cashRefundCount"];
            this.weiChatRefundCount = data["weiChatRefundCount"];
            this.cardRefundCount = data["cardRefundCount"];
            this.zhiFuBaoRefundCount = data["zhiFuBaoRefundCount"];
            this.cashTotalAmount = data["cashTotalAmount"];
            this.cashTotalCount = data["cashTotalCount"];
            this.weiChatTotalAmount = data["weiChatTotalAmount"];
            this.weiChatTotalCount = data["weiChatTotalCount"];
            this.cardTotalAmount = data["cardTotalAmount"];
            this.cardTotalCount = data["cardTotalCount"];
            this.zhiFuBaoTotalCount = data["zhiFuBaoTotalCount"];
            this.zhiFuBaoTotalAmount = data["zhiFuBaoTotalAmount"];
        }
    }

    static fromJS(data: any): SellerTicketResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SellerTicketResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["saler"] = this.saler ? this.saler.toJSON() : <any>undefined;
        data["cashSaleAmount"] = this.cashSaleAmount;
        data["weiChatSaleAmount"] = this.weiChatSaleAmount;
        data["cardSaleAmount"] = this.cardSaleAmount;
        data["zhiFuBaoSaleAmount"] = this.zhiFuBaoSaleAmount;
        data["cashRefundAmount"] = this.cashRefundAmount;
        data["weiChatRefundAmount"] = this.weiChatRefundAmount;
        data["cardRefundAmount"] = this.cardRefundAmount;
        data["zhiFuBaoRefundAmount"] = this.zhiFuBaoRefundAmount;
        data["cashSaleCount"] = this.cashSaleCount;
        data["weiChatSaleCount"] = this.weiChatSaleCount;
        data["cardSaleCount"] = this.cardSaleCount;
        data["zhiFuBaoSaleCount"] = this.zhiFuBaoSaleCount;
        data["cashRefundCount"] = this.cashRefundCount;
        data["weiChatRefundCount"] = this.weiChatRefundCount;
        data["cardRefundCount"] = this.cardRefundCount;
        data["zhiFuBaoRefundCount"] = this.zhiFuBaoRefundCount;
        data["cashTotalAmount"] = this.cashTotalAmount;
        data["cashTotalCount"] = this.cashTotalCount;
        data["weiChatTotalAmount"] = this.weiChatTotalAmount;
        data["weiChatTotalCount"] = this.weiChatTotalCount;
        data["cardTotalAmount"] = this.cardTotalAmount;
        data["cardTotalCount"] = this.cardTotalCount;
        data["zhiFuBaoTotalCount"] = this.zhiFuBaoTotalCount;
        data["zhiFuBaoTotalAmount"] = this.zhiFuBaoTotalAmount;
        return data; 
    }

    clone(): SellerTicketResultDto {
        const json = this.toJSON();
        let result = new SellerTicketResultDto();
        result.init(json);
        return result;
    }
}

/** 售票员售票统计 */
export interface ISellerTicketResultDto {
    /** 售票员 */
    saler: User | undefined;
    /** 现金售票金额 */
    cashSaleAmount: number | undefined;
    /** 微信售票金额 */
    weiChatSaleAmount: number | undefined;
    /** 刷卡售票金额 */
    cardSaleAmount: number | undefined;
    /** 支付宝售票金额 */
    zhiFuBaoSaleAmount: number | undefined;
    /** 现金退票金额 */
    cashRefundAmount: number | undefined;
    /** 微信退票金额 */
    weiChatRefundAmount: number | undefined;
    /** 刷卡退票金额 */
    cardRefundAmount: number | undefined;
    /** 支付宝退票金额 */
    zhiFuBaoRefundAmount: number | undefined;
    /** 现金售票数量 */
    cashSaleCount: number | undefined;
    /** 微信售票数量 */
    weiChatSaleCount: number | undefined;
    /** 刷卡售票数量 */
    cardSaleCount: number | undefined;
    /** 支付宝售票数量 */
    zhiFuBaoSaleCount: number | undefined;
    /** 现金退票数量 */
    cashRefundCount: number | undefined;
    /** 微信退票数量 */
    weiChatRefundCount: number | undefined;
    /** 刷卡退票数量 */
    cardRefundCount: number | undefined;
    /** 支付宝退票数量 */
    zhiFuBaoRefundCount: number | undefined;
    /** 现金金额小计 */
    cashTotalAmount: number | undefined;
    /** 现金数量小计 */
    cashTotalCount: number | undefined;
    /** 微信金额小计 */
    weiChatTotalAmount: number | undefined;
    /** 微信数量小计 */
    weiChatTotalCount: number | undefined;
    /** 刷卡金额小计 */
    cardTotalAmount: number | undefined;
    /** 刷卡数量小计 */
    cardTotalCount: number | undefined;
    /** 支付宝数量小计 */
    zhiFuBaoTotalCount: number | undefined;
    /** 支付宝金额小计 */
    zhiFuBaoTotalAmount: number | undefined;
}

export class StatsPagedResultDtoOfScheduleTicketDetailResultDto implements IStatsPagedResultDtoOfScheduleTicketDetailResultDto {
    total: ScheduleTicketDetailResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: ScheduleTicketDetailResultDto[] | undefined;

    constructor(data?: IStatsPagedResultDtoOfScheduleTicketDetailResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"] ? ScheduleTicketDetailResultDto.fromJS(data["total"]) : <any>undefined;
            if (data["filters"]) {
                this.filters = {} as any;
                for (let key in data["filters"]) {
                    if (data["filters"].hasOwnProperty(key))
                        this.filters[key] = data["filters"][key] !== undefined ? data["filters"][key] : [];
                }
            }
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ScheduleTicketDetailResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatsPagedResultDtoOfScheduleTicketDetailResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatsPagedResultDtoOfScheduleTicketDetailResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total ? this.total.toJSON() : <any>undefined;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    data["filters"][key] = this.filters[key];
            }
        }
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StatsPagedResultDtoOfScheduleTicketDetailResultDto {
        const json = this.toJSON();
        let result = new StatsPagedResultDtoOfScheduleTicketDetailResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatsPagedResultDtoOfScheduleTicketDetailResultDto {
    total: ScheduleTicketDetailResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: ScheduleTicketDetailResultDto[] | undefined;
}

export class StatsPagedResultDtoOfTravelAgencyResultDto implements IStatsPagedResultDtoOfTravelAgencyResultDto {
    total: TravelAgencyResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: TravelAgencyResultDto[] | undefined;

    constructor(data?: IStatsPagedResultDtoOfTravelAgencyResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"] ? TravelAgencyResultDto.fromJS(data["total"]) : <any>undefined;
            if (data["filters"]) {
                this.filters = {} as any;
                for (let key in data["filters"]) {
                    if (data["filters"].hasOwnProperty(key))
                        this.filters[key] = data["filters"][key] !== undefined ? data["filters"][key] : [];
                }
            }
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TravelAgencyResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatsPagedResultDtoOfTravelAgencyResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatsPagedResultDtoOfTravelAgencyResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total ? this.total.toJSON() : <any>undefined;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    data["filters"][key] = this.filters[key];
            }
        }
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StatsPagedResultDtoOfTravelAgencyResultDto {
        const json = this.toJSON();
        let result = new StatsPagedResultDtoOfTravelAgencyResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatsPagedResultDtoOfTravelAgencyResultDto {
    total: TravelAgencyResultDto | undefined;
    filters: { [key: string] : any[]; } | undefined;
    totalCount: number | undefined;
    items: TravelAgencyResultDto[] | undefined;
}

export class TravelAgencyResultDto implements ITravelAgencyResultDto {
    /** 旅行社 */
    travelAgency: TravelAgency | undefined;
    /** 售票数量 */
    saleCount: number | undefined;
    /** 退票数量 */
    refundCount: number | undefined;
    /** 数量小计 */
    totalCount: number | undefined;
    /** 现金支付 */
    cashAmount: number | undefined;
    /** 刷卡支付 */
    cardAmount: number | undefined;
    /** 微信支付 */
    weiChatAmount: number | undefined;
    /** 支付宝支付 */
    zhiFuBaoAmount: number | undefined;
    /** 销售金额小计 */
    totalAmount: number | undefined;
    /** 现金退票 */
    cashRefund: number | undefined;
    /** 刷卡退票 */
    cardRefund: number | undefined;
    /** 微信退票 */
    weiChatRefund: number | undefined;
    /** 支付宝退票 */
    zhiFuBaoRefund: number | undefined;
    /** 退票小计 */
    totalRefund: number | undefined;
    /** 应收总金额 */
    totalAll: number | undefined;

    constructor(data?: ITravelAgencyResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.travelAgency = data["travelAgency"] ? TravelAgency.fromJS(data["travelAgency"]) : <any>undefined;
            this.saleCount = data["saleCount"];
            this.refundCount = data["refundCount"];
            this.totalCount = data["totalCount"];
            this.cashAmount = data["cashAmount"];
            this.cardAmount = data["cardAmount"];
            this.weiChatAmount = data["weiChatAmount"];
            this.zhiFuBaoAmount = data["zhiFuBaoAmount"];
            this.totalAmount = data["totalAmount"];
            this.cashRefund = data["cashRefund"];
            this.cardRefund = data["cardRefund"];
            this.weiChatRefund = data["weiChatRefund"];
            this.zhiFuBaoRefund = data["zhiFuBaoRefund"];
            this.totalRefund = data["totalRefund"];
            this.totalAll = data["totalAll"];
        }
    }

    static fromJS(data: any): TravelAgencyResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TravelAgencyResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["travelAgency"] = this.travelAgency ? this.travelAgency.toJSON() : <any>undefined;
        data["saleCount"] = this.saleCount;
        data["refundCount"] = this.refundCount;
        data["totalCount"] = this.totalCount;
        data["cashAmount"] = this.cashAmount;
        data["cardAmount"] = this.cardAmount;
        data["weiChatAmount"] = this.weiChatAmount;
        data["zhiFuBaoAmount"] = this.zhiFuBaoAmount;
        data["totalAmount"] = this.totalAmount;
        data["cashRefund"] = this.cashRefund;
        data["cardRefund"] = this.cardRefund;
        data["weiChatRefund"] = this.weiChatRefund;
        data["zhiFuBaoRefund"] = this.zhiFuBaoRefund;
        data["totalRefund"] = this.totalRefund;
        data["totalAll"] = this.totalAll;
        return data; 
    }

    clone(): TravelAgencyResultDto {
        const json = this.toJSON();
        let result = new TravelAgencyResultDto();
        result.init(json);
        return result;
    }
}

export interface ITravelAgencyResultDto {
    /** 旅行社 */
    travelAgency: TravelAgency | undefined;
    /** 售票数量 */
    saleCount: number | undefined;
    /** 退票数量 */
    refundCount: number | undefined;
    /** 数量小计 */
    totalCount: number | undefined;
    /** 现金支付 */
    cashAmount: number | undefined;
    /** 刷卡支付 */
    cardAmount: number | undefined;
    /** 微信支付 */
    weiChatAmount: number | undefined;
    /** 支付宝支付 */
    zhiFuBaoAmount: number | undefined;
    /** 销售金额小计 */
    totalAmount: number | undefined;
    /** 现金退票 */
    cashRefund: number | undefined;
    /** 刷卡退票 */
    cardRefund: number | undefined;
    /** 微信退票 */
    weiChatRefund: number | undefined;
    /** 支付宝退票 */
    zhiFuBaoRefund: number | undefined;
    /** 退票小计 */
    totalRefund: number | undefined;
    /** 应收总金额 */
    totalAll: number | undefined;
}

export class ActivateAccountModel implements IActivateAccountModel {
    emailAddress: string;
    password: string;
    userId: string | undefined;
    /** 验证码 */
    verificationCode: string | undefined;
    activateType: ActivateType | undefined;

    constructor(data?: IActivateAccountModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.userId = data["userId"];
            this.verificationCode = data["verificationCode"];
            this.activateType = data["activateType"];
        }
    }

    static fromJS(data: any): ActivateAccountModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateAccountModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["userId"] = this.userId;
        data["verificationCode"] = this.verificationCode;
        data["activateType"] = this.activateType;
        return data; 
    }

    clone(): ActivateAccountModel {
        const json = this.toJSON();
        let result = new ActivateAccountModel();
        result.init(json);
        return result;
    }
}

export interface IActivateAccountModel {
    emailAddress: string;
    password: string;
    userId: string | undefined;
    /** 验证码 */
    verificationCode: string | undefined;
    activateType: ActivateType | undefined;
}

export enum ActivateType {
    NewAccount = <any>"NewAccount", 
    BindExistAccount = <any>"BindExistAccount", 
}

export class ActivateAccountResultModel implements IActivateAccountResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    userId: number | undefined;

    constructor(data?: IActivateAccountResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ActivateAccountResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateAccountResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): ActivateAccountResultModel {
        const json = this.toJSON();
        let result = new ActivateAccountResultModel();
        result.init(json);
        return result;
    }
}

export interface IActivateAccountResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    userId: number | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    /** 验证码 */
    verificationCode: string | undefined;
    rememberClient: boolean | undefined;
    returnUrl: string | undefined;
    sourceCode: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sourceCode = "Reception";
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.verificationCode = data["verificationCode"];
            this.rememberClient = data["rememberClient"];
            this.returnUrl = data["returnUrl"];
            this.sourceCode = data["sourceCode"] !== undefined ? data["sourceCode"] : "Reception";
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["verificationCode"] = this.verificationCode;
        data["rememberClient"] = this.rememberClient;
        data["returnUrl"] = this.returnUrl;
        data["sourceCode"] = this.sourceCode;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    /** 验证码 */
    verificationCode: string | undefined;
    rememberClient: boolean | undefined;
    returnUrl: string | undefined;
    sourceCode: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    userId: number | undefined;
    shouldResetPassword: boolean | undefined;
    passwordResetCode: string | undefined;
    returnUrl: string | undefined;
    /** 需要进行账号绑定激活 */
    waitingForActivation: boolean | undefined;
    /** 游客登录Id */
    customerId: string | undefined;
    /** 游客登录Id */
    travelAgencyId: string | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.userId = data["userId"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.returnUrl = data["returnUrl"];
            this.waitingForActivation = data["waitingForActivation"];
            this.customerId = data["customerId"];
            this.travelAgencyId = data["travelAgencyId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["returnUrl"] = this.returnUrl;
        data["waitingForActivation"] = this.waitingForActivation;
        data["customerId"] = this.customerId;
        data["travelAgencyId"] = this.travelAgencyId;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    userId: number | undefined;
    shouldResetPassword: boolean | undefined;
    passwordResetCode: string | undefined;
    returnUrl: string | undefined;
    /** 需要进行账号绑定激活 */
    waitingForActivation: boolean | undefined;
    /** 游客登录Id */
    customerId: string | undefined;
    /** 游客登录Id */
    travelAgencyId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data; 
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;
    userId: number | undefined;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;
    userId: number | undefined;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string] : string; } | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
            if (data["additionalParams"]) {
                this.additionalParams = {} as any;
                for (let key in data["additionalParams"]) {
                    if (data["additionalParams"].hasOwnProperty(key))
                        this.additionalParams[key] = data["additionalParams"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        if (this.additionalParams) {
            data["additionalParams"] = {};
            for (let key in this.additionalParams) {
                if (this.additionalParams.hasOwnProperty(key))
                    data["additionalParams"][key] = this.additionalParams[key];
            }
        }
        return data; 
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string] : string; } | undefined;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }

    clone(): ImpersonatedAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }

    clone(): SwitchedAccountAuthenticateResultModel {
        const json = this.toJSON();
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
}

export class Login implements ILogin {
    loginName: string;
    loginPwd: string | undefined;
    verificationCode: string | undefined;
    rememberClient: boolean | undefined;
    returnUrl: string | undefined;
    sourceCode: string | undefined;

    constructor(data?: ILogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sourceCode = "Reception";
        }
    }

    init(data?: any) {
        if (data) {
            this.loginName = data["loginName"];
            this.loginPwd = data["loginPwd"];
            this.verificationCode = data["verificationCode"];
            this.rememberClient = data["rememberClient"];
            this.returnUrl = data["returnUrl"];
            this.sourceCode = data["sourceCode"] !== undefined ? data["sourceCode"] : "Reception";
        }
    }

    static fromJS(data: any): Login {
        data = typeof data === 'object' ? data : {};
        let result = new Login();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loginName"] = this.loginName;
        data["loginPwd"] = this.loginPwd;
        data["verificationCode"] = this.verificationCode;
        data["rememberClient"] = this.rememberClient;
        data["returnUrl"] = this.returnUrl;
        data["sourceCode"] = this.sourceCode;
        return data; 
    }

    clone(): Login {
        const json = this.toJSON();
        let result = new Login();
        result.init(json);
        return result;
    }
}

export interface ILogin {
    loginName: string;
    loginPwd: string | undefined;
    verificationCode: string | undefined;
    rememberClient: boolean | undefined;
    returnUrl: string | undefined;
    sourceCode: string | undefined;
}

export enum CaptchaType {
    Defulat = <any>"Defulat", 
    HostTenantRegister = <any>"HostTenantRegister", 
    HostUserLogin = <any>"HostUserLogin", 
    TenantUserRegister = <any>"TenantUserRegister", 
    TenantUserLogin = <any>"TenantUserLogin", 
}

export class AccessTokenResult implements IAccessTokenResult {
    access_token: string | undefined;
    expires_in: number | undefined;
    errcode: ReturnCode | undefined;
    readonly errorCodeValue: number | undefined;
    errmsg: string | undefined;
    p2PData: any | undefined;

    constructor(data?: IAccessTokenResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.access_token = data["access_token"];
            this.expires_in = data["expires_in"];
            this.errcode = data["errcode"];
            (<any>this).errorCodeValue = data["errorCodeValue"];
            this.errmsg = data["errmsg"];
            this.p2PData = data["p2PData"];
        }
    }

    static fromJS(data: any): AccessTokenResult {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["access_token"] = this.access_token;
        data["expires_in"] = this.expires_in;
        data["errcode"] = this.errcode;
        data["errorCodeValue"] = this.errorCodeValue;
        data["errmsg"] = this.errmsg;
        data["p2PData"] = this.p2PData;
        return data; 
    }

    clone(): AccessTokenResult {
        const json = this.toJSON();
        let result = new AccessTokenResult();
        result.init(json);
        return result;
    }
}

export interface IAccessTokenResult {
    access_token: string | undefined;
    expires_in: number | undefined;
    errcode: ReturnCode | undefined;
    errorCodeValue: number | undefined;
    errmsg: string | undefined;
    p2PData: any | undefined;
}

export enum ReturnCode {
    请求成功 = <any>"系统繁忙此时请开发者稍候再试", 
    工商数据返回_企业已注销 = <any>"请求成功", 
    工商数据返回_企业不存在或企业信息未更新 = <any>"获取access_token时AppSecret错误或者access_token无效", 
    工商数据返回_企业法定代表人姓名不一致 = <any>"不合法的凭证类型", 
    工商数据返回_企业法定代表人身份证号码不一致 = <any>"不合法的OpenID", 
    法定代表人身份证号码_工商数据未更新_请5_15个工作日之后尝试 = <any>"不合法的媒体文件类型", 
    工商数据返回_企业信息或法定代表人信息不一致 = <any>"不合法的文件类型", 
    对方不是粉丝 = <any>"不合法的文件大小", 
    发送消息失败_对方关闭了接收消息 = <any>"不合法的媒体文件id", 
    发送消息失败_48小时内用户未互动 = <any>"不合法的消息类型_40008", 
    POST参数非法 = <any>"不合法的图片文件大小", 
    获取access_token时AppSecret错误或者access_token无效 = <any>"不合法的语音文件大小", 
    不合法的凭证类型 = <any>"不合法的视频文件大小", 
    不合法的OpenID = <any>"不合法的缩略图文件大小", 
    不合法的媒体文件类型 = <any>"不合法的APPID", 
    不合法的文件类型 = <any>"不合法的access_token", 
    不合法的文件大小 = <any>"不合法的菜单类型", 
    不合法的媒体文件id = <any>"不合法的按钮个数1", 
    不合法的消息类型_40008 = <any>"不合法的按钮个数2", 
    不合法的图片文件大小 = <any>"不合法的按钮名字长度", 
    不合法的语音文件大小 = <any>"不合法的按钮KEY长度", 
    不合法的视频文件大小 = <any>"不合法的按钮URL长度", 
    不合法的缩略图文件大小 = <any>"不合法的菜单版本号", 
    不合法的APPID = <any>"不合法的子菜单级数", 
    不合法的access_token = <any>"不合法的子菜单按钮个数", 
    不合法的菜单类型 = <any>"不合法的子菜单按钮类型", 
    不合法的按钮个数1 = <any>"不合法的子菜单按钮名字长度", 
    不合法的按钮个数2 = <any>"不合法的子菜单按钮KEY长度", 
    不合法的按钮名字长度 = <any>"不合法的子菜单按钮URL长度", 
    不合法的按钮KEY长度 = <any>"不合法的自定义菜单使用用户", 
    不合法的按钮URL长度 = <any>"不合法的oauth_code", 
    不合法的菜单版本号 = <any>"不合法的refresh_token", 
    不合法的子菜单级数 = <any>"不合法的openid列表", 
    不合法的子菜单按钮个数 = <any>"不合法的openid列表长度", 
    不合法的子菜单按钮类型 = <any>"不合法的请求字符不能包含uxxxx格式的字符", 
    不合法的子菜单按钮名字长度 = <any>"不合法的参数", 
    不合法的子菜单按钮KEY长度 = <any>"template_id不正确", 
    不合法的子菜单按钮URL长度 = <any>"不合法的请求格式", 
    不合法的自定义菜单使用用户 = <any>"不合法的URL长度", 
    不合法的oauth_code = <any>"不合法的分组id", 
    不合法的refresh_token = <any>"分组名字不合法", 
    不合法的openid列表 = <any>"appsecret不正确", 
    不合法的openid列表长度 = <any>"小程序Appid不存在", 
    不合法的请求字符不能包含uxxxx格式的字符 = <any>"缺少access_token参数", 
    不合法的参数 = <any>"缺少appid参数", 
    Template_id不正确 = <any>"缺少refresh_token参数", 
    不合法的请求格式 = <any>"缺少secret参数", 
    不合法的URL长度 = <any>"缺少多媒体文件数据", 
    不合法的分组id = <any>"缺少media_id参数", 
    分组名字不合法 = <any>"缺少子菜单数据", 
    输入参数有误 = <any>"缺少oauth_code", 
    Appsecret不正确 = <any>"缺少openid", 
    小程序Appid不存在 = <any>"form_id不正确_或者过期", 
    缺少access_token参数 = <any>"form_id已被使用", 
    缺少appid参数 = <any>"page不正确", 
    缺少refresh_token参数 = <any>"access_token超时", 
    缺少secret参数 = <any>"refresh_token超时", 
    缺少多媒体文件数据 = <any>"oauth_code超时", 
    缺少media_id参数 = <any>"需要GET请求", 
    缺少子菜单数据 = <any>"需要POST请求", 
    缺少oauth_code = <any>"需要HTTPS请求", 
    缺少openid = <any>"需要接收者关注", 
    Form_id不正确_或者过期 = <any>"需要好友关系", 
    Form_id已被使用 = <any>"多媒体文件为空", 
    Page不正确 = <any>"POST的数据包为空", 
    Access_token超时 = <any>"图文消息内容为空", 
    Refresh_token超时 = <any>"文本消息内容为空", 
    Oauth_code超时 = <any>"多媒体文件大小超过限制", 
    需要GET请求 = <any>"消息内容超过限制", 
    需要POST请求 = <any>"标题字段超过限制", 
    需要HTTPS请求 = <any>"描述字段超过限制", 
    需要接收者关注 = <any>"链接字段超过限制", 
    需要好友关系 = <any>"图片链接字段超过限制", 
    没有权限 = <any>"语音播放时间超过限制", 
    多媒体文件为空 = <any>"图文消息超过限制", 
    POST的数据包为空 = <any>"接口调用超过限制", 
    图文消息内容为空 = <any>"创建菜单个数超过限制", 
    文本消息内容为空 = <any>"回复时间超过限制", 
    多媒体文件大小超过限制 = <any>"系统分组不允许修改", 
    消息内容超过限制 = <any>"分组名字过长", 
    标题字段超过限制 = <any>"分组数量超过上限", 
    描述字段超过限制 = <any>"不存在媒体数据", 
    链接字段超过限制 = <any>"不存在的菜单版本", 
    图片链接字段超过限制 = <any>"不存在的菜单数据", 
    语音播放时间超过限制 = <any>"解析JSON_XML内容错误", 
    图文消息超过限制 = <any>"api功能未授权", 
    接口调用超过限制 = <any>"用户未授权该api", 
    创建菜单个数超过限制 = <any>"参数错误invalid_parameter", 
    回复时间超过限制 = <any>"无效客服账号invalid_kf_account", 
    系统分组不允许修改 = <any>"客服帐号已存在kf_account_exsited", 
    分组名字过长 = <any>"客服帐号名长度超过限制", 
    分组数量超过上限 = <any>"客服帐号名包含非法字符", 
    不存在媒体数据 = <any>"客服帐号个数超过限制", 
    不存在的菜单版本 = <any>"无效头像文件类型invalid_file_type", 
    不存在的菜单数据 = <any>"系统错误system_error", 
    解析JSON_XML内容错误 = <any>"日期格式错误", 
    Api功能未授权 = <any>"日期范围错误", 
    用户未授权该api = <any>"发送消息失败_48小时内用户未互动", 
    法人姓名与微信号不一致 = <any>"发送消息失败_该用户已被加入黑名单_无法向此发送消息", 
    系统错误system_error = <any>"发送消息失败_对方关闭了接收消息", 
    参数错误invalid_parameter = <any>"对方不是粉丝", 
    无效客服账号invalid_kf_account = <any>"没有留言权限", 
    客服帐号已存在kf_account_exsited = <any>"该图文不存在", 
    客服帐号名长度超过限制 = <any>"文章存在敏感信息", 
    客服帐号名包含非法字符 = <any>"精选评论数已达上限", 
    客服帐号个数超过限制 = <any>"已被用户删除_无法精选", 
    无效头像文件类型invalid_file_type = <any>"已经回复过了", 
    日期格式错误 = <any>"回复超过长度限制或为0", 
    日期范围错误 = <any>"该评论不存在", 
    发送消息失败_该用户已被加入黑名单_无法向此发送消息 = <any>"获取评论数目不合法", 
    门店不存在 = <any>"该公众号_小程序已经绑定了开放平台帐号", 
    该门店状态不允许更新 = <any>"该主体已有任务执行中_距上次任务24h后再试", 
    标签格式错误 = <any>"内部错误", 
    页面路径错误 = <any>"无效微信号", 
    类目填写错误 = <any>"法人姓名与微信号不一致", 
    已经有正在审核的版本 = <any>"企业代码类型无效_请选择正确类型填写", 
    Item_list有项目为空 = <any>"未找到该任务", 
    标题填写错误 = <any>"待法人人脸核身校验", 
    无效的审核id = <any>"法人_企业信息一致性校验中", 
    没有审核版本 = <any>"缺少参数", 
    审核状态未满足发布 = <any>"第三方权限集不全_补全权限集全网发布后生效", 
    状态不可变 = <any>"已下发的模板消息法人并未确认且已超时_24h_未进行身份证校验", 
    Action非法 = <any>"已下发的模板消息法人并未确认且已超时_24h_未进行人脸识别校验", 
    审核列表填写的项目数不在1到5以内 = <any>"已下发的模板消息法人并未确认且已超时_24h", 
    需要补充相应资料_填写org_code和other_files参数 = <any>"工商数据返回_企业已注销", 
    管理员手机登记数量已超过上限 = <any>"工商数据返回_企业不存在或企业信息未更新", 
    该微信号已绑定5个管理员 = <any>"工商数据返回_企业法定代表人姓名不一致", 
    管理员身份证已登记过5次 = <any>"工商数据返回_企业法定代表人身份证号码不一致", 
    该主体登记数量已超过上限 = <any>"法定代表人身份证号码_工商数据未更新_请5_15个工作日之后尝试", 
    商家名称已被占用 = <any>"工商数据返回_企业信息或法定代表人信息不一致", 
    不能使用该名称 = <any>"不是由第三方代小程序进行调用", 
    该名称在侵权投诉保护期 = <any>"不存在第三方的已经提交的代码", 
    名称包含违规内容或微信等保留字 = <any>"标签格式错误", 
    商家名称在改名15天保护期内 = <any>"页面路径错误", 
    需与该帐号相同主体才可申请 = <any>"类目填写错误", 
    介绍中含有虚假混淆内容 = <any>"已经有正在审核的版本", 
    头像或者简介修改达到每个月上限 = <any>"item_list有项目为空", 
    正在审核中_请勿重复提交 = <any>"标题填写错误", 
    请先成功创建门店后再调用 = <any>"无效的审核id", 
    临时mediaid无效 = <any>"没有审核版本", 
    不是由第三方代小程序进行调用 = <any>"审核状态未满足发布", 
    不存在第三方的已经提交的代码 = <any>"状态不可变", 
    小程序还未设置昵称_头像_简介_请先设置完后再重新提交 = <any>"action非法", 
    无效微信号 = <any>"审核列表填写的项目数不在1到5以内", 
    签名错误 = <any>"小程序还未设置昵称_头像_简介_请先设置完后再重新提交", 
    内容含有违法违规内容 = <any>"签名错误", 
    没有留言权限 = <any>"内容含有违法违规内容", 
    该图文不存在 = <any>"POST参数非法", 
    文章存在敏感信息 = <any>"该经营资质已添加_请勿重复添加", 
    精选评论数已达上限 = <any>"附近地点添加数量达到上线_无法继续添加", 
    已被用户删除_无法精选 = <any>"地点已被其它小程序占用", 
    已经回复过了 = <any>"附近功能被封禁", 
    回复超过长度限制或为0 = <any>"地点正在审核中", 
    该评论不存在 = <any>"地点正在展示小程序", 
    获取评论数目不合法 = <any>"地点审核失败", 
    该公众号_小程序已经绑定了开放平台帐号 = <any>"程序未展示在该地点", 
    内部错误 = <any>"小程序未上架或不可见", 
    企业代码类型无效_请选择正确类型填写 = <any>"地点不存在", 
    该主体已有任务执行中_距上次任务24h后再试 = <any>"个人类型小程序不可用", 
    未找到该任务 = <any>"需要补充相应资料_填写org_code和other_files参数", 
    待法人人脸核身校验 = <any>"管理员手机登记数量已超过上限", 
    法人_企业信息一致性校验中 = <any>"该微信号已绑定5个管理员", 
    缺少参数 = <any>"管理员身份证已登记过5次", 
    第三方权限集不全_补全权限集全网发布后生效 = <any>"该主体登记数量已超过上限", 
    该经营资质已添加_请勿重复添加 = <any>"商家名称已被占用", 
    附近地点添加数量达到上线_无法继续添加 = <any>"不能使用该名称", 
    地点已被其它小程序占用 = <any>"该名称在侵权投诉保护期", 
    附近功能被封禁 = <any>"名称包含违规内容或微信等保留字", 
    地点正在审核中 = <any>"商家名称在改名15天保护期内", 
    地点正在展示小程序 = <any>"需与该帐号相同主体才可申请", 
    地点审核失败 = <any>"介绍中含有虚假混淆内容", 
    程序未展示在该地点 = <any>"头像或者简介修改达到每个月上限", 
    小程序未上架或不可见 = <any>"没有权限", 
    地点不存在 = <any>"正在审核中_请勿重复提交", 
    个人类型小程序不可用 = <any>"请先成功创建门店后再调用", 
    已下发的模板消息法人并未确认且已超时_24h_未进行身份证校验 = <any>"临时mediaid无效", 
    已下发的模板消息法人并未确认且已超时_24h_未进行人脸识别校验 = <any>"输入参数有误", 
    已下发的模板消息法人并未确认且已超时_24h = <any>"门店不存在", 
    系统繁忙此时请开发者稍候再试 = <any>"该门店状态不允许更新", 
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}